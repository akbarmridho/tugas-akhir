\section{Analisis Masalah}

Fenomena penjualan tiket untuk acara berskala masif, seperti konser Taylor Swift atau Coldplay, telah menjadi tolok ukur baru bagi tantangan skalabilitas sistem digital. Jutaan calon pembeli secara serentak membanjiri platform dalam hitungan menit, menciptakan lonjakan permintaan yang jauh melampaui kapasitas tiket yang tersedia. Dari perspektif pengguna, pengalaman ini sering kali diwarnai frustrasi: antrean virtual yang berlangsung berjam-jam, situs web yang tidak responsif atau gagal total, dan tiket yang habis terjual dalam sekejap mata.

Solusi yang umum diterapkan industri saat ini, seperti antrean virtual, pada dasarnya adalah mekanisme untuk membatasi beban agar tidak melumpuhkan sistem. Pendekatan ini memang menjaga stabilitas, tetapi ia tidak menyelesaikan masalah inti, yaitu bagaimana meningkatkan kapasitas pemrosesan sistem agar dapat melayani lebih banyak pengguna secara efisien dan mempercepat siklus penjualan. Di sisi lain, kajian akademis yang secara spesifik membahas dan membandingkan strategi arsitektur untuk kasus ekstrem ini masih terbatas. Penelitian seperti \cite{microservicesEventDriven} berfokus pada arsitektur yang tahan kegagalan, sementara \cite{backendForTicketing} lebih membahas pemodelan fungsionalitas; keduanya tidak mendalami aspek skalabilitas di bawah beban puncak.

Oleh karena itu, diperlukan analisis mendalam untuk merancang arsitektur yang lebih optimal. Tujuannya bukan untuk menggantikan antrean virtual, melainkan untuk melengkapinya dengan sistem inti yang jauh lebih andal, sehingga batas pengguna yang dapat dilayani secara bersamaan meningkat drastis dan proses penjualan menjadi lebih cepat. Untuk mencapai tujuan tersebut, masalah ini perlu diurai menjadi tantangan-tantangan teknis yang fundamental.

Masalah utama pada sistem tiket berskala besar dapat diurai menjadi dua fase beban kritis yang terjadi hampir bersamaan:

\begin{enumerate}
    \item \textbf{Fase Banjir Pembacaan Data (\textit{Read Flood}).} Sesaat sebelum dan ketika penjualan dibuka, aktivitas dominan adalah permintaan informasi. Jutaan pengguna secara bersamaan memuat ulang halaman untuk melihat ketersediaan tiket, baik secara agregat per kategori maupun detail per kursi. Hal ini menciptakan beban pembacaan (\textit{read load}) yang luar biasa masif pada basis data. Tantangannya, data ketersediaan ini bersifat sangat dinamis—berubah setiap detik seiring tiket dipesan. Akibatnya, mekanisme tembolok (\textit{caching}) konvensional menjadi kurang efektif karena data di tembolok cepat menjadi usang (\textit{stale}), yang dapat memberikan informasi keliru kepada pengguna.

    \item \textbf{Fase Perebutan Sumber Daya (\textit{Resource Contention}).} Ketika pengguna menemukan tiket yang tersedia, beban sistem secara drastis beralih dari dominan-baca ke dominan-tulis (\textit{write-heavy}). Fase inilah yang dikenal sebagai "perang tiket", di mana ribuan transaksi pemesanan terjadi secara bersamaan. Sifat penjualan yang "siapa cepat, dia dapat" menciptakan kondisi pacu (\textit{race condition}) yang ekstrem. Beberapa pengguna bisa jadi mencoba memesan unit tiket yang sama pada milidetik yang sama. Sistem harus mampu mengelola perebutan ini dengan sempurna untuk menjamin integritas data, memastikan tidak ada satu tiket pun yang terjual lebih dari sekali (\textit{double booking}).
\end{enumerate}

Kedua fase ini secara langsung memunculkan empat tantangan teknis utama yang harus dipecahkan:

\begin{enumerate}
    \item \textbf{Keterbatasan Laju Pemrosesan Transaksi.} Inti dari perebutan tiket adalah kemampuan basis data untuk memproses transaksi pemesanan. Basis data relasional konvensional, meskipun andal dalam menjaga konsistensi, umumnya memiliki arsitektur dengan satu instans penulis utama (\textit{single writer master}). Akibatnya, laju pemrosesan transaksi tulis dibatasi oleh kapasitas satu mesin tersebut (penskalaan vertikal). Untuk dapat melayani puluhan ribu pemesanan per detik, diperlukan strategi penskalaan horizontal (\textit{scaling out}) yang memungkinkan transaksi tulis diproses secara paralel di banyak mesin, sebuah area di mana solusi basis data relasional terdistribusi menawarkan alternatif.

    \item \textbf{Optimalisasi Kueri Ketersediaan yang Volatil.} Seperti yang telah dijelaskan, beban baca untuk data ketersediaan tiket sangatlah tinggi dan data tersebut terus berubah. Sistem memerlukan strategi khusus untuk menyajikan data ini dengan cepat dan seakurat mungkin tanpa membebani basis data utama yang sedang sibuk memproses transaksi. Ini menuntut solusi yang lebih canggih daripada sekadar tembolok biasa, yang mampu menangani agregasi data secara efisien.

    \item \textbf{Penjaminan Integritas Data di Bawah Kondisi Pacu Ekstrem.} Kegagalan dalam mengelola kondisi pacu akan berakibat fatal: tiket yang sama terjual kepada dua orang berbeda. Oleh karena itu, mekanisme transaksi pada basis data harus benar-benar kuat (\textit{atomic}) untuk mengunci sumber daya (tiket/kursi) selama proses pemesanan, dari pemilihan hingga konfirmasi, dan memastikan hanya satu transaksi yang berhasil untuk setiap unit tiket.

    \item \textbf{Kebutuhan Pengendalian Aliran untuk Menjaga Stabilitas Sistem.} Tanpa mekanisme perlindungan, banjir permintaan—termasuk permintaan yang sudah pasti gagal karena tiketnya telah dipesan pengguna lain—akan terus membebani basis data. Setiap permintaan gagal tetap mengonsumsi sumber daya (koneksi, CPU) yang berharga. Hal ini dapat meningkatkan latensi secara keseluruhan, bahkan untuk transaksi yang seharusnya berhasil, dan berisiko menyebabkan kelumpuhan sistem. Oleh karena itu, diperlukan sebuah skema pengendalian aliran (\textit{flow control}) yang cerdas untuk menyaring permintaan yang tidak perlu dan mengatur laju pemrosesan pesanan sesuai kapasitas basis data, demi menjaga stabilitas dan kinerja optimal.
\end{enumerate}

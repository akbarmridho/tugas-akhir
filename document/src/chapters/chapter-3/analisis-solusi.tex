\section{Analisis Solusi}

\subsection{Peningkatan Laju Pemrosesan Pemesanan Tiket}
Tantangan fundamental dalam sistem tiket berskala besar adalah keterbatasan laju pemrosesan transaksi tulis (\textit{write throughput}). Basis data relasional tradisional, seperti PostgreSQL dalam konfigurasi \textit{primary-replica}, menghadapi \textit{bottleneck} inheren: semua operasi tulis harus diproses oleh satu \textit{node primary}. Peningkatan kinerjanya terbatas pada penskalaan vertikal (menambah CPU, memori, dan media penyimpanan pada satu mesin), sebuah pendekatan yang mahal dan memiliki batas fisik. Oleh karena itu, arsitektur ini secara fundamental membatasi jumlah pesanan tiket yang dapat diproses secara bersamaan.

Meskipun basis data NoSQL seperti MongoDB dan Cassandra menawarkan skalabilitas tulis horizontal yang superior, solusi ini umumnya mengorbankan jaminan konsistensi transaksional kuat (ACID) yang esensial untuk sistem tiket. Dalam skenario perebutan tiket, kemampuan untuk mengeksekusi operasi secara atomik—seperti mengunci dan memesan sebuah kursi—adalah kebutuhan esensial untuk mencegah \textit{double-booking}.

Oleh karena itu, fokus solusi adalah pada ranah basis data relasional yang mampu diskalakan secara horizontal (\textit{scale-out}), atau yang dikenal sebagai Distributed SQL. Pendekatan ini menjanjikan skalabilitas tulis dari dunia NoSQL sambil mempertahankan jaminan transaksional dari dunia relasional. Dalam praktiknya, terdapat dua ekosistem utama yang dominan, yaitu ekosistem MySQL (dengan solusi seperti Vitess dan CockroachDB) dan ekosistem PostgreSQL (dengan CitusData dan YugabyteDB).

\subsubsection{Perbandingan Ekosistem PostgreSQL dan MySQL}

Kedua ekosistem menawarkan solusi yang matang dan valid untuk skalabilitas. Vitess menyediakan skalabilitas horizontal untuk MySQL, serupa dengan peran CitusData untuk PostgreSQL \parencite{vitess}. CockroachDB, yang kompatibel dengan antarmuka MySQL, merupakan basis data terdistribusi \textit{native}, sejajar dengan YugabyteDB di dunia PostgreSQL \parencite{cockroachDB}.

Meskipun demikian, ekosistem PostgreSQL dipilih untuk tugas akhir ini karena beberapa alasan strategis yang berfokus pada validitas perbandingan dan efisiensi pengembangan:

\begin{enumerate}
    \item \textbf{Konsistensi Lingkungan Pengujian:} Dengan memilih basis data yang semuanya menggunakan antarmuka PostgreSQL (PostgreSQL, CitusData, dan YugabyteDB), perbandingan kinerja menjadi lebih adil. Semua varian sistem menggunakan dialek SQL, \textit{driver}, dan \textit{tooling} yang sama. Hal ini meminimalkan variabel pembaur (\textit{confounding variables}) sehingga perbedaan kinerja yang teramati dapat lebih akurat diatribusikan pada perbedaan arsitektur fundamental basis data, bukan pada perbedaan implementasi \textit{query planner} atau protokol klien.
    \item \textbf{Kekuatan Ekstensi dan Komunitas:} PostgreSQL dikenal dengan arsitekturnya yang sangat ekstensibel, yang memungkinkan inovasi seperti CitusData untuk berkembang secara organik. Reputasinya yang kuat dalam hal kepatuhan terhadap standar SQL dan fitur-fitur canggih menjadikannya fondasi yang solid untuk eksplorasi arsitektur.
    \item \textbf{Efisiensi Pengembangan:} Keakraban penulis dengan ekosistem PostgreSQL memungkinkan fokus yang lebih mendalam pada perancangan arsitektur dan analisis hasil pengujian, alih-alih menghabiskan waktu signifikan untuk mempelajari dan beradaptasi dengan dialek SQL dan perilaku operasional ekosistem yang berbeda.
\end{enumerate}

\subsubsection{Strategi Arsitektur yang Diuji}

\paragraph{Tolok Ukur: Arsitektur Monolitik Tradisional (PostgreSQL)}

Pendekatan pertama dan paling fundamental adalah menggunakan kluster PostgreSQL standar dengan konfigurasi \textit{primary-replica}. Arsitektur ini berfungsi sebagai tolok ukur (\textit{baseline}) yang esensial dalam penelitian ini. Kinerjanya merepresentasikan solusi yang matang, andal, dan umum digunakan di industri. Dengan menetapkannya sebagai dasar perbandingan, efektivitas dari dua strategi lainnya dalam mengatasi \textit{bottleneck} penulisan dapat diukur secara kuantitatif.

\paragraph{Strategi 1: Ekstensi Terdistribusi pada Basis Data Monolitik}

Pendekatan ini memanfaatkan basis data yang matang dan teruji seperti PostgreSQL dan menambahkan kemampuan distribusi di atasnya. CitusData dipilih untuk merepresentasikan strategi ini. Sebagai ekstensi, CitusData mengubah kluster PostgreSQL menjadi basis data terdistribusi dengan arsitektur \textit{coordinator-worker} \parencite{citus}.

Kemampuan CitusData untuk melakukan pemartisian (\textit{sharding}) tabel secara horizontal di seluruh \textit{node worker} sangat relevan. Hipotesisnya adalah dengan mempartisi tabel krusial seperti TicketSeats dan Orders berdasarkan kolom seperti ticket\_area\_i, beban transaksi pemesanan dapat didistribusikan. Perebutan tiket untuk "Area A" dapat diproses oleh \textit{Worker 1}, sementara perebutan untuk "Area B" diproses secara paralel oleh \textit{Worker 2}. Secara teoretis, pendekatan ini memungkinkan sistem memproses pesanan dari berbagai kategori tiket secara bersamaan, sehingga secara signifikan meningkatkan laju pemrosesan pesanan secara keseluruhan dibandingkan dengan satu \textit{node primary} tunggal.

\paragraph{Strategi 2: Basis Data Relasional Terdistribusi Secara Natif}

Pendekatan kedua adalah menggunakan basis data yang dirancang dari awal (\textit{from the ground up}) sebagai sistem terdistribusi. Basis data ini tidak memiliki ketergantungan pada arsitektur monolitik dan dibangun dengan konsensus terdistribusi sebagai fondasinya. YugabyteDB dipilih sebagai representasi dari arsitektur ini. YugabyteDB menggunakan konsensus Raft dan arsitektur \textit{multi-writer}, di mana setiap \textit{node} dalam kluster mampu memproses operasi tulis untuk data yang disimpannya \parencite{yugabyte}.

Arsitektur YugabyteDB secara teoretis menawarkan skalabilitas tulis dan ketahanan terhadap kegagalan (\textit{fault tolerance}) yang lebih superior karena tidak adanya \textit{single point of contention} seperti \textit{node coordinator} pada CitusData. Dalam skenario perebutan tiket yang ekstrem, di mana puluhan ribu pengguna mencoba memesan tiket secara bersamaan, kemampuan untuk mendistribusikan beban tulis ke semua \textit{node} secara merata adalah keuntungan yang sangat besar. Hipotesisnya adalah YugabyteDB akan menunjukkan laju pemrosesan transaksi tertinggi di bawah beban puncak. Namun, ini datang dengan pertukaran: protokol konsensus Raft yang menjamin konsistensi data di seluruh kluster dapat memperkenalkan latensi tambahan pada setiap operasi tulis.

\subsubsection{Pemilihan Final dan Alternatif yang Dikesampingkan}

Selain kedua pendekatan di atas, pemartisian pada level aplikasi atau \textit{connection pooler} (misalnya PgCat) juga merupakan alternatif yang valid. Namun, pendekatan ini tidak dipilih karena akan memindahkan kompleksitas logika distribusi ke dalam kode aplikasi, sehingga menyulitkan perbandingan yang adil antar-teknologi basis data itu sendiri \parencite{pgcat}.

Dengan demikian, untuk menjawab rumusan masalah secara komprehensif, tiga varian basis data dipilih untuk diuji:
\begin{enumerate}
    \item Kluster PostgreSQL, sebagai tolok ukur (\textit{baseline}) yang merepresentasikan arsitektur relasional tradisional yang matang dan andal.
    \item CitusData, untuk mengevaluasi efektivitas pendekatan "menambahkan distribusi" pada basis data yang sudah ada.
    \item YugabyteDB, untuk mengevaluasi kinerja arsitektur "terdistribusi secara \textit{native}" yang dirancang untuk skalabilitas \textit{cloud-native}.
\end{enumerate}

Pemilihan basis data yang seluruhnya kompatibel dengan antarmuka PostgreSQL memungkinkan pengembangan aplikasi yang sama untuk digunakan di ketiga varian, sehingga memastikan perbandingan kinerja yang lebih adil dan terfokus pada kapabilitas arsitektur basis data masing-masing.

\subsection{Pengoptimalan Operasi Baca Ketersediaan Tiket}

Berdasarkan referensi pemodelan sistem tiket, terdapat dua operasi baca ketersediaan tiket, yaitu operasi baca agregat ketersediaan berdasarkan area dan operasi baca ketersediaan kursi pada area.

Operasi pembacaan ketersediaan berdasarkan area merupakan operasi agregat terhadap data yang selalu diperbarui dan merupakan operasi yang paling banyak dipanggil mengikuti banyaknya pengguna yang ada. Keterbaruan data merupakan aspek penting, sehingga penggunaan tembolok tidak serta merta dapat digunakan.

Penggunaan denormalisasi pada level basis data dapat digunakan, seperti menambahkan kolom sisa kursi tersedia. Meskipun begitu, pendekatan ini tidak dapat digunakan karena dapat menimbulkan \textit{contention} apabila sistem ingin meningkatkan laju penulisan sebanyak-banyaknya. Oleh karena itu, kolom hasil agregat ini tidak disimpan pada basis data, tetapi disimpan pada Redis yang dapat menangani hal ini dengan lebih baik. Sama seperti sebelumnya, tantangan pendekatan ini adalah bagaimana caranya memastikan data yang ada pada basis data dengan Redis tetap sinkron, terutama pada skenario yang memiliki banyak kegagalan.

Operasi berikutnya adalah operasi baca ketersediaan kursi pada suatu area. Operasi ini membutuhkan data berdasarkan baris. Operasi ini memang lebih baik apabila langsung memanggil basis data. Meskipun begitu, pada lonjakan pengunjung yang tinggi, operasi tersebut dapat membebani basis data. Dari sisi keterbaruan data, data yang 150 milisekon lebih lama tidak akan jauh berbeda dengan data paling terbaru. Terlebih lagi, sistem ini bukan sistem yang sangat sensitif sehingga perbedaan sekian milisekon akan mempengaruhi hasil secara signifikan. Pertukaran kinerja yang ditawarkan dengan pendekatan ini membuat penggunaan tembolok secara mikro jauh lebih bermanfaat untuk menjaga stabilitas sistem. Penyimpanan tembolok dapat diimplementasikan dengan menggunakan hashmap di memori untuk latensi yang lebih baik. Waktu hidup tembolok sebesar 150 milisekon membuat penggunaan Redis tidak cocok karena perbedaan latensi yang bisa menjadi sangat signifikan.

\subsection{Integritas data dan Pencegahan Pesanan Ganda}

Pemesanan tiket dibagi menjadi dua tahap, yaitu fase \textit{hold seating} dan fase penyelesaian pesanan. Fase \textit{hold seating} akan mencadangkan tiket sampai batas waktu tertentu hingga pengguna menyelesaikan pembayaran. Saat pembayaran berhasil, pembelian tiket baru akan dianggap sukses.

Penggunaan basis data relasional seperti PostgreSQL memungkinkan implementasi pemesanan tiket yang lebih mudah dan terjamin konsistensinya. Untuk mencegah pemesanan ganda, basis data dapat melakukan penguncian pada level baris di dalam transaksi, sehingga setiap tiket hanya terjual sebanyak satu kali.

Pada pemesanan berdasarkan nomor kursi secara langsung, hal ini dapat diimplementasikan dengan memulai transaksi, lalu melakukan kueri "SELECT WHERE available FOR UPDATE" untuk baris data yang ingin dikunci. Kueri tersebut akan gagal apabila terdapat transaksi lain yang sedang mengakses data yang sama.

Pemesanan berdasarkan area tertentu (tidak memilih nomor kursi) memiliki pendekatan yang serupa dengan menggunakan kueri "SELECT WHERE available FOR UPDATE SKIP LOCKED". Kueri ini akan mengembalikan data yang tersedia untuk dikunci dan bertindak sebagai antrean untuk alokasi kursi virtual pada tiket \textit{free standing}.

\subsection{Penggunaan Skema Pengendalian Aliran Pada Pemesanan Tiket}

Dengan banyaknya pengguna yang ingin memesan tiket pada satu waktu, basis data akan cukup sibuk menangani transaksi gagal dan menangani konflik selama proses transaksional. Sebagaimana dibahas sebelumnya, penggunaan pengendalian aliran menarik untuk dieksplorasi lebih lanjut pengaruhnya terhadap kinerja sistem tiket. Setidaknya terdapat dua strategi pengendalian aliran yang dapat digunakan pada operasi pemesanan tiket, yaitu penggunaan antrian dan penolakan permintaan.

\subsubsection{Penolakan Permintaan Lebih Awal}

Tentunya penolakan permintaan lebih awal harus dilakukan secara strategis agar dapat mengurangi beban tanpa menghalangi pembelian tiket yang masih tersedia. Ide dasar yang dapat digunakan adalah dengan membuang permintaan terhadap kursi yang sudah terjual atau akan terjual (terdapat permintaan lain yang memesan kursi yang sama, tetapi belum \textit{commited} atau pesanannya masih diproses oleh sistem). Proses ini dapat dilimpahkan pada basis data yang memiliki latensi rendah seperti Redis. Tantangan pendekatan ini berada pada bagaimana cara memastikan data ketersediaan pada basis data dengan data ketersediaan pada Redis tetap tersinkronisasi terutama saat banyak terjadi kegagalan pada sistem.

Hal yang harus diperhatikan dari penggunaan Redis adalah aspek persistensi. Redis memiliki dua jenis persistensi, yaitu \textit{snapshot} dan \textit{Append-Only File}. Tentunya pada kasus ini persistensi penting untuk memitigasi kegagalan. Pengaturan yang paling direkomendasikan adalah penggunaan \textit{snapshot} dengan \textit{append-only file} (AOF). Pengaturan AOF sendiri memiliki dua pengaturan, yaitu \textit{everysec} dan \textit{always}. Opsi \textit{everysec} dipilih karena merupakan pengaturan yang menyeimbangkan kinerja dengan persistensi. Sekalipun terjadi kegagalan, data yang terdapat pada Redis dapat dibuat ulang dan permintaan yang tidak dapat ditolak pada tahap ini tetap akan ditolak pada tahap berikutnya.

\subsubsection{Penggunaan Antrean Pemrosesan Pesanan}

Penggunaan antrean didasari pada ide bahwa basis data akan kesulitan menangani banyak permintaan secara bersamaan. Banyaknya permintaan yang menumpuk mengakibatkan latensi yang tinggi dan seringkali basis data tidak dapat pulih dari kondisi tersebut kecuali bebannya dikurangi secara signifikan. Oleh karena itu, penting agar menjaga basis data pada utilisasi yang optimal sehingga basis data dapat beroperasi dengan baik. Oleh karena itu, proses pemrosesan pemesanan tiket seharusnya disesuaikan berdasarkan kapasitas basis data untuk menjaga stabilitas sistem.

Pada tugas akhir ini, pemrosesan pesanan yang sesuai dengan kapasitas sistem diimplementasikan dengan cara yang sederhana, yaitu membatasi banyaknya pesanan yang diproses pada satu waktu hingga jumlah tertentu. Penggunaan algoritma yang lebih canggih dapat digunakan, tetapi hal tersebut bukan merupakan fokus dari tugas akhir ini.

Apakah pendekatan ini berarti menjadikan proses pemesanan tiket menjadi asinkron? belum tentu. Operasi ini tetap diimplementasikan secara sinkron yang berupa pemanggilan HTTP lalu menunggu respons dari server. Hanya saja, permintaan pengguna dipindahkan ke antrean terlebih dahulu. Pertukaran dari implementasi ini adalah latensi yang lebih tinggi yang akan dirasakan dari sisi pengguna. Klasifikasi yang tepat adalah pemrosesan permintaan secara sinkron dengan pemrosesan dari sisi \textit{backend} asinkron.

Pendekatan tersebut memunculkan masalah baru terutama perihal penanganan kegagalan atau permintaan yang melewati batas waktu tertentu. Untuk menangani hal tersebut, implementasi proses pemesanan tiket dapat dibuat idempoten dengan menyertakan kunci idempotensi. Dengan begitu, apabila sebuah pemesanan tiket melewati batas waktu dari sisi klien, pesanan tetap diproses dengan sukses oleh server sebagaimana mestinya tanpa harus membuat pesanan baru.

Pertimbangan berikutnya adalah pemilihan platform antrean. Dari sisi kinerja, penggunaan platform penyiaran \textit{event} seperti Kafka atau Redpanda menawarkan latensi yang jauh lebih baik dengan penskalaan yang jauh lebih baik \parencite{comparingKafkaAlternatives}. meskipun begitu, beban implementasi untuk menjadikan platform tersebut sebagai platform antrean tradisional membutuhkan investasi yang tinggi, sehingga tidak dapat diimplementasikan dalam waktu yang singkat. Oleh karena itu, platform antrean tradisional seperti RabbitMQ dipilih karena memiliki beban implementasi yang lebih rendah dan \textit{deployment} yang lebih mudah. Solusi ini merupakan solusi yang sudah terbukti dan memilki fitur yang lengkap. Selain itu, meskipun beban yang diterima sangat tinggi, pada akhirnya jumlah permintaan yang masuk untuk proses pemesanan tiket akan jauh lebih sedikit sehingga keterbatasan penskalaan pada RabbitMQ tidak akan menjadi masalah.

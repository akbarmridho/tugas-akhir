\section{Analisis Solusi}

\subsection{Peningkatan Laju Pemrosesan Pemesanan Tiket}

Penskalaan laju pemrosesan penulisan pada basis data relasional tradisional seperti PostgreSQL terbatas pada maksimal CPU, Memori, dan laju media penyimpanan yang dapat digunakan oleh suatu komputer. Penskalaan ini memiliki batas dari sisi teknologi dan peningkatan biayanya tidak sebanding dengan peningkatan kinerja yang dihasilkan. Oleh karena itu, skema PostgreSQL dengan \textit{primary} dan \textit{replica} memiliki keterbatasan dari sisi penulisan.

Penggunaan basis data nonrelasional berbasikan dokumen seperti MongoDB memang menarik karena menawarkan laju penulisan yang jauh lebih baik. Meskipun begitu, basis data tersebut tidak memiliki dukungan kueri transaksional sebagaimana yang dimiliki pada basis data relasional. Hal yang sama juga terjadi dengan penggunaan basis data berbasiskan \textit{wide-column}.

Ide yang menyatakan bahwa penskalaan basis data relasional buruk perlu dipertanyakan karena keduanya memiliki pemodelan entitas yang jauh berbeda. Oleh karena itu, penelitian ini akan mengeksporasi basis data relasional yang dapat di-\textit{scale-out} sehingga laju penulisan dapat meningkat.

Terdapat berbagai alternatif basis data relasional yang merupakan pengembangan dari basis data tradisional. PostgreSQL dan MySQL merupakan basis data relasional yang sudah umum diketahui. Di sisi lain, terdapat CitusData yang merupakan ekstensi PostgreSQL dan memungkinkan PostgreSQL mendukung beberapa penulis dengan skema permartisian baik dari sisi skema atau pun data \parencite{citus}. Hal yang sama juga terjadi pada ekosistem MySQL dengan Vitess \parencite{vitess}.

Selain itu, terdapat basis data yang bukan merupakan pengembangan dari basis data yang ada seperti PostgreSQL dan MySQL dan merupakan pengembangan basis data yang dimulai dari nol dengan penggunaan konsensus Raft seperti RocksDB atau LevelDB. Meskipun begitu, basis data seperti itu tetap mengimplementasikan antarmuka yang sama pada PostgreSQL dan MySQL. CockroachDB merupakan basis data jenis ini yang kompatibel dengan antarmuka MySQL \parencite{cockroachDB}. YugaByteDB merupakan basis data jenis ini yang kompatible dengan antarmuka PostgreSQL \parencite{yugabyte}. Penggunaan basis data tersebut menarik untuk diuji kinerjanya dibandingkan dengan basis data biasa dan menarik untuk diketahui apakah penggunaan teknologi tersebut dapat membantu kinerja sistem tiket yang dibahas pada penelitian ini.

Dari sekian banyak alternatif basis data relasional, perlu dipilih basis data yang masing-masing dapat merepresentasikan pendekatan yang dipakai pada basis data tersebut. Basis data yang mendukung antarmuka PostgreSQL dipilih karena keakraban dengan teknologi tersebut. Selain itu, pemilihan basis data dengan antarmuka yang sama memungkinkan pengembangan yang lebih mudah dan perbandingan kinerja yang lebih adil. Oleh karena itu, kluster PostgreSQL dipilih sebagai basis data yang menjadi dasar acuan, CitusData dipilih sebagai basis data yang mengembangkan PostgreSQL, sedangkan YugaByteDB dipilih sebagai basis data dengan ide berbeda, tetapi tetap mengimplementasikan antarmuka PostgreSQL.

\subsection{Pengoptimalan Operasi Baca Ketersediaan Tiket}

Berdasarkan referensi pemodelan sistem tiket, terdapat dua operasi baca ketersediaan tiket, yaitu operasi baca agregat ketersediaan berdasarkan area dan operasi baca ketersediaan kursi pada area.

Operasi pembacaan ketersediaan berdasarkan area merupakan operasi agregat terhadap data yang selalu diperbarui dan merupakan operasi yang paling banyak dipanggil mengikuti banyaknya pengguna yang ada. Keterbaruan data merupakan aspek penting, sehingga penggunaan tembolok tidak serta merta dapat digunakan.

Penggunaan denormalisasi pada level basis data dapat digunakan, seperti menambahkan kolom sisa kursi tersedia. Meskipun begitu, pendekatan ini tidak dapat digunakan karena dapat menimbulkan \textit{contention} apabila sistem ingin meningkatkan laju penulisan sebanyak-banyaknya. Oleh karena itu, kolom hasil agregat ini tidak disimpan pada basis data, tetapi disimpan pada Redis yang dapat menangani hal ini dengan lebih baik. Sama seperti sebelumnya, tantangan pendekatan ini adalah bagaimana caranya memastikan data yang ada pada basis data dengan Redis tetap sinkron, terutama pada skenario yang memiliki banyak kegagalan.

Operasi berikutnya adalah operasi baca ketersediaan kursi pada suatu area. Operasi ini membutuhkan data berdasarkan baris. Operasi ini memang lebih baik apabila langsung memanggil basis data. Meskipun begitu, pada lonjakan pengunjung yang tinggi, operasi tersebut dapat membebani basis data. Dari sisi keterbaruan data, data yang 150 milisekon lebih lama tidak akan jauh berbeda dengan data paling terbaru. Terlebih lagi, sistem ini bukan sistem yang sangat sensitif sehingga perbedaan sekian milisekon akan mempengaruhi hasil secara signifikan. Pertukaran kinerja yang ditawarkan dengan pendekatan ini membuat penggunaan tembolok secara mikro jauh lebih bermanfaat untuk menjaga stabilitas sistem. Penyimpanan tembolok dapat diimplementasikan dengan menggunakan hashmap di memori untuk latensi yang lebih baik. Waktu hidup tembolok sebesar 150 milisekon membuat penggunaan Redis tidak cocok karena perbedaan latensi yang bisa menjadi sangat signifikan.

\subsection{Integritas data dan Pencegahan Pesanan Ganda}

Pemesanan tiket dibagi menjadi dua tahap, yaitu fase \textit{hold seating} dan fase pembayaran. Fase \textit{hold seating} akan mencadangkan tiket sampai batas waktu tertentu hingga pengguna menyelesaikan fase pembayaran. Saat pembayaran berhasil, pembelian tiket baru akan dianggap sukses.

Penggunaan basis data relasional seperti PostgreSQL memungkinkan implementasi pemesanan tiket yang lebih mudah dan terjamin konsistensinya. Untuk mencegah pemesanan ganda, basis data dapat melakukan penguncian pada level baris di dalam transaksi, sehingga setiap tiket hanya terjual sebanyak satu kali.

Pada pemesanan berdasarkan nomor kursi secara langsung, hal ini dapat diimplementasikan dengan memulai transaksi, lalu melakukan kueri "SELECT WHERE available FOR UPDATE" untuk baris data yang ingin dikunci. Kueri tersebut akan gagal apabila terdapat transaksi lain yang sedang mengakses data yang sama.

Pemesanan berdasarkan area tertentu (tidak memilih nomor kursi) memiliki pendekatan yang serupa dengan menggunakan kueri "SELECT WHERE available FOR UPDATE SKIP LOCKED". Kueri ini akan mengembalikan data yang tersedia untuk dikunci dan bertindak sebagai antrean untuk alokasi kursi virtual pada tiket \textit{free standing}.

\subsection{Penggunaan Skema Pengendalian Aliran Pada Pemesanan Tiket}

Dengan banyaknya pengguna yang ingin memesan tiket pada satu waktu, basis data akan cukup sibuk menangani transaksi gagal dan menangani konflik selama proses transaksional. Sebagaimana dibahas sebelumnya, penggunaan pengendalian aliran menarik untuk dieksplorasi lebih lanjut pengaruhnya terhadap kinerja sistem tiket. Setidaknya terdapat dua strategi pengendalian aliran yang dapat digunakan pada operasi pemesanan tiket, yaitu penggunaan antrian dan penolakan permintaan.

\subsubsection{Penolakan Permintaan Lebih Awal}

Tentunya penolakan permintaan lebih awal harus dilakukan secara strategis agar dapat mengurangi beban tanpa menghalangi pembelian tiket yang masih tersedia. Ide dasar yang dapat digunakan adalah dengan membuang permintaan terhadap kursi yang sudah terjual atau akan terjual (terdapat permintaan lain yang memesan kursi yang sama, tetapi belum \textit{commited} atau pesanannya masih diproses oleh sistem). Proses ini dapat dilimpahkan pada basis data yang memiliki latensi rendah seperti Redis. Tantangan pendekatan ini berada pada bagaimana cara memastikan data ketersediaan pada basis data dengan data ketersediaan pada Redis tetap tersinkronisasi terutama saat banyak terjadi kegagalan pada sistem.

Hal yang harus diperhatikan dari penggunaan Redis adalah aspek persistensi. Redis memiliki dua jenis persistensi, yaitu \textit{snapshot} dan \textit{Append-Only File}. Tentunya pada kasus ini persistensi penting untuk memitigasi kegagalan. Pengaturan yang paling direkomendasikan adalah penggunaan \textit{snapshot} dengan \textit{append-only file} (AOF). Pengaturan AOF sendiri memiliki dua pengaturan, yaitu \textit{everysec} dan \textit{always}. Opsi \textit{everysec} dipilih karena merupakan pengaturan yang menyeimbangkan kinerja dengan persistensi. Sekalipun terjadi kegagalan, data yang terdapat pada Redis dapat dibuat ulang dan permintaan yang tidak dapat ditolak pada tahap ini tetap akan ditolak pada tahap berikutnya.

\subsubsection{Penggunaan Antrean Pemrosesan Pesanan}

Penggunaan antrean didasari pada ide bahwa basis data akan kesulitan menangani banyak permintaan secara bersamaan. Banyaknya permintaan yang menumpuk mengakibatkan latensi yang tinggi dan seringkali basis data tidak dapat pulih dari kondisi tersebut kecuali bebannya dikurangi secara signifikan. Oleh karena itu, penting agar menjaga basis data pada utilisasi yang optimal sehingga basis data dapat beroperasi dengan baik. Oleh karena itu, proses pemrosesan pemesanan tiket seharusnya disesuaikan berdasarkan kapasitas basis data untuk menjaga stabilitas sistem.

Pada penelitian ini, pemrosesan pesanan yang sesuai dengan kapasitas sistem diimplementasikan dengan cara yang sederhana, yaitu membatasi banyaknya pesanan yang diproses pada satu waktu hingga jumlah tertentu. Penggunaan algoritma yang lebih canggih dapat digunakan, tetapi hal tersebut bukan merupakan fokus dari penelitian ini.

Apakah pendekatan ini berarti menjadikan proses pemesanan tiket menjadi asinkron? belum tentu. Operasi ini tetap diimplementasikan secara sinkron yang berupa pemanggilan HTTP lalu menunggu respons dari server. Hanya saja, permintaan pengguna dipindahkan ke antrean terlebih dahulu. Pertukaran dari implementasi ini adalah latensi yang lebih tinggi yang akan dirasakan dari sisi pengguna. Klasifikasi yang tepat adalah \textit{partial synchrony}. Sistem ini sinkron pada sebagian besar waktu, tetapi dapat menjadi asinkron saat terjadi hal-hal yang tidak diinginkan.

Pendekatan tersebut memunculkan masalah baru terutama perihal penanganan kegagalan atau permintaan yang melewati batas waktu tertentu. Untuk menangani hal tersebut, implementasi proses pemesanan tiket dapat dibuat idempoten dengan menyertakan kunci idempotensi. Dengan begitu, apabila sebuah pemesanan tiket melewati batas waktu dari sisi klien, pesanan tetap diproses dengan sukses oleh server sebagaimana mestinya tanpa harus membuat pesanan baru.

Pertimbangan berikutnya adalah pemilihan platform antrean. Dari sisi kinerja, penggunaan platform penyiaran \textit{event} seperti Kafka atau Redpanda menawarkan latensi yang jauh lebih baik dengan penskalaan yang jauh lebih baik \parencite{comparingKafkaAlternatives}. meskipun begitu, beban implementasi untuk menjadikan platform tersebut sebagai platform antrean tradisional membutuhkan investasi yang tinggi, sehingga tidak dapat diimplementasikan dalam waktu yang singkat. Oleh karena itu, platform antrean tradisional seperti RabbitMQ dipilih karena memiliki beban implementasi yang lebih rendah dan \textit{deployment} yang lebih mudah. Solusi ini merupakan solusi yang sudah terbukti dan memilki fitur yang lengkap. Selain itu, meskipun beban yang diterima sangat tinggi, pada akhirnya jumlah permintaan yang masuk untuk proses pemesanan tiket akan jauh lebih sedikit sehingga keterbatasan penskalaan pada RabbitMQ tidak akan menjadi masalah.

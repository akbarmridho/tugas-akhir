\section{Analisis Solusi}

\subsection{Pencegahan \textit{Double Booking}}

Penggunaan basis data relasional seperti PostgreSQL memungkinkan implementasi pemesanan tiket yang lebih mudah dan terjamin konsistensinya. Untuk mencegah \textit{double booking}, basis data dapat melakukan \textit{row-level locking} di dalam transaksi, sehingga setiap \textit{seat} hanya terjual sebanyak satu kali.

\subsection{Peningkatan \textit{Raw Throughput} Pemesanan Tiket}

Penskalaan \textit{throughpupt} penulisan pada basis data relasional tradisional seperti PostgreSQL terbatas pada maksimal CPU, Memori, dan \textit{throughput} media penyimpanan yang dapat digunakan oleh suatu komputer. Penskalaan ini memiliki batas dari sisi teknologi dan peningkatan biayanya tidak sebanding dengan peningkatan kinerja yang dihasilkan. Oleh karena itu, skema PostgreSQL dengan \textit{primary} dan \textit{replica} memiliki keterbatasan dari sisi penulisan.

Penggunaan basis data nonrelasional berbasikan dokumen seperti MongoDB memang menarik karena menawarkan \textit{throughput} yang jauh lebih baik. Meskipun begitu, basis data tersebut tidak memiliki dukungan kueri transaksional sebagaimana yang dimiliki pada basis data relasional. Hal yang sama juga terjadi dengan penggunaan basis data berbasiskan \textit{wide-column}. Ide yang menyatakan bahwa basis data relasional tidak \textit{scalable} perlu dipertanyakan karena keduanya memiliki pemodelan entitas yang jauh berbeda. Oleh karena itu, penelitian ini akan mengeksporasi basis data relasional yang dapat di-\textit{scale-out} sehingga \textit{write throughput} dapat meningkat.

Terdapat berbagai alternatif basis data relasional yang merupakan pengembangan dari basis data tradisional. PostgreSQL dan MySQL merupakan basis data relasional yang sudah umum diketahui. Di sisi lain, terdapat CitusData yang merupakan ekstensi PostgreSQL dan memungkinkan PostgreSQL mendukung \textit{multiple-writer} dengan skema \textit{sharding} baik dari sisi skema atau pun data \parencite{citus}. Hal yang sama juga terjadi pada ekosistem MySQL dengan Vitess \textit{Vitess}. Selain itu, terdapat basis data yang bukan merupakan pengembangan dari basis data yang ada seperti PostgreSQL dan MySQL dan merupakan pengembangan basis data yang dimulai dari nol dengan penggunaan konsensus seperti Raft dan protokol \textit{low-level} seperti RocksDB atau LevelDB. Meskipun begitu, basis data seperti itu tetap mengimplementasikan antarmuka yang sama pada PostgreSQL dan MySQL. CockroachDB merupakan basis data jenis ini yang kompatibel dengan antarmuka MySQL \parencite{cockroachDB}. YugaByteDB merupakan basis data jenis ini yang kompatible dengan antarmuka PostgreSQL \parencite{yugabyte}. Penggunaan basis data tersebut menarik untuk diuji kinerjanya dibandingkan dengan basis data biasa dan menarik untuk diketahui apakah penggunaan teknologi tersebut dapat membantu kinerja sistem tiket yang dibahas pada penelitian ini.

Dari sekian banyak alternatif basis data relasional, perlu dipilih basis data yang masing-masing dapat merepresentasikan pendekatan yang dipakai pada basis data tersebut. Basis data yang mendukung antarmuka PostgreSQL dipilih karena keakraban dengan teknologi tersebut. Selain itu, pemilihan basis data dengan antarmuka yang sama memungkinkan pengembangan yang lebih mudah dan perbandingan kinerja yang lebih adil. Oleh karena itu, PostgreSQL dipilih sebagai basis data yang menjadi dasar acuan, CitusData dipilih sebagai basis data yang mengembangkan PostgreSQL, sedangkan YugaByteDB dipilih sebagai basis data dengan ide berbeda, tetapi tetap mengimplementasikan antarmuka PostgreSQL.

\subsection{Penggunaan Skema \textit{Flow Control} Pada Pemesanan Tiket}

Dengan banyaknya pengguna yang ingin memesan tiket pada satu waktu, kemungkinan terjadinya \textit{write contention} sangat tinggi. Bila tidak ditangani dengan baik, kesalahan seperti \textit{double booking} dapat terjadi. Selain itu, basis data akan cukup sibuk menangani transaksi gagal dan menangani konflik selama proses kueri transaksional. Sebagaimana dibahas sebelumnya, penggunaan \textit{flow control} menarik untuk dieksplorasi lebih lanjut pengaruhnya terhadap kinerja sistem tiket. Setidaknya terdapat dua strategi \textit{flow control} yang dapat digunakan pada operasi pemesanan tiket, yaitu penggunaan \textit{buffer} atau antrian dan \textit{drop request}. Tentunya proses \textit{drop request} harus dilakukan secara strategis agar dapat mengurangi \textit{contention} tanpa menghalangi pembelian tiket yang masih tersedia. Ide dasar yang dapat digunakan adalah dengan membuang permintaan terhadap kursi yang sudah terjual atau akan terjual (terdapat \textit{request} lain yang memesan kursi yang sama, tetapi belum \textit{commited} atau pesanannya masih diproses oleh sistem). Proses \textit{filter} ini dapat dilimpahkan pada basis data yang memiliki latensi rendah seperti Redis. Meskipun begitu, tantangan pendekatan ini berada pada bagaimana cara memastikan data ketersediaan pada basis data dengan data ketersediaan pada Redis tetap tersinkronisasi terutama saat banyak terjadi kegagalan pada sistem.

Hal yang harus diperhatikan dari penggunaan Redis adalah aspek \textit{persistence}. Redis memiliki dua jenis \textit{persistence}, yaitu \textit{snapshot} dan \textit{Append-Only File}. Tentunya pada kasus ini \textit{persistence} penting untuk memitigasi kegagalan. Pengaturan yang paling direkomendasikan adalah penggunaan \textit{snapshot} dengan \textit{append-only file} (AOF). Pengaturan AOF sendiri memiliki dua pengaturan, yaitu \textit{everysec} dan \textit{always}. Opsi \textit{everysec} dipilih karena merupakan pengaturan yang menyeimbangkan kinerja dengan \textit{persistence}. Sekalipun terjadi kegagalan, data yang terdapat pada Redis dapat dibuat ulang dan permintaan yang tidak dapat ditolak pada tahap ini tetap akan ditolak pada tahap berikutnya.

Selain itu, penggunaan \textit{queue} didasari pada ide bahwa basis data akan kesulitan menangani banyak \textit{concurrent request}. Banyaknya \textit{request} yang menumpuk mengakibatkan latensi yang tinggi dan seringkali basis data tidak dapat \textit{recover} dari kondisi tersebut kecuali bebannya dikurangi secara signifikan. Oleh karena itu, penting agar menjaga basis data pada utilisasi yang optimal sehingga basis data dapat beroperasi dengan baik. Oleh karena itu, proses pemrosesan pemesanan tiket seharusnya disesuaikan berdasarkan kapasitas basis data untuk menjaga stabilitas sistem.

Apakah itu berarti proses pemesanan tiket menjadi asinkron? belum tentu. Operasi ini tetap diimplementasikan secara sinkron yang berupa pemanggilan HTTP lalu meunggu respons dari server. Hanya saja, permintaan pengguna di-\textit{queue} terlebih dahulu. \textit{Tradeoff} dari implementasi ini adalah latensi yang lebih tinggi yang akan dirasakan dari sisi pengguna. Klasifikasi yang tepat adalah \textit{partial synchrony}. Sistem ini \textit{synchronous} pada sebagian besar waktu, tetapi dapat menjadi asinkron saat terjadi hal-hal yang tidak diinginkan.

Dengan pendekatan seperti itu muncul masalah terutama bagaimana menangani kegagalan atau permintaan yang melewati batas waktu tertentu. Untuk menangani hal tersebut, implementasi proses pemesanan tiket dapat dibuat idempoten dengan menyertakan \textit{idempotency key} sehingga apabila sebuah pemesanan tiket mengalami \textit{timeout} dari sisi klien, tetapi tetap diproses dengan sukses oleh server meski setelah beberapa waktu tertentu, proses pemesanan tetap dapat dilanjutkan sebagaimana mestinya tanpa harus membuat pesanan baru.

Konsiderasi berikutnya adalah pemiilhan broker \textit{message queue}. Dari sisi kinerja, penggunaan \textit{event-streaming platform} seperti Kafka atau Redpanda menawarkan latensi yang jauh lebih baik dengan penskalaan yang jauh lebih baik \parencite{comparingKafkaAlternatives}. meskipun begitu, \textit{overhead} implementasi untuk menjadikan \textit{platform} tersebut sebagai \textit{message queue platform} tradisional membutuhkan investasi yang tinggi, sehingga tidak dapat diimplementasikan dalam waktu yang singkat. Oleh karena itu, \textit{message queue platform} tradisional seperti RabbitMQ dipilih karena memiliki \textit{overhead} implementasi yang lebih rendah dan \textit{deployment} yang lebih mudah. Solusi ini merupakan solusi yang sudah terbukti dan memilki fitur yang lengkap. Selain itu, meskipun beban yang diterima sangat tinggi, pada akhirnya jumlah permintaan yang masuk untuk proses pemesanan tiket akan jauh lebih sedikit sehingga keterbatasan penskalaan pada RabbitMQ tidak akan menjadi masalah.

\subsection{Pengoptimalan Operasi Baca Ketersediaan Tiket}

Pada sistem referensi, terdapat dua operasi baca ketersediaan tiket, yaitu operasi baca ketersediaan berdasarkan area dan operasi baca ketersediaan kursi berdasarkan area.

Operasi pembacaan ketersediaan berdasarkan area merupakan operasi agregat terhadap data yang selalu diperbarui dan merupakan operasi yang paling banyak dipanggil mengikuti banyaknya pengguna yang ada. Keterbaruan data merupakan aspek penting, sehingga penggunaan \textit{cache} tidak serta merta dapat digunakan.

Penggunaan denormalisasi pada level basis data dapat digunakan, seperti menambahkan kolom sisa kursi tersedia. Meskipun begitu, pendekatan ini tidak dapat digunakan karena dapat menimbulkan \textit{contention} apabila sistem ingin meningkatkan \textit{throughput} penulisan sebanyak-banyaknya. Oleh karena itu, kolom hasil agregat ini tidak disimpan pada basis data, tetapi disimpan pada Redis yang dapat menangani hal ini dengan lebih baik. Sama seperti sebelumnya, tantangan pendekatan ini adalah bagaimana caranya memastikan data yang ada pada basis data dengan Redis tetap sinkron, terutama pada skenario yang memiliki banyak kegagalan.

Operasi berikutnya adalah operasi baca ketersediaan kursi berdasarkan area. Operasi ini membutuhkan data berdasarkan baris dan operasi ini memang lebih baik apabila langsung memanggil basis data. Meskipun begitu, pada \textit{traffic spike} yang tinggi dalam waktu singkat, operasi tersebut dapat membebani basis data. Dari sisi keterbaruan data, data yang 150 milisekon lebih lama tidak akan jauh berbeda dengan data paling terbaru. Terlebih lagi, sistem ini bukan sistem yang sangat sensitif sehingga perbedaan sekian milisekon akan mempengaruhi hasil secara signifikan. \textit{Tradeoff} kinerja yang ditawarkan dengan pendekatan ini membuat penggunaan \textit{micro-caching} jauh lebih bermanfaat untuk menjaga stabilitas sistem. Penyimpanan \textit{cache} dapat diimplementasikan dengan \textit{in-memory hashmap} untuk latensi yang lebih baik. TTL \textit{cache} sebesar 150 milisekon membuat penggunaan Redis tidak cocok karena perbedaan latensi yang bisa menjadi sangat signifikan.
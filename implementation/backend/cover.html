
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>processor: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">tugas-akhir/backend/app/processor/http.go (0.0%)</option>
				
				<option value="file1">tugas-akhir/backend/app/processor/module.go (0.0%)</option>
				
				<option value="file2">tugas-akhir/backend/app/processor/processor.go (68.2%)</option>
				
				<option value="file3">tugas-akhir/backend/app/processor/rate_limiter.go (73.7%)</option>
				
				<option value="file4">tugas-akhir/backend/app/processor/worker/result_publisher.go (71.4%)</option>
				
				<option value="file5">tugas-akhir/backend/app/processor/worker/worker.go (55.6%)</option>
				
				<option value="file6">tugas-akhir/backend/app/sanity/pg_check.go (0.0%)</option>
				
				<option value="file7">tugas-akhir/backend/app/sanity/redis_check.go (0.0%)</option>
				
				<option value="file8">tugas-akhir/backend/app/sanity/sanity_check.go (0.0%)</option>
				
				<option value="file9">tugas-akhir/backend/app/server/handler/events/events.go (0.0%)</option>
				
				<option value="file10">tugas-akhir/backend/app/server/handler/health/base_healthcheck_handler.go (0.0%)</option>
				
				<option value="file11">tugas-akhir/backend/app/server/handler/health/fc_healthcheck_handler.go (0.0%)</option>
				
				<option value="file12">tugas-akhir/backend/app/server/handler/orders/base_order_handler.go (0.0%)</option>
				
				<option value="file13">tugas-akhir/backend/app/server/http.go (0.0%)</option>
				
				<option value="file14">tugas-akhir/backend/app/server/middleware/auth.go (0.0%)</option>
				
				<option value="file15">tugas-akhir/backend/app/server/middleware/logger.go (0.0%)</option>
				
				<option value="file16">tugas-akhir/backend/app/server/route/events.go (0.0%)</option>
				
				<option value="file17">tugas-akhir/backend/app/server/route/orders.go (0.0%)</option>
				
				<option value="file18">tugas-akhir/backend/app/server/route/route.go (0.0%)</option>
				
				<option value="file19">tugas-akhir/backend/app/server/route/webhook.go (0.0%)</option>
				
				<option value="file20">tugas-akhir/backend/cmd/fc/server/main_server.go (0.0%)</option>
				
				<option value="file21">tugas-akhir/backend/cmd/fc/worker/main_worker.go (0.0%)</option>
				
				<option value="file22">tugas-akhir/backend/cmd/nofc/server/main_server.go (0.0%)</option>
				
				<option value="file23">tugas-akhir/backend/cmd/sanity/main_sanity_check.go (0.0%)</option>
				
				<option value="file24">tugas-akhir/backend/cmd/seeder/seeder.go (0.0%)</option>
				
				<option value="file25">tugas-akhir/backend/infrastructure/amqp/client.go (76.1%)</option>
				
				<option value="file26">tugas-akhir/backend/infrastructure/amqp/consumer.go (75.0%)</option>
				
				<option value="file27">tugas-akhir/backend/infrastructure/amqp/publisher.go (71.4%)</option>
				
				<option value="file28">tugas-akhir/backend/infrastructure/config/config.go (0.0%)</option>
				
				<option value="file29">tugas-akhir/backend/infrastructure/memcache/memcache.go (80.0%)</option>
				
				<option value="file30">tugas-akhir/backend/infrastructure/postgres/postgres.go (31.6%)</option>
				
				<option value="file31">tugas-akhir/backend/infrastructure/postgres/tracer.go (0.0%)</option>
				
				<option value="file32">tugas-akhir/backend/infrastructure/redis/redis.go (76.2%)</option>
				
				<option value="file33">tugas-akhir/backend/internal/bookings/repository/booked_seats/pg_seat_repository.go (83.7%)</option>
				
				<option value="file34">tugas-akhir/backend/internal/bookings/repository/booking/pg_booking_repository.go (81.6%)</option>
				
				<option value="file35">tugas-akhir/backend/internal/bookings/service/serial_number.go (90.9%)</option>
				
				<option value="file36">tugas-akhir/backend/internal/events/entity/enum.go (56.0%)</option>
				
				<option value="file37">tugas-akhir/backend/internal/events/module.go (0.0%)</option>
				
				<option value="file38">tugas-akhir/backend/internal/events/repository/availability/pg_availability_repository.go (0.0%)</option>
				
				<option value="file39">tugas-akhir/backend/internal/events/repository/availability/redis_availability_repository.go (81.5%)</option>
				
				<option value="file40">tugas-akhir/backend/internal/events/repository/event/pg_event_repository.go (74.4%)</option>
				
				<option value="file41">tugas-akhir/backend/internal/events/repository/seat/pg_seat_repository.go (88.9%)</option>
				
				<option value="file42">tugas-akhir/backend/internal/events/service/redis_availability_seeder/redis_availability_seeder.go (65.4%)</option>
				
				<option value="file43">tugas-akhir/backend/internal/events/usecase/event.go (0.0%)</option>
				
				<option value="file44">tugas-akhir/backend/internal/orders/entity/amqp.go (86.7%)</option>
				
				<option value="file45">tugas-akhir/backend/internal/orders/entity/enum.go (46.2%)</option>
				
				<option value="file46">tugas-akhir/backend/internal/orders/module.go (0.0%)</option>
				
				<option value="file47">tugas-akhir/backend/internal/orders/repository/order/pg_order_repository.go (48.1%)</option>
				
				<option value="file48">tugas-akhir/backend/internal/orders/service/early_dropper/early_dropper.go (76.9%)</option>
				
				<option value="file49">tugas-akhir/backend/internal/orders/service/early_dropper/lock_releaser.go (100.0%)</option>
				
				<option value="file50">tugas-akhir/backend/internal/orders/service/idempotent_place_order/idempotent_place_order.go (81.8%)</option>
				
				<option value="file51">tugas-akhir/backend/internal/orders/service/pgp_place_order_connector/pgp_place_order_connector.go (63.2%)</option>
				
				<option value="file52">tugas-akhir/backend/internal/orders/usecase/get_order/pg_get_order_usecase.go (7.7%)</option>
				
				<option value="file53">tugas-akhir/backend/internal/orders/usecase/place_order/base_place_order_usecase.go (71.4%)</option>
				
				<option value="file54">tugas-akhir/backend/internal/orders/usecase/place_order/fc_place_order_usecase.go (45.5%)</option>
				
				<option value="file55">tugas-akhir/backend/internal/orders/usecase/webhook/pg_webhook_usecase.go (18.4%)</option>
				
				<option value="file56">tugas-akhir/backend/internal/payments/entity/enum.go (46.2%)</option>
				
				<option value="file57">tugas-akhir/backend/internal/payments/repository/invoice/pg_invoice_repository.go (50.0%)</option>
				
				<option value="file58">tugas-akhir/backend/internal/payments/service/payment_gateway_ext.go (0.0%)</option>
				
				<option value="file59">tugas-akhir/backend/internal/payments/service/payment_gateway_mock.go (100.0%)</option>
				
				<option value="file60">tugas-akhir/backend/internal/seeder/case_seeder.go (73.6%)</option>
				
				<option value="file61">tugas-akhir/backend/internal/seeder/schema_manager.go (50.0%)</option>
				
				<option value="file62">tugas-akhir/backend/internal/seeder/test_utils.go (96.6%)</option>
				
				<option value="file63">tugas-akhir/backend/pkg/cursor_iterator/cursor_iterator.go (68.8%)</option>
				
				<option value="file64">tugas-akhir/backend/pkg/error/http.go (0.0%)</option>
				
				<option value="file65">tugas-akhir/backend/pkg/go-metrics-prometheus/prometheusmetrics.go (79.3%)</option>
				
				<option value="file66">tugas-akhir/backend/pkg/logger/logger.go (80.0%)</option>
				
				<option value="file67">tugas-akhir/backend/pkg/mock_payment/api_default.go (0.0%)</option>
				
				<option value="file68">tugas-akhir/backend/pkg/mock_payment/client.go (0.0%)</option>
				
				<option value="file69">tugas-akhir/backend/pkg/mock_payment/configuration.go (0.0%)</option>
				
				<option value="file70">tugas-akhir/backend/pkg/mock_payment/model__invoices__id__get_404_response.go (0.0%)</option>
				
				<option value="file71">tugas-akhir/backend/pkg/mock_payment/model_create_invoice_request.go (0.0%)</option>
				
				<option value="file72">tugas-akhir/backend/pkg/mock_payment/model_invoice.go (0.0%)</option>
				
				<option value="file73">tugas-akhir/backend/pkg/mock_payment/model_pay_invoice_request.go (0.0%)</option>
				
				<option value="file74">tugas-akhir/backend/pkg/mock_payment/response.go (0.0%)</option>
				
				<option value="file75">tugas-akhir/backend/pkg/mock_payment/utils.go (1.0%)</option>
				
				<option value="file76">tugas-akhir/backend/pkg/utility/hmac.go (0.0%)</option>
				
				<option value="file77">tugas-akhir/backend/pkg/utility/json.go (100.0%)</option>
				
				<option value="file78">tugas-akhir/backend/pkg/utility/sleep.go (50.0%)</option>
				
				<option value="file79">tugas-akhir/backend/pkg/utility/string.go (30.0%)</option>
				
				<option value="file80">tugas-akhir/backend/test-containers/rabbitmq.go (90.9%)</option>
				
				<option value="file81">tugas-akhir/backend/test-containers/redis_cluster.go (80.2%)</option>
				
				<option value="file82">tugas-akhir/backend/test-containers/relational_db.go (66.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package processor

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/pkg/logger"

        "github.com/prometheus/client_golang/prometheus/promhttp"
)

type MetricsServer struct {
        server *http.Server
}

func NewMetricsServer(config *config.Config) *MetricsServer <span class="cov0" title="0">{
        mux := http.NewServeMux()
        mux.Handle("/metrics", promhttp.Handler())

        server := &amp;http.Server{
                Addr:    fmt.Sprintf(":%d", config.WorkerMetricsPort),
                Handler: mux,
        }

        return &amp;MetricsServer{
                server: server,
        }
}</span>

func (s *MetricsServer) Run(ctx context.Context) error <span class="cov0" title="0">{
        l := logger.FromCtx(ctx)

        l.Sugar().Infof("Starting metrics server on %s\n", s.server.Addr)

        go func() </span><span class="cov0" title="0">{
                if err := s.server.ListenAndServe(); !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        l.Sugar().Errorw("metrics server failed", err)
                }</span>
        }()

        <span class="cov0" title="0">return nil</span>
}

func (s *MetricsServer) Stop(ctx context.Context) error <span class="cov0" title="0">{
        return s.server.Shutdown(ctx)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package processor

import (
        "context"
        "go.uber.org/fx"
        "tugas-akhir/backend/app/processor/worker"
)

var Module = fx.Options(
        fx.Provide(worker.NewResultPublisher),
        fx.Provide(worker.NewBookingWorker),
        fx.Provide(NewProcessor),
        fx.Provide(fx.Annotate(
                NewMetricsServer,
                fx.OnStop(func(ctx context.Context, metricsServer *MetricsServer) error <span class="cov0" title="0">{
                        return metricsServer.Stop(ctx)
                }</span>),
        )),
)
</pre>
		
		<pre class="file" id="file2" style="display: none">package processor

import (
        "context"
        "github.com/platinummonkey/go-concurrency-limits/core"
        "go.uber.org/zap"
        "time"
        "tugas-akhir/backend/app/processor/worker"
        "tugas-akhir/backend/infrastructure/amqp"
        entity2 "tugas-akhir/backend/infrastructure/amqp/entity"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/internal/orders/entity"
        go_metrics_prometheus "tugas-akhir/backend/pkg/go-metrics-prometheus"
        "tugas-akhir/backend/pkg/logger"
)

const PollInterval = 5 * time.Second
const ProcessorNamespace = string(config.FlowControlVariant__DropperAsync)
const ProcessorSubsystem = "order_processor"
const LimiterName = "order_processor_limiter"
const StrategyLimit = 15000
const ConcurrencyLimit = 15000

type Processor struct {
        config           *config.Config
        orderConsumer    *amqp.Consumer
        ctx              context.Context
        limiter          core.Limiter
        worker           *worker.BookingWorker
        prometheusClient *go_metrics_prometheus.PrometheusConfig
}

func (p *Processor) Run(ctx context.Context) error <span class="cov4" title="2">{
        // hacky but it is what is is
        // should be on constructor
        limiter, prometheusClient, err := NewLimiter(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">p.limiter = limiter
        p.prometheusClient = prometheusClient

        go p.prometheusClient.UpdatePrometheusMetrics()

        // run consume place order
        err = p.ConsumePlaceOrder()

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func (p *Processor) Stop() error <span class="cov4" title="2">{
        l := logger.FromCtx(p.ctx).Sugar()

        if consumeErr := p.orderConsumer.Close(); consumeErr != nil </span><span class="cov0" title="0">{
                l.Error(consumeErr)
        }</span>

        <span class="cov4" title="2">if publishErr := p.worker.Stop(); publishErr != nil </span><span class="cov0" title="0">{
                l.Error(publishErr)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func (p *Processor) ConsumePlaceOrder() error <span class="cov4" title="2">{
        l := logger.FromCtx(p.ctx).With(zap.String("context", "place-order-consumer"))

        go func() </span><span class="cov4" title="2">{
        connLoop:
                for </span><span class="cov8" title="4">{
                        channel, consumeErr := p.orderConsumer.Consume(p.ctx)

                        if consumeErr != nil </span><span class="cov0" title="0">{
                                l.Sugar().Error(consumeErr)
                                continue</span>
                        }

                <span class="cov4" title="2">mainLoop:
                        for </span><span class="cov10" title="5">{
                                select </span>{
                                case rawMsg, ok := &lt;-channel:<span class="cov10" title="5">
                                        if !ok </span><span class="cov4" title="2">{
                                                l.Info("channel is closed")
                                                break mainLoop</span>
                                        }

                                        //l.Info("receiving message")

                                        <span class="cov7" title="3">go func() </span><span class="cov7" title="3">{
                                                listener, ok := p.limiter.Acquire(p.ctx)

                                                if !ok || listener == nil </span><span class="cov0" title="0">{
                                                        l.Sugar().Errorf("failed to acquire because not ok or listener is nil")

                                                        if requeueErr := rawMsg.Reject(true); requeueErr != nil </span><span class="cov0" title="0">{
                                                                l.Sugar().Error(requeueErr)
                                                        }</span>

                                                        <span class="cov0" title="0">if listener != nil </span><span class="cov0" title="0">{
                                                                listener.OnDropped()
                                                        }</span>

                                                        <span class="cov0" title="0">return</span>
                                                }

                                                <span class="cov7" title="3">_ = p.worker.Process(p.ctx, &amp;rawMsg)

                                                listener.OnSuccess()</span>
                                        }()
                                case &lt;-p.ctx.Done():<span class="cov0" title="0">
                                        l.Info("consume place order context is done")
                                        break connLoop</span>
                                }
                        }
                }
        }()

        <span class="cov4" title="2">return nil</span>
}

func NewProcessor(
        config *config.Config,
        worker *worker.BookingWorker,
) (*Processor, error) <span class="cov4" title="2">{
        orderConsumer := amqp.NewConsumer(
                config,
                entity.PlaceOrderQueue,
                &amp;entity.PlaceOrderExchange,
                entity2.ConsumeConfig{
                        PrefetchCount: ConcurrencyLimit,
                        PrefetchSize:  0,
                        AutoAck:       false,
                        RoutingKeys:   []string{"orders"},
                },
        )

        return &amp;Processor{
                ctx:              context.Background(),
                orderConsumer:    orderConsumer,
                config:           config,
                limiter:          nil,
                worker:           worker,
                prometheusClient: nil,
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package processor

import (
        "context"
        "fmt"
        "github.com/platinummonkey/go-concurrency-limits/core"
        "github.com/platinummonkey/go-concurrency-limits/limit"
        limiter2 "github.com/platinummonkey/go-concurrency-limits/limiter"
        "github.com/platinummonkey/go-concurrency-limits/metric_registry/gometrics"
        "github.com/platinummonkey/go-concurrency-limits/strategy"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/rcrowley/go-metrics"
        "go.uber.org/zap"
        "time"
        go_metrics_prometheus "tugas-akhir/backend/pkg/go-metrics-prometheus"
        "tugas-akhir/backend/pkg/logger"
)

type LimiterLogger struct {
        l *zap.Logger
}

func (l *LimiterLogger) Debugf(msg string, params ...interface{}) <span class="cov10" title="3">{
        l.l.Info(fmt.Sprintf(msg, params...))
}</span>

func (l *LimiterLogger) IsDebugEnabled() bool <span class="cov0" title="0">{
        return true
}</span>

func NewLimiter(ctx context.Context) (core.Limiter, *go_metrics_prometheus.PrometheusConfig, error) <span class="cov10" title="3">{
        metricsRegistry := metrics.NewRegistry()

        prometheusClient := go_metrics_prometheus.NewPrometheusProvider(
                metricsRegistry,
                ProcessorNamespace,
                ProcessorSubsystem,
                prometheus.DefaultRegisterer,
                PollInterval,
        )

        limiterMetricsRegistry, err := gometrics.NewGoMetricsMetricRegistry(
                metricsRegistry,
                "",
                "",
                PollInterval,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov10" title="3">limitLogger := LimiterLogger{
                l: logger.FromCtx(ctx),
        }

        // Setup concurrency limits
        limitStrategy := strategy.NewSimpleStrategyWithMetricRegistry(StrategyLimit, limiterMetricsRegistry)

        fixedLimit := limit.NewFixedLimit(LimiterName, 5000, limiterMetricsRegistry)

        //gradient2Limit, err := limit.NewGradient2Limit(
        //        LimiterName,
        //        1000,
        //        ConcurrencyLimit,
</span></span>        //        500,
        //        func(limit int) int {
        //                return int(math.Max(4, float64(limit)/4))
        //        },
        //        0.2,
        //        1200,
        <span class="cov10" title="3">//        &amp;limitLogge</span><span class="cov0" title="0">r,
        //        limiterMetricsRegistry,
        /</span>/)
        //
        <span class="cov10" title="3">//if err != nil {
        //        return nil, nil, err
        //}

        tracedLimit := limit.NewTracedLimit(fixedLimit, &amp;limitLogger)

        defaultLimiter, err := limiter2.NewDefaultLimiter(
                tracedLimit,
                int64(100*time.Millisecond),
                int64(500*time.Millisecond),
                int64(100*time.Microsecond),
                100,
                limitStrategy,
                &amp;limitLogger,</span><span class="cov0" title="0">
                limiterMetricsRegistry,
        )</span>

        <span class="cov10" title="3">if err != nil {
                return nil, nil, err
        }

        limiter := limiter2.NewQueueBlockingLimiterFromConfig(defaultLimiter, limiter2.QueueLimiterConfig{
                Ordering:          limiter2.OrderingFIFO,
                MaxBacklogTimeout: 15 * time.Minute,</span>
                MaxBacklogSize:    10000,
                MetricRegistry:    limiterMetricsRegistry,
        })

        return limiter, prometheusClient, nil
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package worker

import (
        "context"
        "errors"
        "time"
        "tugas-akhir/backend/infrastructure/amqp"
        entity2 "tugas-akhir/backend/infrastructure/amqp/entity"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/internal/orders/entity"
        "tugas-akhir/backend/pkg/utility"
)

type ResultPublisher struct {
        replyPublisher *amqp.Publisher
}

func (p *ResultPublisher) Stop() error <span class="cov10" title="6">{
        return p.replyPublisher.Close()
}</span>

func (p *ResultPublisher) Publish(ctx context.Context, message entity.PlaceOrderReplyMessage) error <span class="cov6" title="3">{
        amqpMessage, err := message.ToMessage()

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

<span class="cov6" title="3">ensureDelivered:
        for </span><span class="cov6" title="3">{
                err := p.replyPublisher.Push(*amqpMessage)

                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, entity2.NotConnectedError) </span><span class="cov0" title="0">{
                                utility.SleepWithContext(ctx, 2*time.Second)
                        }</span> else<span class="cov0" title="0"> {
                                return err
                        }</span>
                }

                <span class="cov6" title="3">break ensureDelivered</span>
        }

        <span class="cov6" title="3">return nil</span>
}

func NewResultPublisher(config *config.Config) *ResultPublisher <span class="cov4" title="2">{
        replyPublisher := amqp.NewPublisher(config, &amp;entity.PlaceOrderExchange)

        return &amp;ResultPublisher{
                replyPublisher: replyPublisher,
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package worker

import (
        "bytes"
        "context"
        "encoding/gob"
        "github.com/rabbitmq/amqp091-go"
        "go.uber.org/zap"
        "time"
        "tugas-akhir/backend/internal/orders/entity"
        "tugas-akhir/backend/internal/orders/usecase/place_order"
        "tugas-akhir/backend/pkg/logger"
)

type BookingWorker struct {
        placeOrderUsecase place_order.PlaceOrderUsecase
        resultPublisher   *ResultPublisher
}

func (w *BookingWorker) Process(ctx context.Context, rawMsg *amqp091.Delivery) error <span class="cov8" title="3">{
        l := logger.FromCtx(ctx).With(zap.String("context", "worker"))

        waitTime := time.Since(rawMsg.Timestamp)
        now := time.Now()

        var buffer bytes.Buffer

        if _, writeBufferErr := buffer.Write(rawMsg.Body); writeBufferErr != nil </span><span class="cov0" title="0">{
                l.Sugar().Error(writeBufferErr)

                rejectErr := rawMsg.Reject(true)

                if rejectErr != nil </span><span class="cov0" title="0">{
                        l.Sugar().Error(rejectErr)
                        return rejectErr
                }</span>

                <span class="cov0" title="0">return writeBufferErr</span>
        }

        <span class="cov8" title="3">var payload entity.PlaceOrderMessage

        decoder := gob.NewDecoder(&amp;buffer)
        if decodeErr := decoder.Decode(&amp;payload); decodeErr != nil </span><span class="cov0" title="0">{
                l.Sugar().Error(decodeErr)

                rejectErr := rawMsg.Reject(true)

                if rejectErr != nil </span><span class="cov0" title="0">{
                        l.Sugar().Error(rejectErr)

                }</span>

                <span class="cov0" title="0">return decodeErr</span>
        }

        <span class="cov8" title="3">response, httpErr := w.placeOrderUsecase.PlaceOrder(ctx, payload.Data)

        if httpErr != nil &amp;&amp; httpErr.ErrorContext != nil </span><span class="cov0" title="0">{
                l.Sugar().Error("internal error", zap.Error(httpErr.ErrorContext))
                httpErr.ErrorContext = nil
        }</span>

        <span class="cov8" title="3">processTime := time.Since(now)
        now = time.Now()

        publishErr := w.resultPublisher.Publish(ctx, entity.PlaceOrderReplyMessage{
                Order:          response,
                HttpErr:        httpErr,
                ReplyRoute:     payload.ReplyRoute,
                IdempotencyKey: *payload.Data.IdempotencyKey,
        })

        if ackErr := rawMsg.Ack(false); ackErr != nil </span><span class="cov0" title="0">{
                l.Sugar().Error(ackErr)
        }</span>

        <span class="cov8" title="3">publishTime := time.Since(now)

        if publishErr != nil </span><span class="cov0" title="0">{
                l.Sugar().Error(publishErr)
                return publishErr
        }</span>

        <span class="cov8" title="3">l.Info("order processed",
                zap.Int64("wait_time", waitTime.Milliseconds()),
                zap.Int64("process_time", processTime.Milliseconds()),
                zap.Int64("publish_time", publishTime.Milliseconds()),
        )

        return nil</span>
}

func (w *BookingWorker) Stop() error <span class="cov10" title="4">{
        return w.resultPublisher.Stop()
}</span>

func NewBookingWorker(
        placeOrderUsecase place_order.PlaceOrderUsecase,
        resultPublisher *ResultPublisher,
) *BookingWorker <span class="cov5" title="2">{
        return &amp;BookingWorker{
                placeOrderUsecase: placeOrderUsecase,
                resultPublisher:   resultPublisher,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package sanity

import (
        "context"
        "fmt"
        "github.com/georgysavva/scany/v2/pgxscan"
        "tugas-akhir/backend/infrastructure/postgres"
        "tugas-akhir/backend/internal/events/entity"
)

type PGCheck struct {
        db *postgres.Postgres
}

func (s *PGCheck) GetTicketSales(ctx context.Context) ([]int64, error) {
        var ids []int64

        err := pgxscan.Select(ctx, s.db.GetExecutor(ctx), &amp;ids, `
                SELECT id
                FROM ticket_sales
        `)

        if err != nil {
                return nil, e</span><span class="cov0" title="0">rr
        }

</span>        return ids, nil
}<span class="cov0" title="0">
</span>
fu</span>nc (s *PGCheck) GetAvailability(ctx context.Context) (*AvailabilityCheck, error) {
        raw := make([]DBAvailabilityRow, 0)

        err := pgxscan.Select(ctx, s.db.GetExecutor(ctx), &amp;raw, `
                SELECT status, count(*) as total
                FROM ticket_seats
                GROUP BY status
        `)

</span>        if err != nil {
</span>                return nil, err
        }
</span></span>
        if</span> len(<span class="cov0" title="0">raw) == 0 {
</span>                return nil, fmt.Errorf("query result must have more than one row")
        }
</span>
        r<span class="cov0" title="0">esult := AvailabilityChec</span>k{
                Count:       0,
                Available:   0,
        <span class="cov0" title="0">        Unavailable: 0,
</span>        }

        for _, row := range raw {
                if row.Status == entity.SeatStatus__Available {
                        result.Available += row.Total
                } else if row.Status == entity.SeatStatus__Sold {
                        result.Unavailable += row.Total
                } else if row.Status == entity.SeatStatus__OnHold {
                        result.Unavailable += row.Total
                }

                result.Count += row.Total
        }

        return &amp;result, nil
}

func (s *PGCheck) CheckDoubleOrder(ctx context.Context) (*DoubleOrderCheck, error) {
        // sanity check for double order (one seat sold more than once)
        raw := make([]DoubleOrderCheck, 0)

        err := pgxscan.Select(ctx, s.db.GetExecutor(ctx), &amp;raw, `
                SELECT COUNT(*) as total
                FROM (
                        SELECT 
                                order_items.ticket_area_id as ticket_area_id,
                                ticket_seat</span><span class="cov0" title="0">_id
                        FROM 
                </span>                order_items
                        INNER JOIN 
        <span class="cov0" title="0">                        orders ON orde</span><span class="cov0" title="0">r_items.ticket_area_id = orders.ticket_area_id 
                                          AND order_items.order_id = orders.id
                        WHERE 
                                orders.status != 'failed'
                </span>        GROUP BY 
                                order_items.ticket_area_id, ticket_seat_id
        <span class="cov0" title="0">                HAVING 
</span>                                COUNT(*) &gt; 1
                ) as double_bookings;
        `)

        if err != nil {
                return nil, err
        }

        if len(raw) == 0 {
                return &amp;DoubleOrderCheck{
                        Total: 0,
                }, nil
        }

        return &amp;raw[0], nil
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package sanity

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        baseredis "github.com/redis/go-redis/v9"
        "go.uber.org/zap"
        "strconv"
        "strings"
        "sync"
        "tugas-akhir/backend/infrastructure/memcache"
        "tugas-akhir/backend/infrastructure/redis"
        "tugas-akhir/backend/internal/events/entity"
        "tugas-akhir/backend/internal/events/repository/availability"
        "tugas-akhir/backend/internal/orders/service/early_dropper"
        "tugas-akhir/backend/pkg/logger"
)

type RedisCheck struct {
        redis *redis.Redis
        cache *memcache.Memcache
}

const dropperCacheKey = "dropper-keys"

// GetAvailability performs a sanity check on seat availability for a given list of ticket sale IDs.
// It fetches data directly from Redis Hashes for high performance.
func (s *RedisCheck) GetAvailability(ctx context.Context, ticketSaleIDs []int64) (*Ava<span class="cov0" title="0">ilabilityCheck, error) {
        l := logger.FromCtx(ctx)
        result := &amp;AvailabilityCheck{}

        if len(ticketSaleIDs) == 0 {
                return result, nil // Return empty result if no IDs are provided.
        }

</span>        // Use a pipeline to fetch all HGetAll results in a single round-trip.
        pipe := s.redis.Client.Pipeline()
        cmds := make(map[int64]*baseredis.MapStringStringCmd, len(ticketSaleIDs))

</span>        for _, id := range ticketSaleIDs {
                key := availability.CacheKey(id)
                cmds[</span><span class="cov0" title="0">id] = pipe.HGetAll(ctx, key)
        }

        _, err := pipe.Ex</span><span class="cov0" title="0">ec(ctx)
        // We can ignore a general `redis.Nil` error from Exec, as it might just mean some keys didn't exist.
        // W</span>e'll check the error for each individual command below.
        if err != nil &amp;&amp; !errors.Is(err, baseredis.Nil) {
                l.<span class="cov0" title="0">Error("failed to execute availability pipeline", zap.Error(err))
                return nil, err
        }
</span>
</span>        // Process the results from the pipeline.
        for<span class="cov0" title="0"> _, cmd := range cm</span>ds {
                fields, err := cmd.Result()
                if err != nil {
                        <span class="cov0" title="0">// If a specific hash doesn't exist, it's not an error for a sanity check, just skip it.
                        if errors.Is(err, baseredis.Nil) {
                                continue
                        }
                        l.Warn("fa</span>iled to get command result from availability pipeline", zap.Error(err))
                        continue // Continue checking other results
                }

</span>                for field, value := range fields {
                        </span>parts := strings.Split(field, ":")
                        if len(parts) != 3 {
                <span class="cov0" title="0">                continue // Ignore malformed fields
                        }

</span>                        // The last part determines if it's total or available seats.
                        fieldType := parts[2]
                        </span>seatCount, convErr := strconv.ParseInt(value, 10, 32)
                        if convErr != nil {
                <span class="cov0" title="0">                l.Warn("could not parse seat count", zap.String("field", field), zap.String("valu</span><span class="cov0" title="0">e", value), zap.Error(convErr))
                                continue
                        }

</span>                        switch fieldType {
                <span class="cov0" title="0">        case "tot</span>al":
                                result.Count += int(seatCount)
                        case "available":
        <span class="cov0" title="0">                        result.Available += int(seatCount)
                        }
                }
        }

</span>        result.Unavailable = result.Count - result.Available</span><span class="cov0" title="0">
        return result, nil
}
</span>
fun</span>c (s *RedisCheck) GetDropperAvailability(ctx context.Context) (*AvailabilityCheck, error) {
        l := l<span class="cov0" title="0">ogger.FromCtx(ctx).With(zap.String("func", "dropper_availability"))

        pattern := fmt.Sprintf("%s*", early_dropper.DropperRedisPrefix)

</span>        keys := make([]string, 0)

        getKeys := func() error {
                v</span>ar mu sync.Mutex

                // ForEachMaster will loop over every master node in the cluster.
        <span class="cov0" title="0">        err := s.redis.Client.</span><span class="cov0" title="0">ForEachMaster(ctx, func(ctx context.Context, client *baseredis.Client) error {
                        var cursor uint64 = 0
                </span>        var localKeys []string
                        for {
                                // Scan on the current node.
        <span class="cov0" title="0">                        ckeys, nextCursor, err := client.Scan(ctx, cursor, pattern, 100).Result()
                                if err != nil {
</span>                                        return err
                                }
</span>
                                localKe</span>ys = append(localKeys, ckeys...)

                                if nextCursor == 0 {
                                        break
                <span class="cov0" title="0">                }
                                cursor = nextCursor
</span>                        }

                        mu.Lock()
        <span class="cov0" title="0">                keys = append(ke</span><span class="cov0" title="0">ys, localKeys...)
                        mu.Unlock()

</span>                        return nil
        <span class="cov0" title="0">        })

                if err != nil {
                        return err
                }

                raw, err := json.Marshal</span><span class="cov0" title="0">(keys)

                </span>if err != nil {
                        logger.FromCtx(ctx).Error("Cannot marshall keys", zap.Error(err))
        <span class="cov0" title="0">                return err
                }

</span>                s.cache.Cache.SetDefault(dropperCacheKey, raw)

</span>                return nil
        <span class="cov0" title="0">}
</span>
        cachedData, found := </span><span class="cov0" title="0">s.cache.Cache.Get(dropperCacheKey)

        var getKey</span>sError error

        i<span class="cov0" title="0">f found {
</span>                rawBytes, typeOk := cachedData.([]byte) // bigcache Get returns []byte, go-cache Get returns interface{}
                if !typeOk {
                        l.Error("Cached data for dropper keys is not []byte", zap.String("key", dropperCacheKey))
        <span class="cov0" title="0">                // Treat as cache miss/corruption if type is wrong, and refetch
                        getKeysError = getKeys()
                } else {
                        marshallErr := json.Unmarshal(rawBytes, &amp;keys)
                        if marshallErr != nil {
                                l.Error("Cannot unmarshal cached dropper keys", zap.Error(marshallErr))
                                // Original logic: Do not set getKey</span><span class="cov0" title="0">sError = marshallErr here directly.
                                // The len(keys) == 0 check below is the primary trigger for getKeys()
                                // if unmarshalli</span><span class="cov0" title="0">ng fails and results in empty keys.
                        }

</span>                        // This check mirrors the original logic: if after attempting to load from cache,
                        // 'keys' is empty, then refetch. This covers:
                <span class="cov0" title="0">        // 1. Successful unmarshal of an empty list from cache.
                        // 2. Failed unmarshal where 'keys' remains (or becomes) empty.
                        if len(keys) == 0 {
                                if marshallErr != nil { // Add context if unmarshal error led to empty keys
                                        l.Warn("Unmarshaling cached dropper keys failed and resulted in empty keys, refetching.", zap.Error(marshallErr), zap.String("key", dropperCacheKey))
                                } else {
                                        l.Warn("Cached dropper keys are an empty list, refetching.", zap.String("key", dropperCacheKey))
                                }
                                getKeysError = getKeys()
                        }
</span>                }
        } else { // Not </span><span class="cov0" title="0">found in cache (equivalent to bigcache.ErrEntryNotFound)
                getKeysError = getKeys()
        }
</span>
        if getKeysError != nil {
                <span class="cov0" title="0">return nil, getKeysError
</span>        }

</span>        //l.Sugar().Infof("got %d keys to scan", len(keys))

</span>        result := AvailabilityCheck{
                Count:       0,
                Available:   0,
        <span class="cov0" title="0">        Unavailable: 0,
        }

</span>        buffer := make([]string, 0)
        bufferCount := 400

        batchCheck := func() error {
                //defer func() {
                //        l.Sugar().Infof("current result: total %d, available %d, unavailable %d", result.Count, result.Available, result.Unavailable)
                //}()

                pipe := s.redis.Client.Pipeline()

</span>                cmds := make(map[string]*baseredis.StringCmd)

                for _, key := range buffer {
                        // wrong key
</span>                        if key == "early-dropper:refresher-node" {
                                continue
                        }
</span>
                        cmds[key] = pipe.Get(ctx, key)
                }
</span>
                _, </span>err := pipe.Exec(ctx)

                if<span class="cov0" title="0"> err != nil &amp;&amp; !errors.Is(err, baseredis.Nil) {
                        return err
                }
</span>
</span>                freeSeatAvailableTotal := 0
                fr<span class="cov0" title="0">eeSeatCheck := make</span>([]string, 0)

                for key, cmd := range cmds {
                        <span class="cov0" title="0">val, resultErr := cmd.Result()
                        if resultErr != nil {
                                l.Sugar().Warnf("failed to get key %s: %v", key, err)
                                continue
                        }
</span>
                        if strings.Contains(key, "numbered") {
                <span class="cov0" title="0">                // numbered </span><span class="cov0" title="0">set
                                if val == string(entity.SeatStatus__Available) {
                        </span>                result.Available += 1
                                } else {
                <span class="cov0" title="0">                        result.Unavailable += 1
                                }

</span>                                result.Count += 1
                        } else {
                        </span>        // free seat
                                availableCount, parseErr := strconv.ParseInt(val, 10, 32)

</span>                                if parseErr != nil {
                                        l.Sugar().Warnf("cannot parse value for key %s with value %s", key, val)
                        </span>                continue
                                }

</span>                                result.Available += int(availableCount)
                                freeSeatAvailableTotal += int(availableCount)
        <span class="cov0" title="0">                        freeSeatCheck = append(freeSeatCheck, key)
                        }
                }

                buffer = make([]st</span><span class="cov0" title="0">ring, 0)

</span>                if len(freeSeatCheck) == 0 {
                        </span>retur<span class="cov0" title="0">n nil
                }

</span>                pipe <span class="cov0" title="0">= s.redis.Client.Pipeline()
                cmds = make(map[string]*baseredis.StringCmd)

                for _, key := range fr</span><span class="cov0" title="0">eeSeatCheck {
                        debugKey := fmt.Sprintf("debug:%s", key)
                        cmds[debugKey] = pipe.Get(ctx, debugKey)
                }

</span>                _, err = pipe.Exec(ctx)

</span>                if err != nil &amp;&amp; !errors.Is(err, baseredis.Nil) {
                        return err
                }</span>

                freeSeatCount := 0

</span>                for key, cmd := range cmds {
                </span>        val, resultErr := cmd.Result()
                        if resultErr != nil {
                                l.Sugar().Warnf("failed to get key %s: %v", key, err)
                                continue
        <span class="cov0" title="0">                }

                        initialCount, parseErr := strconv.ParseInt(val, 10, 32)

                        if parseErr != nil {
                                l.Sugar().Warnf("cannot parse value for key %s with value %s", key, val)
                                continue
                        }

                        freeSeatCount += int(init</span><span class="cov0" title="0">ialCount)
                }

                result.Count += freeSeatCount
                result.Unavailable += freeSeatCount - freeSeatAvailableTotal

                return nil
        }

        for _, key := range keys {
</span>                buffer = append(buffer, key)

</span>                if len(buf</span>fer) &gt;= bufferCount {
                        batchErr := batchCheck()

                        <span class="cov0" title="0">if batchErr != nil {
</span>                                l.Sugar().Error("batch check error", zap.Error(batchErr))
                        }
                <span class="cov0" title="0">}
        }

</span>        if len(buffer) &gt; 0 {
                b</span>atchErr := batchCheck()

                <span class="cov0" title="0">if batchErr != nil {
                        l.Sugar().Error("batch check error", zap.Error(batchErr))
                }
        }
</span>
        return &amp;result, nil
</span>}
</pre>
		
		<pre class="file" id="file8" style="display: none">package sanity

import (
        "context"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        "go.uber.org/zap"
        "sync"
        "time"
        "tugas-akhir/backend/infrastructure/memcache"
        "tugas-akhir/backend/infrastructure/postgres"
        "tugas-akhir/backend/infrastructure/redis"
        "tugas-akhir/backend/pkg/logger"
)

type SanityCheck struct {
        pgCheck    *PGCheck
        redisCheck *RedisCheck
        quitChan   *chan struct{}

        // metrics
        dbAvailability    *prometheus.GaugeVec
        redisAvailability *prometheus.GaugeVec
        redisDropper      *prometheus.GaugeVec
        doubleOrder       prometheus.Gauge
}

func (s *SanityCheck) Run(ctx context.Context) <span class="cov0" title="0">{
        l := logger.FromCtx(ctx)

        l.Info("sanity check initialized")

        ticker := time.NewTicker(3 * time.Minute)

        quit := make(chan struct{})

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                s.Collect(ctx)</span>
                        case &lt;-quit:<span class="cov0" title="0">
                                ticker.Stop()
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">s.quitChan = &amp;quit

        // run immediately after started
        s.Collect(ctx)</span>
}

func (s *SanityCheck) Stop() <span class="cov0" title="0">{
        if s.quitChan != nil </span><span class="cov0" title="0">{
                close(*s.quitChan)
        }</span>
}

func (s *SanityCheck) push(gauge *prometheus.GaugeVec, check *AvailabilityCheck) <span class="cov0" title="0">{
        gauge.With(prometheus.Labels{
                "status": "total",
        }).Set(float64(check.Count))

        gauge.With(prometheus.Labels{
                "status": "available",
        }).Set(float64(check.Available))

        gauge.With(prometheus.Labels{
                "status": "unavailable",
        }).Set(float64(check.Unavailable))
}</span>

func (s *SanityCheck) Collect(ctx context.Context) <span class="cov0" title="0">{
        l := logger.FromCtx(ctx)

        wg := sync.WaitGroup{}

        wg.Add(4)

        go func() </span><span class="cov0" title="0">{
                result, err := s.pgCheck.GetAvailability(ctx)

                defer wg.Done()

                if err != nil </span><span class="cov0" title="0">{
                        l.Sugar().Error("cannot check availability from pg", zap.Error(err))
                        return
                }</span>

                <span class="cov0" title="0">s.push(s.dbAvailability, result)</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                ids, err := s.pgCheck.GetTicketSales(ctx)

                if err != nil {
                        l.Sugar().Error("cannot fetch ticket sales id", zap.Error(err))
                        return
</span>                }

                r</span>esult, err := s.redisCheck.GetAvailability(ctx, ids)

                <span class="cov0" title="0">defer wg.Done()
</span>
                if err != nil {
        <span class="cov0" title="0">                l.Sugar(</span><span class="cov0" title="0">).Error("cannot check availability from redis", zap.Error(err))
                        return
                }

                s.push(s.redisAvailability, result)
        }()
</span>
        go func() {
                r</span>esult, err := s.redisCheck.GetDropperAvailability(ctx)

                <span class="cov0" title="0">defer wg.Done()
</span>
                if err != nil {
        <span class="cov0" title="0">                l.Sugar(</span><span class="cov0" title="0">).Error("cannot check redis dropper", zap.Error(err))
                        return
                }

                s.push(s.redisDropper, result)
        }()
</span>
        go func() {
                r</span>esult, err := s.pgCheck.CheckDoubleOrder(ctx)

                <span class="cov0" title="0">defer wg.Done()
</span>
                if err != nil {
        <span class="cov0" title="0">                l.Sugar().Error("cannot check double order", zap.Error(err))
                        return
</span>                }

                s.doubleOrder.Set(float64(result.Total))
        }()

        wg.Wait()
        l.Info("finished collecting sanity check")
}

</span>func NewSanityCheck(
        d</span>b *postgres.Postgres,
        redis *redis.Redis,
)<span class="cov0" title="0"> (*SanityCheck, error) {
        cache, err := memcache.NewMemcache()

        if err != nil {
                return nil, err
        }

        pgCheck := PGCheck{
                db: db,
        }

        redisCheck := RedisCheck{
                redis: redis,
                cache: cache,
        }

        dbAvailability := promauto.NewGaugeVec(prometheus.GaugeOpts{
                Name: "ticket_app_db_availability",
                Help: "Database Seat Availability",
        }, []string{"status"})

        redisAvailability := promauto.NewGaugeVec(prometheus.GaugeOpts{
                Name: "ticket_app_redis_availability",
                Help: "Redis Seat Availability",
        }, []string{"status"})

        redisDropper := promauto.NewGaugeVec(prometheus.GaugeOpts{
                Name: "ticket_app_redis_dropper",
                Help: "Redis Dropper Availability",
        }, []string{"status"})

        doubleOrder := promauto.NewGauge(prometheus.GaugeOpts{
                Name: "ticket_app_double_order",
                Help: "Seat double order check",
        })

        return</span> &amp;SanityCheck{
                pgCheck:           &amp;pgCheck,
                redisCheck:        &amp;redisCheck,
                dbAvailability:    dbAvailability,
                redisAvailability: redisAvailability,
                redisDropper:      redisDropper,
                doubleOrder:       doubleOrder,
        }, nil
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package events

import (
        "github.com/labstack/echo/v4"
        "net/http"
        "tugas-akhir/backend/internal/events/entity"
        "tugas-akhir/backend/internal/events/usecase"
        myerror "tugas-akhir/backend/pkg/error"
        myvalidator "tugas-akhir/backend/pkg/validator"
)

type EventHandler struct {
        validator    *myvalidator.TranslatedValidator
        eventUsecase *usecase.EventUsecase
}

func NewEventHandler(
        validator *myvalidator.TranslatedValidator,
        eventUsecase *usecase.EventUsecase,
) *EventHandler <span class="cov0" title="0">{
        return &amp;EventHandler{
                validator:    validator,
                eventUsecase: eventUsecase,
        }
}</span>

func (h *EventHandler) GetAvailability(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()
        var payload entity.GetAvailabilityDto

        if err := c.Bind(&amp;payload); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, myerror.HttpError{
                        Message: "Malformed payload",
                })
        }</span>

        <span class="cov0" title="0">validationError, err := h.validator.Validate(payload)

        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, myerror.HttpError{
                        Message: err.Error(),
                })
        }</span>

        <span class="cov0" title="0">if len(validationError) != 0 </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, myerror.NewFromFieldError(validationError))
        }</span>

        <span class="cov0" title="0">result, httpErr := h.eventUsecase.GetAvailability(ctx, payload)

        if httpErr != nil </span><span class="cov0" title="0">{
                httpErr.Log(ctx)
                return c.JSON(httpErr.Code, httpErr)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, myerror.HttpPayload{
                Data: result,
        })</span>
}

func (h *EventHandler) GetSeats(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()
        var payload entity.GetSeatsDto

        if err := c.Bind(&amp;payload); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, myerror.HttpError{
                        Message: "Malformed payload",
                })
        }</span>

        <span class="cov0" title="0">validationError, err := h.validator.Validate(payload)

        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, myerror.HttpError{
                        Message: err.Error(),
                })
        }</span>

        <span class="cov0" title="0">if len(validationError) != 0 </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, myerror.NewFromFieldError(validationError))
        }</span>

        <span class="cov0" title="0">result, httpErr := h.eventUsecase.GetSeats(ctx, payload)

        if httpErr != nil </span><span class="cov0" title="0">{
                httpErr.Log(ctx)
                return c.JSON(httpErr.Code, httpErr)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, myerror.HttpPayload{
                Data: result,
        })</span>
}

func (h *EventHandler) GetEvent(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()
        var payload entity.GetEventDto

        if err := c.Bind(&amp;payload); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, myerror.HttpError{
                        Message: "Malformed payload",
                })
        }</span>

        <span class="cov0" title="0">validationError, err := h.validator.Validate(payload)

        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, myerror.HttpError{
                        Message: err.Error(),
                })
        }</span>

        <span class="cov0" title="0">if len(validationError) != 0 </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, myerror.NewFromFieldError(validationError))
        }</span>

        <span class="cov0" title="0">result, httpErr := h.eventUsecase.GetEvent(ctx, payload)

        if httpErr != nil </span><span class="cov0" title="0">{
                httpErr.Log(ctx)
                return c.JSON(httpErr.Code, httpErr)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, myerror.HttpPayload{
                Data: result,
        })</span>
}

func (h *EventHandler) GetEvents(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        result, httpErr := h.eventUsecase.GetEvents(ctx)

        if httpErr != nil </span><span class="cov0" title="0">{
                httpErr.Log(ctx)
                return c.JSON(httpErr.Code, httpErr)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, myerror.HttpPayload{
                Data: result,
        })</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package health

import (
        "github.com/labstack/echo/v4"
        "net/http"
        "sync"
        "tugas-akhir/backend/infrastructure/postgres"
        "tugas-akhir/backend/infrastructure/redis"
        myerror "tugas-akhir/backend/pkg/error"
        "tugas-akhir/backend/pkg/logger"
)

type BaseHealthcheckHandler struct {
        db    *postgres.Postgres
        redis *redis.Redis
}

func NewBaseHealthcheckHandler(db *postgres.Postgres, redis *redis.Redis) *BaseHealthcheckHandler <span class="cov0" title="0">{
        return &amp;BaseHealthcheckHandler{
                db:    db,
                redis: redis,
        }
}</span>

type PGHealthcheckResult struct {
        PostgresStatus string `json:"postgresStatus"`
        RedisStatus    string `json:"redisStatus"`
}

func (h *BaseHealthcheckHandler) Healthcheck(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        l := logger.FromCtx(ctx)

        status := http.StatusOK

        response := PGHealthcheckResult{
                PostgresStatus: "Healthy",
                RedisStatus:    "Healthy",
        }

        wg := sync.WaitGroup{}

        wg.Add(2)

        go func() </span><span class="cov0" title="0">{
                err := h.db.Pool.Ping(ctx)

                if err != nil </span><span class="cov0" title="0">{
                        l.Sugar().Error(err)
                        status = http.StatusServiceUnavailable
                        response.PostgresStatus = err.Error()
                }</span>

                <span class="cov0" title="0">wg.Done()</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                err := h.redis.IsHealthy(ctx)

                if err != nil </span><span class="cov0" title="0">{
                        l.Sugar().Error(err)
                        status = http.StatusServiceUnavailable
                        response.RedisStatus = err.Error()
                }</span>

                <span class="cov0" title="0">wg.Done()</span>
        }()

        <span class="cov0" title="0">wg.Wait()

        return c.JSON(status, myerror.HttpPayload{
                Message: "Ok",
                Data:    response,
        })</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package health

import (
        "fmt"
        "github.com/labstack/echo/v4"
        "net/http"
        "sync"
        "tugas-akhir/backend/infrastructure/amqp"
        "tugas-akhir/backend/infrastructure/postgres"
        "tugas-akhir/backend/infrastructure/redis"
        myerror "tugas-akhir/backend/pkg/error"
        "tugas-akhir/backend/pkg/logger"
)

type FCHealthcheckHandler struct {
        db    *postgres.Postgres
        redis *redis.Redis
}

func NewFCHealthcheckHandler(db *postgres.Postgres, redis *redis.Redis) *FCHealthcheckHandler <span class="cov0" title="0">{
        return &amp;FCHealthcheckHandler{
                db:    db,
                redis: redis,
        }
}</span>

type FCHealthcheckResult struct {
        PostgresStatus string `json:"postgresStatus"`
        RedisStatus    string `json:"redisStatus"`
        AmqpStatus     string `json:"amqpStatus"`
}

func (h *FCHealthcheckHandler) Healthcheck(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        l := logger.FromCtx(ctx)

        status := http.StatusOK

        response := FCHealthcheckResult{
                PostgresStatus: "Healthy",
                RedisStatus:    "Healthy",
                AmqpStatus:     "Healthy",
        }

        wg := sync.WaitGroup{}

        wg.Add(3)

        go func() </span><span class="cov0" title="0">{
                err := h.db.Pool.Ping(ctx)

                if err != nil </span><span class="cov0" title="0">{
                        l.Sugar().Error(err)
                        status = http.StatusServiceUnavailable
                        response.PostgresStatus = err.Error()
                }</span>

                <span class="cov0" title="0">wg.Done()</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                err := h.redis.IsHealthy(ctx)

                if err != nil </span><span class="cov0" title="0">{
                        l.Sugar().Error(err)
                        status = http.StatusServiceUnavailable
                        response.RedisStatus = err.Error()
                }</span>

                <span class="cov0" title="0">wg.Done()</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                everyConnected := true

                for _, consumer := range amqp.ConnectedConsumers </span><span class="cov0" title="0">{
                        if consumer == nil || !consumer.Cl</span><span class="cov0" title="0">ient.IsConnected() {
                                everyConnected = false
                                break</span>
                        }
                }

                <span class="cov0" title="0">for _, publisher := range amqp.ConnectedPublishers </span><span class="cov0" title="0">{
                        if publisher == nil || !publisher.C</span><span class="cov0" title="0">lient.IsConnected() {
                                everyConnected = false
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !everyConnected </span><span class="cov0" title="0">{
                        theErr := fmt.Errorf("some RabbitMQ publisher or consumer is not connected")
                        l.Sugar().Error(theErr)
                        status = http.StatusServiceUnavailable
                        response.AmqpStatus = theErr.Error()
                }</span>

                <span class="cov0" title="0">wg.Done()</span>
        }()

        <span class="cov0" title="0">wg.Wait()

        return c.JSON(status, myerror.HttpPayload{
                Message: "Ok",
                Data:    response,
        })</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package orders

import (
        "bytes"
        "context"
        "crypto/hmac"
        "github.com/golang-jwt/jwt/v5"
        "github.com/labstack/echo/v4"
        "go.uber.org/zap"
        "io"
        "net/http"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/infrastructure/redis"
        "tugas-akhir/backend/internal/auth/entity"
        entity3 "tugas-akhir/backend/internal/bookings/entity"
        entity4 "tugas-akhir/backend/internal/events/entity"
        entity2 "tugas-akhir/backend/internal/orders/entity"
        "tugas-akhir/backend/internal/orders/service/idempotent_place_order"
        "tugas-akhir/backend/internal/orders/usecase/get_order"
        "tugas-akhir/backend/internal/orders/usecase/place_order"
        "tugas-akhir/backend/internal/orders/usecase/webhook"
        myerror "tugas-akhir/backend/pkg/error"
        "tugas-akhir/backend/pkg/logger"
        "tugas-akhir/backend/pkg/mock_payment"
        "tugas-akhir/backend/pkg/utility"
        myvalidator "tugas-akhir/backend/pkg/validator"
)

type BaseOrderHandler struct {
        validator           *myvalidator.TranslatedValidator
        placeOrderUsecase   place_order.PlaceOrderUsecase
        getOrderUsecase     get_order.GetOrderUsecase
        webhookOrderUsecase webhook.WebhookOrderUsecase
        config              *config.Config
        redis               *redis.Redis
}

func NewBaseOrderHandler(
        validator *myvalidator.TranslatedValidator,
        placeOrderUsecase place_order.PlaceOrderUsecase,
        getOrderUsecase get_order.GetOrderUsecase,
        webhookOrderUsecase webhook.WebhookOrderUsecase,
        config *config.Config,
        redis *redis.Redis,<span class="cov0" title="0">
) *BaseOrderHandler {
        return &amp;BaseOrderHandler{
                validator:           validator,
                placeOrderUsecase:   placeOrderUsecase,
                getOrderUsecase:     getOrderUsecase,
                webhookOrderUsecase: webhookOrderUsecase,
                config:              config,
                redis:               redis,
        </span>}
}

func (h *BaseOrderHandler) PlaceOrder(c echo.Context) error {
        ctx := c.Request().Context()
        var payload entity2.PlaceOrderDto

</span>        if err := c.Bind(&amp;payload); err != nil {
                return c.JSON(http.StatusBadRequest, myerror.HttpError{
                        Message: "Malformed payload",
                </span>})
        }

        validationError, err := h.validator.Validate(payload)

</span>        if err != nil {
                return c.JSON(http.StatusBadRequest, myerror.HttpError{
                        Message: err.Error(),
                </span>})
        }

</span>        if len(validationError) != 0 {
                </span>return c.JSON(http.StatusBadRequest, myerror.NewFromFieldError(validationError))
        }

        userToken := c.Get(entity.JwtContextKey).(*jwt.Token)
        tokenClaim := userToken.Claims.(*entity.TokenClaim)

        payload.UserID = &amp;tokenClaim.UserID

        idempotencyKey := c.Request().Header.Get(HeaderIdempotencyKey)

</span>        if idempotencyKey != "" {
                </span>payload.IdempotencyKey = &amp;idempotencyKey
        }

        <span class="cov0" title="0">requestID := c.Request().Header.Get(echo.HeaderXRequestID)

        ctx = context.WithValue(ctx, echo.Header</span><span class="cov0" title="0">XRequestID, requestID)

        /</span>/ che<span class="cov0" title="0">ck for request type
        var requestType entity4.AreaType

</span>        if payload.Items[0].TicketSeatID == nil {
        <span class="cov0" title="0">        requestType = entity4.AreaType__FreeStanding
        } else {
                requestType = entity4.AreaType__NumberedSeating
        }

        l := logger.FromCtx(ctx)
        l = l.With(zap.String("area_type", string(requestType)))
        ctx = logger.WithC</span><span class="cov0" title="0">tx(ctx, l)
        c.SetRequest(c.Request().WithContext(ctx))

        r</span>esult, httpErr := idempotent_place_order.WrapIdempotency(ctx, h.redis, h.placeOrderUsecase.PlaceOrder, payload)

        <span class="cov0" title="0">if httpErr != nil {
                httpErr.Log(ctx)
                r</span>eturn c.JSON(httpErr.Code, httpErr)
        }

        return c.JSON(http.StatusOK, myerror.HttpPayload{
                Data: result,
        })
}

</span>func (h *BaseOrderHandler) GetOrder(c echo.Context) error {
        ctx := c.Request().Context()
        var payload entity2.GetOrderDto

</span>        if err := c.Bind(&amp;payload); err != nil {
        <span class="cov0" title="0">        return c.JSON(http.StatusBadRequest, myerror.HttpError{
                        Message: "Malformed payload",
                })
</span>        }

        validationError, err := h.validator.Validate(payload)

</span>        if err != nil {
        <span class="cov0" title="0">        return c.JSON(http.StatusBad</span><span class="cov0" title="0">Request, myerror.HttpError{
                        Message: err.Error(),
                </span>})
        }

        if len(validationError) != 0 {
                return c.JSON</span><span class="cov0" title="0">(http.StatusBadRequest, myerror.NewFromFieldError(validationError))
        }

        OrderID, TicketAreaID, err := utility.ParseNumberString(payload.CompositePK)

</span>        if err != nil {
        <span class="cov0" title="0">        return c.JSON(http.StatusBadRequest, myerror.HttpError{
                        Message: err.Error(),
                })
        }

        payload.OrderID = OrderID
        payload.TicketAreID = TicketAreaID

        userToken := c.Get(entity.JwtContextKey).(*jwt.Token)
        tokenClaim := userToken.Claims.(*entity.TokenClaim)

</span>        payload.UserID = &amp;tokenClaim.UserID

        r</span>esult, httpErr := h.getOrderUsecase.GetOrder(ctx, payload)

        <span class="cov0" title="0">if httpErr != nil {
                httpErr.Log(ctx)
                r</span>eturn c.JSON(httpErr.Code, httpErr)
        }

        return c.JSON(http.StatusOK, myerror.HttpPayload{
                Data: result,
        })
}

</span>func (h *BaseOrderHandler) GetIssuedTickets(c echo.Context) error {
        ctx := c.Request().Context()
        var payload entity3.GetIssuedTicketDto

</span>        if err := c.Bind(&amp;payload); err != nil {
        <span class="cov0" title="0">        return c.JSON(http.StatusBadRequest, myerror.HttpError{
                        Message: "Malformed payload",
                })
</span>        }

        validationError, err := h.validator.Validate(payload)

</span>        if err != nil {
        <span class="cov0" title="0">        return c.JSON(http.StatusBad</span><span class="cov0" title="0">Request, myerror.HttpError{
                        Message: err.Error(),
                </span>})
        }

        if len(validationError) != 0 {
                return c.JSON</span><span class="cov0" title="0">(http.StatusBadRequest, myerror.NewFromFieldError(validationError))
        }

        OrderID, TicketAreaID, err := utility.ParseNumberString(payload.CompositePK)

</span>        if err != nil {
        <span class="cov0" title="0">        return c.JSON(http.StatusBadRequest, myerror.HttpError{
                        Message: err.Error(),
                })
        }

        payload.OrderID = OrderID
        payload.TicketAreaID = TicketAreaID

        userToken := c.Get(entity.JwtContextKey).(*jwt.Token)
        tokenClaim := userToken.Claims.(*entity.TokenClaim)

</span>        payload.UserID = &amp;tokenClaim.UserID

        r</span>esult, httpErr := h.getOrderUsecase.GetIssuedTicket(ctx, payload)

        <span class="cov0" title="0">if httpErr != nil {
                httpErr.Log(ctx)
                r</span>eturn c.JSON(httpErr.Code, httpErr)
        }

        return c.JSON(http.StatusOK, myerror.HttpPayload{
                Data: result,
        })
}

func (h *BaseOr</span><span class="cov0" title="0">derHandler) HandleWebhook(c echo.Context) error {
        ctx := c.Request().Context()

        raw, err := io.ReadAll(c.Request().Body)

</span>        if err != nil {
        <span class="cov0" title="0">        return c.JSON(http.StatusBadRequest, myerror.HttpError{
                        Message: "Cannot read request body",
                })
        }

        rawStr := string(raw)

        c.Request().Body = io.NopCloser(bytes.NewReader(raw))

        given := c.Request().Header.Get("x-webhook-verif</span><span class="cov0" title="0">y")

        // verify the webhook token
        computed := utility.ComputeHMACSHA256(h.config.WebhookSecret, rawStr)

</span>        if !hmac.Equal([]byte(given), []byte(computed)) {
        <span class="cov0" title="0">        return c.JSON(http.StatusForbidden, myerror.HttpError{
                        Message: "Given and computed webhook token is different",
                })
</span>        }

        var payload mock_payment.Invoice

</span>        if err := c.Bind(&amp;payload); err != nil {
        <span class="cov0" title="0">        return c.JSON(http.StatusBadRequest, myerror.HttpError{
                        Message: "Malformed payload",
                })
</span>        }

        validationError, err := h.validator.Validate(payload)

</span>        if err != nil {
        <span class="cov0" title="0">        return c.JSON(http.StatusBad</span><span class="cov0" title="0">Request, myerror.HttpError{
                        Message: err.Error(),
                </span>})
        }

        if len(validationError) != 0 {
                return c.JSON(htt</span><span class="cov0" title="0">p.StatusBadRequest, myerror.NewFromFieldError(validationError))
        }

        h</span>ttpErr := h.webhookOrderUsecase.HandleWebhook(ctx, payload)

        <span class="cov0" title="0">if httpErr != nil {
                httpErr.Log(ctx)
                r</span>eturn c.JSON(httpErr.Code, httpErr)
        }

        return c.JSON(http.StatusOK, myerror.HttpPayload{
                Message: "ok",
        })
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package server

import (
        "context"
        "errors"
        "fmt"
        "github.com/labstack/echo-contrib/echoprometheus"
        "github.com/labstack/echo-contrib/pprof"
        "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"
        "go.uber.org/fx"
        "net/http"
        "tugas-akhir/backend/app/server/handler/health"
        middleware2 "tugas-akhir/backend/app/server/middleware"
        "tugas-akhir/backend/app/server/route"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/pkg/logger"
)

type Server struct {
        config *config.Config
        engine *echo.Echo
}

func (s *Server) Run() {
        address := fmt.Sprintf<span class="cov0" title="0">(":%d", s.config.ServerPort)

        // start server
        go func() {
                logger.Ge</span><span class="cov0" title="0">tInfo().Sugar().Infof("Server started on port %d", s.config.ServerPort)
                if err := s.engine.StartTLS(address, s.config.TlsCertPath, s.config.TlsKeyPath); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) {
                        s.engine.Logger.Fatal("Shutting down the server")
</span>                }
        }(</span>)

        // start prometheus server
        go func() {
        <span class="cov0" title="0">        metricSer</span><span class="cov0" title="0">ver := echo.New()
                metricServer.HideBanner = true
                metricServer.HidePort = true

                metricServer.GET("/metrics", echoprometheus.NewHandler()) // adds route to serve gathered metrics

                if err := metricServer.Start(fmt.Sprintf(":%d", s.config.PrometheusPort)); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) {
                        metricServer.Logger.Fatal("Shutting down the server")
</span>                }
        }(</span>)
}

func (s *Server) Stop(context context.Context) error {
        return s.engine.Shutdown(context)
}

</span>func NewServer(
        healthHandler health.HealthcheckHandler,
        routes *route.Routes,
        config *config.Config,
        loggerMiddleware *middleware2.LoggerMiddleware,
) *Server {
        l := logg<span class="cov0" title="0">er.FromCtx(context.Background())
        engine := echo.New()
        engine.HideBanner = true
        engine.HidePort = true

        if config.EnableProfiling {
                l.Info("Profiling enabled</span><span class="cov0" title="0">")
                pprof.Register(engine)
        }

</span>        engine.Use(echoprometheus.NewMiddlewareWithConfig(echoprometheus.MiddlewareConfig{
        <span class="cov0" title="0">        Namespace: "ticket_backend",
                Skipper: func(c echo.Context) bool {
                        return c.Path() == "/health"
</span>                },
                L</span>abelFuncs: map[string]echoprometheus.LabelValueFunc{
                        "test_scenario":        func(c echo.Context, err error) string { return config.TestScenario },
                        "db_variant":           func(c echo.Context, err error) string <span class="cov0" title="0">{ return string(config.DBVaria</span>nt) },
                        "flow_control_variant": func(c echo.Context, err error) string <span class="cov0" title="0">{ return string(config.FlowControlV</span>ariant) },
                        "kubernetes_pod":       func(c echo.Context, err error) string <span class="cov0" title="0">{ return config.PodName },
</span>                },
</span>        }))

        timeoutMiddleware := middleware2.NewTimeoutMiddleware()

        engine.Use(timeoutMiddleware.TimeoutMiddleware)

        engine.Pre(middleware.RemoveTrailingSlash())

        engine.Use(middleware.RequestID())

        // default error handler
        engine.Use(middleware.Recover())

        //engine.GET("/metrics", echoprometheus.NewHandler()) // adds route to serve gathered metrics

        engine.GET("/health", healthHandler.Healthcheck)

        // setup common middleware=
        engine.Use(loggerMiddleware.LoggerMiddleware)

        engine.GET("/", func(c echo.Context) error {
                return c.JSON(http.StatusOK, struct {
</span>                        FlowControlVariant string `json:"flowControlVariant"`
                        DBVariant          string `json:"dbVariant"`
                        Scenario           string `json:"scenario"`
                }{
                        FlowControlVariant: string(config.FlowControlVariant),
                        DBVariant:          string(config.DBVariant),
                        Scenario:           config.TestScenario,
                })
        })

</span>        routes.Setup(engine)

        return &amp;Server{
                config: config,
                engine: engine,
        }
}
</span>
var Module = fx.Options(
        fx.Provide(
                fx.Annotate(
                        NewServer,
                        fx.OnStop(func(ctx context.Context, server *Server) error {
                                return server.Stop(ctx)
                        }),
                ),</span>
        ),
)
</pre>
		
		<pre class="file" id="file14" style="display: none">package middleware

import (
        "github.com/golang-jwt/jwt/v5"
        config2 "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/internal/auth/entity"
        "tugas-akhir/backend/pkg/logger"

        echojwt "github.com/labstack/echo-jwt/v4"
        "github.com/labstack/echo/v4"
        "go.uber.org/zap"
)

type AuthMiddleware struct {
        JwtMiddleware echo.MiddlewareFunc
}

func wrapJWTMiddleware(jwtMiddleware echo.MiddlewareFunc) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return jwtMiddleware(func(c echo.Context) error </span><span class="cov0" title="0">{
                        userToken := c.Get(entity.JwtContextKey).(*jwt.Token)
                        claims := userToken.Claims.(*entity.TokenClaim)

                        ctx := c.Request().Context()
                        l := logger.FromCtx(ctx)
                        l.With(zap.String("userId", claims.UserID))

                        c.SetRequest(c.Request().WithContext(logger.WithCtx(ctx, l)))

                        return next(c)
                }</span>)
        }
}

func NewAuthMiddleware(config *config2.Config,
) *AuthMiddleware <span class="cov0" title="0">{
        middleware := echojwt.WithConfig(echojwt.Config{
                NewClaimsFunc: func(c echo.Context) jwt.Claims </span><span class="cov0" title="0">{
                        return new(entity.TokenClaim)
                }</span>,
                SigningKey: []byte(config.JwtSecret),
                ContextKey: entity.JwtContextKey,
        })

        <span class="cov0" title="0">return &amp;AuthMiddleware{
                JwtMiddleware: wrapJWTMiddleware(middleware),
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package middleware

import (
        "fmt"
        "strings"
        "time"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/pkg/logger"

        "github.com/labstack/echo/v4"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

type LoggerMiddleware struct {
        LoggerMiddleware echo.MiddlewareFunc
}

func NewLoggerMiddleware(config *config.Config) *LoggerMiddleware <span class="cov0" title="0">{
        l := logger.GetInfo()

        return &amp;LoggerMiddleware{
                LoggerMiddleware: func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                        return func(c echo.Context) error </span><span class="cov0" title="0">{
                                start := time.Now()

                                beforeReq := c.Request()

                                id := beforeReq.Header.Get(echo.HeaderXRequestID)

                                ctx := c.Request().Context()

                                log := l.With(zap.String("request_id", id))

                                ctx = logger.WithCtx(ctx, log)

                                beforeReq = c.Request().WithContext(ctx)

                                c.SetRequest(beforeReq)

                                err := next(c)
                                if err != nil </span><span class="cov0" title="0">{
                                        c.Error(err)
                                }</span>

                                <span class="cov0" title="0">afterReq := c.Request()
                                afterRes := c.Response()

                                // take from
                                log = logger.FromCtx(afterReq.Context())

                                fields := []zapcore.Field{
                                        //zap.String("remote_ip", c.RealIP()),
                                        zap.String("latency", time.Since(start).String()),
                                        //zap.String("host", afterReq.Host),
                                        zap.String("request", fmt.Sprintf("%s %s", afterReq.Method, afterReq.RequestURI)),
                                        zap.Int("status", afterRes.Status),
                                        zap.Int64("size", afterRes.Size),
                                        //zap.String("user_agent", afterReq.UserAgent()),
                                        //zap.String("db_variant", string(config.DBVariant)),
                                        //zap.String("fc_variant", string(config.FlowControlVariant)),
                                        //zap.String("test_scenario", config.TestScenario),
                                }

                                if strings.Contains(afterReq.RequestURI, "health") || strings.Contains(afterReq.RequestURI, "metrics") </span><span class="cov0" title="0">{
                                        // skip healthcheck endpoint
                                        return nil
                                }</span>

                                <span class="cov0" title="0">n := afterRes.Status
                                switch </span>{
                                case n &gt;= 500:<span class="cov0" title="0">
                                        log.With(zap.Error(err)).Error("Server error", fields...)</span>
                                case n &gt;= 400:<span class="cov0" title="0">
                                        log.With(zap.Error(err)).Warn("Client error", fields...)</span>
                                case n &gt;= 300:<span class="cov0" title="0">
                                        log.Info("Redirection", fields...)</span>
                                default:<span class="cov0" title="0"></span>
                                        // skip 2xx response
                                        //log.Info("Success", fields...)
                                }

                                <span class="cov0" title="0">return nil</span>
                        }
                },
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package route

import (
        "github.com/labstack/echo/v4"
        "tugas-akhir/backend/app/server/handler/events"
        "tugas-akhir/backend/app/server/middleware"
)

type EventsRoute struct {
        authMiddleware *middleware.AuthMiddleware
        eventHandler   *events.EventHandler
}

func NewEventsRoute(
        authMiddleware *middleware.AuthMiddleware,
        eventHandler *events.EventHandler,
) *EventsRoute <span class="cov0" title="0">{
        return &amp;EventsRoute{
                authMiddleware: authMiddleware,
                eventHandler:   eventHandler,
        }
}</span>

func (r *EventsRoute) Setup(engine *echo.Group) <span class="cov0" title="0">{
        group := engine.Group("/events")
        group.Use(r.authMiddleware.JwtMiddleware)

        group.GET("/availability/:ticketSaleId", r.eventHandler.GetAvailability)
        group.GET("/seats/:ticketAreaId", r.eventHandler.GetSeats)
        group.GET("/:eventId", r.eventHandler.GetEvent)
        group.GET("", r.eventHandler.GetEvents)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package route

import (
        "github.com/labstack/echo/v4"
        "tugas-akhir/backend/app/server/handler/orders"
        "tugas-akhir/backend/app/server/middleware"
)

type OrdersRoute struct {
        authMiddleware *middleware.AuthMiddleware
        orderHandler   orders.OrderHandler
}

func NewOrdersRoute(
        authMiddleware *middleware.AuthMiddleware,
        orderHandler orders.OrderHandler,
) *OrdersRoute <span class="cov0" title="0">{
        return &amp;OrdersRoute{
                authMiddleware: authMiddleware,
                orderHandler:   orderHandler,
        }
}</span>

func (r *OrdersRoute) Setup(engine *echo.Group) <span class="cov0" title="0">{
        group := engine.Group("/orders")
        group.Use(r.authMiddleware.JwtMiddleware)

        group.POST("", r.orderHandler.PlaceOrder)
        group.GET("/:id", r.orderHandler.GetOrder)
        group.GET("/:id/tickets", r.orderHandler.GetIssuedTickets)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package route

import (
        "github.com/labstack/echo/v4"
        "go.uber.org/fx"
)

type Route interface {
        Setup(engine *echo.Group)
}

type Routes struct {
        root []Route
}

func (r Routes) Setup(engine *echo.Echo) <span class="cov0" title="0">{
        rootGroup := engine.Group("")

        for _, route := range r.root </span><span class="cov0" title="0">{
                route.Setup(rootGroup)
        }</span>
}

func NewRoutes(
        eventsRoute *EventsRoute,
        ordersRoute *OrdersRoute,
        webhookRoute *WebhookRoute,
) *Routes <span class="cov0" title="0">{
        rootRoutes := []Route{
                eventsRoute,
                ordersRoute,
                webhookRoute,
        }

        return &amp;Routes{
                root: rootRoutes,
        }
}</span>

var Module = fx.Options(
        fx.Provide(NewEventsRoute),
        fx.Provide(NewOrdersRoute),
        fx.Provide(NewRoutes),
        fx.Provide(NewWebhookRoute),
)
</pre>
		
		<pre class="file" id="file19" style="display: none">package route

import (
        "github.com/labstack/echo/v4"
        "tugas-akhir/backend/app/server/handler/orders"
)

type WebhookRoute struct {
        webhookHandler orders.OrderHandler
}

func NewWebhookRoute(
        webhookHandler orders.OrderHandler,
) *WebhookRoute <span class="cov0" title="0">{
        return &amp;WebhookRoute{
                webhookHandler: webhookHandler,
        }
}</span>

func (r *WebhookRoute) Setup(engine *echo.Group) <span class="cov0" title="0">{
        group := engine.Group("/webhooks")

        group.POST("", r.webhookHandler.HandleWebhook)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package main

import (
        "context"
        "os"
        "os/signal"
        "sync"
        "time"
        "tugas-akhir/backend/app/server"
        "tugas-akhir/backend/app/server/handler"
        "tugas-akhir/backend/app/server/middleware"
        "tugas-akhir/backend/app/server/route"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/infrastructure/memcache"
        "tugas-akhir/backend/infrastructure/postgres"
        "tugas-akhir/backend/infrastructure/redis"
        "tugas-akhir/backend/internal/bookings"
        "tugas-akhir/backend/internal/events"
        "tugas-akhir/backend/internal/orders"
        "tugas-akhir/backend/internal/payments"
        "tugas-akhir/backend/pkg/logger"
        myvalidator "tugas-akhir/backend/pkg/validator"

        _ "github.com/KimMachineGun/automemlimit"
        _ "go.uber.org/automaxprocs"
        "go.uber.org/fx"
        "go.uber.org/fx/fxevent"
)

func RunServer(
        server *server.Server,
        c<span class="cov0" title="0"> *config.Config,
) {
        c.FlowControlVariant = config.FlowControlVariant__DropperAsync

        </span>server.Run()
}

func main() {
        app := fx.New(
</span>                fx.WithLogger(func() fxevent.Logger {
                        </span>return &amp;fxevent.ZapLogger{Logger: logger.GetInfo()}
                }),
                fx.Provide(myvalidator.NewTranslastedValidator),
                config.Module,
                memcache.Module,
                postgres.Module,
                redis.Module,
                middleware.Module,
                handler.FCModule,
                bookings.BaseModule,
                events.BaseModule,
                orders.FCModule,
                payments.BaseModule,
                route.Module,
                server.Module,
                fx.Invoke(RunServer),
        )

        ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
        defer stop()

        var wg sync.WaitGroup
        wg.Add(1)

</span>        go func() {
                app.Run()
                </span>wg.Done()
        }()

        wg.Wait()

        // Wait for interrupt signal to gracefully shutdown the server with a timeout
        &lt;-ctx.Done()

        shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

</span>        if err := app.Stop(shutdownCtx); err != nil {
                </span>logger.GetInfo().Info("Application was shutdown ungracefully")
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package main

import (
        "context"
        _ "github.com/KimMachineGun/automemlimit"
        _ "go.uber.org/automaxprocs"
        "go.uber.org/fx"
        "go.uber.org/fx/fxevent"
        "os"
        "os/signal"
        "sync"
        "time"
        "tugas-akhir/backend/app/processor"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/infrastructure/memcache"
        "tugas-akhir/backend/infrastructure/postgres"
        "tugas-akhir/backend/infrastructure/redis"
        "tugas-akhir/backend/internal/bookings"
        "tugas-akhir/backend/internal/events"
        "tugas-akhir/backend/internal/orders"
        "tugas-akhir/backend/internal/payments"
        "tugas-akhir/backend/pkg/logger"
)

func main() {
        l := logger.GetInfo()

        ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
        defer stop()

        ctx = logger.WithCtx(ctx, l)

        app := fx.New(
</span>                fx.WithLogger(func() fxevent.Logger {
                        </span>return &amp;fxevent.ZapLogger{Logger: logger.GetInfo()}
                }),
                config.Module,
                memcache.Module,
                postgres.Module,
                redis.Module,
                bookings.BaseModule,
                events.BaseModule,
                orders.FCWorkerModule,
                payments.BaseModule,
                processor.Module,
                fx.Invoke(func(processor *processor.Processor, metricsServer *processor.MetricsServer, c *config.Config) error {
                        c.FlowControlVariant = config.FlowControlVariant__DropperAsync

</span>                        if err := processor.Run(ctx); err != nil {
                                </span>return err
                        }

</span>                        if err := metricsServer.Run(ctx); err != nil {
                                </span>return err
                        }

</span>                        return nil
                },
                ),
        )

        var wg sync.WaitGroup
        wg.Add(1)

</span>        go func() {
                app.Run()
                </span>wg.Done()
        }()

        wg.Wait()

        // Wait for interrupt signal to gracefully shutdown the server with a timeout
        &lt;-ctx.Done()

        shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

</span>        if err := app.Stop(shutdownCtx); err != nil {
                </span>logger.GetInfo().Info("Application was shutdown ungracefully")
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package main

import (
        "context"
        _ "github.com/KimMachineGun/automemlimit"
        "os"
        "os/signal"
        "sync"
        "time"
        "tugas-akhir/backend/app/server"
        "tugas-akhir/backend/app/server/handler"
        "tugas-akhir/backend/app/server/middleware"
        "tugas-akhir/backend/app/server/route"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/infrastructure/memcache"
        "tugas-akhir/backend/infrastructure/postgres"
        "tugas-akhir/backend/infrastructure/redis"
        "tugas-akhir/backend/internal/bookings"
        "tugas-akhir/backend/internal/events"
        "tugas-akhir/backend/internal/orders"
        "tugas-akhir/backend/internal/payments"
        "tugas-akhir/backend/pkg/logger"
        myvalidator "tugas-akhir/backend/pkg/validator"

        _ "go.uber.org/automaxprocs"
        "go.uber.org/fx"
        "go.uber.org/fx/fxevent"
)

func RunServer(server *server.Server, c *config.Config) {
        c.FlowControlVariant = config.FlowControlVariant__NoFlowControl
        </span>server.Run()
}

func main() {
        app := fx.New(
</span>                fx.WithLogger(func() fxevent.Logger {
                        </span>return &amp;fxevent.ZapLogger{Logger: logger.GetInfo()}
                }),
                fx.Provide(myvalidator.NewTranslastedValidator),
                config.Module,
                memcache.Module,
                postgres.Module,
                redis.Module,
                middleware.Module,
                handler.BaseModule,
                bookings.BaseModule,
                events.BaseModule,
                orders.BaseModule,
                payments.BaseModule,
                route.Module,
                server.Module,
                fx.Invoke(RunServer),
        )

        ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
        defer stop()

        var wg sync.WaitGroup
        wg.Add(1)

</span>        go func() {
                app.Run()
                </span>wg.Done()
        }()

        wg.Wait()

        // Wait for interrupt signal to gracefully shutdown the server with a timeout
        &lt;-ctx.Done()

        shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

</span>        if err := app.Stop(shutdownCtx); err != nil {
                </span>logger.GetInfo().Info("Application was shutdown ungracefully")
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package main

import (
        "context"
        _ "github.com/KimMachineGun/automemlimit"
        _ "go.uber.org/automaxprocs"
        "go.uber.org/fx"
        "go.uber.org/fx/fxevent"
        "os"
        "os/signal"
        "sync"
        "time"
        "tugas-akhir/backend/app/processor"
        "tugas-akhir/backend/app/sanity"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/infrastructure/memcache"
        "tugas-akhir/backend/infrastructure/postgres"
        "tugas-akhir/backend/infrastructure/redis"
        "tugas-akhir/backend/pkg/logger"
)

func main() {
        l := logger.GetInfo()

        ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
        defer stop()

        ctx = logger.WithCtx(ctx, l)

        app := fx.New(
</span>                fx.WithLogger(func() fxevent.Logger {
                        </span>return &amp;fxevent.ZapLogger{Logger: logger.GetInfo()}
                }),
                config.Module,
                memcache.Module,
                postgres.Module,
                redis.Module,
                fx.Provide(fx.Annotate(
                        processor.NewMetricsServer,
                        fx.OnStop(func(ctx context.Context, metricsServer *processor.MetricsServer) error {
                                </span>return metricsServer.Stop(ctx)
                        }),
                )),
                fx.Provide(fx.Annotate(
                        sanity.NewSanityCheck,
                        fx.OnStop(func(sanityCheck *sanity.SanityCheck) error {
                                sanityCheck.Stop()
                                </span>return nil
                        }),
                )),
                fx.Invoke(func(sanityCheck *sanity.SanityCheck, metricsServer *processor.MetricsServer, c *config.Config) error {
                        sanityCheck.Run(ctx)

</span>                        if err := metricsServer.Run(ctx); err != nil {
                                </span>return err
                        }

</span>                        return nil
                },
                ),
        )

        var wg sync.WaitGroup
        wg.Add(1)

</span>        go func() {
                app.Run()
                </span>wg.Done()
        }()

        wg.Wait()

        // Wait for interrupt signal to gracefully shutdown the server with a timeout
        &lt;-ctx.Done()

        shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

</span>        if err := app.Stop(shutdownCtx); err != nil {
                </span>logger.GetInfo().Info("Application was shutdown ungracefully")
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package main

import (
        "context"
        _ "github.com/KimMachineGun/automemlimit"
        baseredis "github.com/redis/go-redis/v9"
        _ "go.uber.org/automaxprocs"
        "go.uber.org/zap"
        "math"
        "os"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/infrastructure/postgres"
        "tugas-akhir/backend/infrastructure/redis"
        "tugas-akhir/backend/internal/bookings/repository/booked_seats"
        "tugas-akhir/backend/internal/bookings/service"
        "tugas-akhir/backend/internal/events/service/redis_availability_seeder"
        "tugas-akhir/backend/internal/orders/service/early_dropper"
        "tugas-akhir/backend/internal/seeder"
        "tugas-akhir/backend/pkg/logger"
)

func getScaledCategories(scale int) seeder.SeederPayload {
        return seeder.SeederPayload{
                DayCount: 0,
                SeatedCategories: []seeder.CategoryPayload{
                        {Name: "Lower - Platinum East 1", Price: 3000000, AreaCount: 1, SeatPerArea: int(math.Floor(float64(2000 / scale)))},
                        {Name: "Lower - Platinum East 2", Price: 3000000, AreaCount: 1, SeatPerArea: int(math.Floor(float64(2000 / scale)))},
                        {Name: "Lower - Platinum West 1", Price: 3000000, AreaCount: 1, SeatPerArea: int(math.Floor(float64(2000 / scale)))},
                        {Name: "Lower - Platinum West 2", Price: 3000000, AreaCount: 1, SeatPerArea: int(math.Floor(float64(2000 / scale)))},
                        {Name: "Lower - Gold East 1", Price: 2500000, AreaCount: 1, SeatPerArea: int(math.Floor(float64(1750 / scale)))},
                        {Name: "Lower - Gold East 2", Price: 2500000, AreaCount: 1, SeatPerArea: int(math.Floor(float64(1750 / scale)))},
                        {Name: "Lower - Gold West 1", Price: 2500000, AreaCount: 1, SeatPerArea: int(math.Floor(float64(1750 / scale)))},
                        {Name: "Lower - Gold West 2", Price: 2500000, AreaCount: 1, SeatPerArea: int(math.Floor(float64(1750 / scale)))},
                        {Name: "Lower - Silver North", Price: 2000000, AreaCount: 5, SeatPerArea: int(math.Floor(float64(1000 / scale)))},
                        {Name: "Lower - Silver South", Price: 2000000, AreaCount: 5, SeatPerArea: int(math.Floor(float64(1000 / scale)))},
                        {Name: "Upper - Bronze West", Price: 1750000, AreaCount: 10, SeatPerArea: int(math.Floor(float64(1050 / scale)))},
                        {Name: "Upper - Bronze East", Price: 1750000, AreaCount: 10, SeatPerArea: int(math.Floor(float64(1050 / scale)))},
                        {Name: "Upper - Bronze North", Price: 1500000, AreaCount: 7, SeatPerArea: int(math.Floor(float64(1000 / scale)))},
                        {Name: "Upper - Bronze South", Price: 1500000, AreaCount: 7, SeatPerArea: int(math.Floor(float64(1000 / scale)))},
                },
                FreeStandingCategories: []seeder.CategoryPayload{
                        {Name: "VIP", Price: 4000000, AreaCount: 1, SeatPerArea: int(math.Floor(float64(4000 / scale)))},
                        {Name: "Zone A", Price: 3250000, AreaCount: 1, SeatPerArea: int(math.Floor(float64(8000 / scale)))},
                        {Name: "Zone B", Price: 2500000, AreaCount: 1, SeatPerArea: int(math.Floor(float64(8000 / scale)))},
                },
        </span>}
}

// seedPayloadByScenario
// List of scenario
// xx-y
// xx variant: sf (scale full), s2 (scale by 2), s3 (scale by 3), ...
// y variant: 1, 2, 3 (day count)
// Festival/ free seating area can hold 20.000 person.
// Lower seat can hold 25.000 person.
// Upper seat can hold 35.000 person.
// In GBK, lower seat divided into:
// - Platinum East 1, Platinum East 2, Platinum West 1, Platinum West 2 @2000 seat -&gt; 1 area
// - Gold East 1, Gold East 2, Gold West 1, Gold West 2 @1750 seat -&gt; 1 area
// - Silver North, Silver South @5000 seat -&gt; 5 area
// Upper seat can divided into:
// - Bronze North, Bronze South @7000 seat -&gt; 7 area
// - Bronze West, Bronze East @10500 seat -&gt; 10 area
// Festival can be divided into:
// - VIP Total 4000 seat.
// - Zone A Total 8000 seat.
// - Zone B Total 8000 seat.
func seedPayloadB</span>yScenario(scenario string) *seeder.SeederPayload {
        switch scenario {
        // Per day 8<span class="cov0" title="0">0.000 ticket With a total of 4 day
        case "sf-4":
                payload := getScaledCategories(1)
                payload.DayCoun</span>t = 4
                return &amp;pay<span class="cov0" title="0">load
        case "sf-2":
                payload := getScaledCategories(1)
                payload.DayCoun</span>t = 2
                return &amp;pay<span class="cov0" title="0">load
        case "sf-1":
                payload := getScaledCategories(1)
                payload.DayCoun</span>t = 1
                return &amp;pay<span class="cov0" title="0">load
        case "s2-4":
                payload := getScaledCategories(2)
                payload.DayCoun</span>t = 4
                return &amp;pay<span class="cov0" title="0">load
        case "s2-2":
                payload := getScaledCategories(2)
                payload.DayCoun</span>t = 2
                return &amp;pay<span class="cov0" title="0">load
        case "s2-1":
                payload := getScaledCategories(2)
                payload.DayCoun</span>t = 1
                return &amp;pay<span class="cov0" title="0">load
        case "s5-4":
                payload := getScaledCategories(5)
                payload.DayCoun</span>t = 4
                return &amp;pay<span class="cov0" title="0">load
        case "s5-2":
                payload := getScaledCategories(5)
                payload.DayCoun</span>t = 2
                return &amp;pay<span class="cov0" title="0">load
        case "s5-1":
                payload := getScaledCategories(5)
                payload.DayCoun</span>t = 1
                return &amp;payl<span class="cov0" title="0">oad
        case "s10-4":
                payload := getScaledCategories(10)
                payload.DayCoun</span>t = 4
                return &amp;payl<span class="cov0" title="0">oad
        case "s10-2":
                payload := getScaledCategories(10)
                payload.DayCoun</span>t = 2
                return &amp;payl<span class="cov0" title="0">oad
        case "s10-1":
                payload := getScaledCategories(10)
                payload.DayCoun</span>t = 1
                return <span class="cov0" title="0">&amp;payload
        default:
</span>                return nil
        }
}

func main() {
        l := logger.GetInfo().Sugar()

        c, err := config.NewConfig()

</span>        if err != nil {
                l.Error(err)
                </span>os.Exit(1)
        }

        db, err := pos</span><span class="cov0" title="0">tgres.NewPostgres(c)
        if err != nil {
                l.Error(err)
                </span>os.Exit(1)
        }

        redisInstance,</span><span class="cov0" title="0"> err := redis.NewRedis(c)
        if err != nil {
                l.Error(err)
                </span>os.Exit(1)
        }

        ctx := context.Background()

</span>        err = redisInstance.Client.ForEachMaster(ctx, func(ctx context.Context, client *baseredis.Client) error {
                </span>return client.FlushDB(ctx).Err()
        <span class="cov0" title="0">})
</span>        if err != nil {
                l.Error("failed flushing redis cluster", zap.Error(err))
                </span>os.Exit(1)
        }

        schemaManager := seeder.NewSchemaManager(db)

        err = schemaMa</span><span class="cov0" title="0">nager.SchemaDown(ctx)
        if err != nil {
                l.Error("failed running schema down", zap.Error(err))
                </span>os.Exit(1)
        }

        err = schemaMa</span><span class="cov0" title="0">nager.ExtensionSetup(ctx)
        if err != nil {
                l.Error("failed running extension setup", zap.Error(err))
                </span>os.Exit(1)
        }

        if c.DBVariant</span><span class="cov0" title="0"> == config.DBVariant__YugabyteDB {
                err = schemaManager.YugabyteSchemaUp(ctx)
                if err != nil {
                </span>        l.Error("failed running schema up", zap.Error(err))
                        os.Exit(1)
        <span class="cov0" title="0">        }
</span>        } else {
                err = schemaManager.SchemaUp(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        l.Error("failed running schema up", zap.Error(err))
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">if c.DBVariant == config.DBVariant__Citusdata {
                l.Info("Citus setup is run")
                err = schemaManager.CitusSetup(ctx)
                if err != nil {
                        l.Error("failed runn</span><span class="cov0" title="0">ing citus setup", zap.Error(err))
                        os.Exit(1)
                }
        }</span>

        <span class="cov0" title="0">caseSeeder := seeder.NewCaseSeeder(db)

</span>        seedPayload := seedPayloadByScenario(c.TestScenario)

        i</span>f seedPayload == nil {
                l.Error("Invalid scenario")
        <span class="cov0" title="0">        os.Exit(1)
        }

</span>        err = caseSeeder.Seed(ctx, *seedPayload)
        if err != nil {
                </span>l.Error("failed running seed", zap.Error(err))
                os.Exit(1)
        }

</span>        availabilitySeeder := redis_availability_seeder.NewRedisAvailabilitySeeder(c, redisInstance, db)
        err = availabilitySeeder.RunSync(ctx)
        if err != nil {</span><span class="cov0" title="0">
                l.Error("failed running availability seeder", zap.Error(err))
                os.Exit(1)
        }
</span>
        // stupid bug
        <span class="cov0" title="0">if c.SeedDropper != "no" {
</span>                earlyDropper := early_dropper.NewFCEarlyDropper(c, redisInstance, booked_seats.NewPGBookedSeatRepository(db, service.NewSerialNumberGenerator()))
                err = earlyDropper.RunSync(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        l.Error("failed running early dropper seeder", zap.Error(err))
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">if c.DBVariant != config.DBVariant__YugabyteDB {
                l.Info("P</span>rewarm is run")
                err = schemaManager.Prewarm(ctx)
                if err != nil {
                        l.Error("failed running prewarm", zap.Error(err))
                        os.Exit(1)
                }
        } else {
                l.Info("Prewarm is run")
                err = schemaManager.YugabytePrewarm(ctx)
                if err != nil {
                        l.Error("failed running prewarm", zap.Error(err))
                        os.Exit(1)
                }
        }

        l.Info("seeder success")
        os.Exit(0)
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package amqp

import (
        "context"
        "github.com/rabbitmq/amqp091-go"
        "go.uber.org/zap"
        "tugas-akhir/backend/infrastructure/amqp/entity"
        "tugas-akhir/backend/pkg/utility"

        "sync"
        "time"
)

var ConnectedConsumers = make([]*Consumer, 0)
var ConnectedPublishers = make([]*Publisher, 0)

// Client is the base struct for handling connection recovery, consumption and
// publishing. Note that this struct has an internal mutex to safeguard against
// data races.
type Client struct {
        M               *sync.Mutex
        Queue           *entity.QueueConfig
        Exchange        *entity.ExchangeConfig
        Logger          *zap.Logger
        connection      *amqp091.Connection
        channel         *amqp091.Channel
        done            chan bool
        notifyConnClose chan *amqp091.Error
        notifyChanClose chan *amqp091.Error
        notifyConfirm   chan amqp091.Confirmation
        isReady         bool
}

func (client *Client) IsConnected() bool <span class="cov0" title="0">{
        return client != nil &amp;&amp; client.connection != nil &amp;&amp; !client.connection.IsClosed()
}</span>

func (client *Client) WaitUntilReady(ctx context.Context) <span class="cov4" title="6">{
        for </span><span class="cov10" title="150">{
                client.M.Lock()

                if client.isReady </span><span class="cov3" title="4">{
                        client.M.Unlock()
                        break</span>
                }

                <span class="cov9" title="146">client.M.Unlock()

                utility.SleepWithContext(ctx, time.Second)</span>
        }
}

// handleReconnect will wait for a connection error on
// notifyConnClose, and then continuously attempt to reconnect.
func (client *Client) handleReconnect(address string) <span class="cov4" title="8">{
        for </span><span class="cov4" title="8">{
                client.M.Lock()
                client.isReady = false
                client.M.Unlock()

                client.Logger.Info("attempting to connect")

                conn, err := client.connect(address)
                if err != nil </span><span class="cov0" title="0">{
                        client.Logger.Error("failed to connect. Retrying...", zap.Error(err))

                        select </span>{
                        case &lt;-client.done:<span class="cov0" title="0">
                                return</span>
                        case &lt;-time.After(entity.ReconnectDelay):<span class="cov0" title="0"></span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov4" title="8">if done := client.handleReInit(conn); done </span><span class="cov4" title="8">{
                        break</span>
                }
        }
}

// connect will create a new AMQP connection
func (client *Client) connect(address string) (*amqp091.Connection, error) <span class="cov4" title="8">{
        conn, err := amqp091.Dial(address)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="8">client.changeConnection(conn)
        client.Logger.Info("connected")
        return conn, nil</span>
}

// handleReInit will wait for a channel error
// and then continuously attempt to re-initialize both channels
func (client *Client) handleReInit(conn *amqp091.Connection) bool <span class="cov4" title="8">{
        for </span><span class="cov4" title="8">{
                client.M.Lock()
                client.isReady = false
                client.M.Unlock()

                err := client.init(conn)
                if err != nil </span><span class="cov0" title="0">{
                        client.Logger.Info("failed to initialize channel, retrying...")

                        select </span>{
                        case &lt;-client.done:<span class="cov0" title="0">
                                return true</span>
                        case &lt;-client.notifyConnClose:<span class="cov0" title="0">
                                client.Logger.Info("connection closed, reconnecting...")
                                return false</span>
                        case &lt;-time.After(entity.ReInitDelay):<span class="cov0" title="0"></span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov4" title="8">select </span>{
                case &lt;-client.done:<span class="cov4" title="8">
                        return true</span>
                case &lt;-client.notifyConnClose:<span class="cov0" title="0">
                        client.Logger.Info("connection closed, reconnecting...")
                        return false</span>
                case &lt;-client.notifyChanClose:<span class="cov0" title="0">
                        client.Logger.Info("channel closed, re-running init...")</span>
                }
        }
}

// init will initialize channel &amp; declare queue
func (client *Client) init(conn *amqp091.Connection) error <span class="cov4" title="8">{
        ch, err := conn.Channel()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="8">err = ch.Confirm(false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="8">if client.Exchange != nil </span><span class="cov4" title="8">{
                err = ch.ExchangeDeclare(
                        client.Exchange.Name,
                        client.Exchange.Kind,
                        client.Exchange.Durable,
                        client.Exchange.AutoDelete,
                        client.Exchange.Internal,
                        client.Exchange.NoWait,
                        nil,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov4" title="8">if client.Queue != nil </span><span class="cov3" title="4">{
                args := amqp091.Table{}

                if client.Queue.Timeout != nil </span><span class="cov3" title="4">{
                        args[amqp091.ConsumerTimeoutArg] = client.Queue.Timeout.Milliseconds()
                }</span>

                <span class="cov3" title="4">_, err = ch.QueueDeclare(
                        client.Queue.Name,
                        client.Queue.Durable,    // Durable
                        client.Queue.AutoDelete, // Delete when unused
                        client.Queue.Exclusive,  // Exclusive
                        client.Queue.NoWait,     // No-wait
                        args,                    // Arguments
                )</span>
        }

        <span class="cov4" title="8">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="8">client.changeChannel(ch)
        client.M.Lock()
        client.isReady = true
        client.M.Unlock()
        client.Logger.Info("client init done")

        return nil</span>
}

// changeConnection takes a new connection to the queue,
// and updates the close listener to reflect this.
func (client *Client) changeConnection(connection *amqp091.Connection) <span class="cov4" title="8">{
        client.connection = connection
        client.notifyConnClose = make(chan *amqp091.Error, 1)
        client.connection.NotifyClose(client.notifyConnClose)
}</span>

// changeChannel takes a new channel to the queue,
// and updates the channel listeners to reflect this.
func (client *Client) changeChannel(channel *amqp091.Channel) <span class="cov4" title="8">{
        client.channel = channel
        client.notifyChanClose = make(chan *amqp091.Error, 1)
        client.notifyConfirm = make(chan amqp091.Confirmation, 1)
        client.channel.NotifyClose(client.notifyChanClose)
        client.channel.NotifyPublish(client.notifyConfirm)
}</span>

// Close will cleanly shut down the channel and connection.
func (client *Client) Close() error <span class="cov5" title="12">{
        client.M.Lock()
        // we read and write isReady in two locations, so we grab the lock and hold onto
        // it until we are finished
        defer client.M.Unlock()

        if !client.isReady </span><span class="cov3" title="4">{
                return entity.AlreadyClosedError
        }</span>
        <span class="cov4" title="8">close(client.done)
        err := client.channel.Close()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="8">err = client.connection.Close()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="8">client.isReady = false
        return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package amqp

import (
        "context"
        "github.com/rabbitmq/amqp091-go"
        "go.uber.org/zap"
        "tugas-akhir/backend/infrastructure/amqp/entity"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/pkg/logger"

        "sync"
)

type Consumer struct {
        Client
        consumeConfig entity.ConsumeConfig
}

func NewConsumer(
        config *config.Config,
        queue entity.QueueConfig,
        exchange *entity.ExchangeConfig,
        consumerConfig entity.ConsumeConfig,
) *Consumer <span class="cov7" title="4">{
        l := logger.GetInfo().With(zap.String("service", "amqp.consumer"))

        consumer := Consumer{
                consumeConfig: consumerConfig,
                Client: Client{
                        M:        &amp;sync.Mutex{},
                        Logger:   l,
                        Queue:    &amp;queue,
                        Exchange: exchange,
                        done:     make(chan bool),
                },
        }

        go consumer.handleReconnect(config.AmqpUrl)

        ConnectedConsumers = append(ConnectedConsumers, &amp;consumer)

        return &amp;consumer
}</span>

// Consume will continuously put queue items on the channel.
// It is required to call delivery.Ack when it has been
// successfully processed, or delivery.Nack when it fails.
// Ignoring this will cause data to build up on the server.
// NOTE
// BE CAREFUL WHEN USING CONSUME AS IT DOES NOT HANDLE CHANNEL RECONNECTION
// IF THE CHANNEL THAT ARE USED TO CONSUME THE MESSAGE ARE CLOSED, A NEW CHANNEL WILL BE CREATED
// AND YOU HAVE TO MANUALLY RE-CONSUME THE CHANNEL
func (client *Consumer) Consume(ctx context.Context) (&lt;-chan amqp091.Delivery, error) <span class="cov10" title="6">{
        //client.M.Lock()
        //if !client.isReady {
        //        client.M.Unlock()
        //        return nil, entity.NotConnectedError
        //}
        //client.M.Unlock()
        client.WaitUntilReady(ctx)

        if err := client.channel.Qos(
                client.consumeConfig.PrefetchCount, // prefetchCount
                client.consumeConfig.PrefetchSize,  // prefetchSize
                false,                              // global
        ); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="4">exchangeName := ""

        if client.Exchange != nil </span><span class="cov7" title="4">{
                exchangeName = client.Exchange.Name
        }</span>

        <span class="cov7" title="4">if len(client.consumeConfig.RoutingKeys) == 0 </span><span class="cov0" title="0">{
                err := client.channel.QueueBind(
                        client.Queue.Name,
                        "",
                        exchangeName,
                        client.Queue.NoWait,
                        nil,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov7" title="4"> {
                for _, route := range client.consumeConfig.RoutingKeys </span><span class="cov7" title="4">{
                        err := client.channel.QueueBind(
                                client.Queue.Name,
                                route,
                                exchangeName,
                                client.Queue.NoWait,
                                nil,
                        )

                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        }

        <span class="cov7" title="4">return client.channel.Consume(
                client.Queue.Name,
                "",                           // Consumer
                client.consumeConfig.AutoAck, // Auto-Ack
                client.Queue.Exclusive,       // Exclusive
                false,                        // No-local
                client.Queue.NoWait,          // No-Wait
                nil,                          // Args
        )</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package amqp

import (
        "context"
        "github.com/rabbitmq/amqp091-go"
        "go.uber.org/zap"
        "strconv"
        "sync"
        "time"
        "tugas-akhir/backend/infrastructure/amqp/entity"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/pkg/logger"
)

type Publisher struct {
        Client
}

func NewPublisher(
        config *config.Config,
        exchange *entity.ExchangeConfig,
) *Publisher <span class="cov7" title="4">{
        l := logger.GetInfo().With(zap.String("service", "amqp.publisher"))

        publisher := Publisher{
                Client: Client{
                        M:        &amp;sync.Mutex{},
                        Logger:   l,
                        Exchange: exchange,
                        done:     make(chan bool),
                },
        }

        go publisher.handleReconnect(config.AmqpUrl)

        ConnectedPublishers = append(ConnectedPublishers, &amp;publisher)

        return &amp;publisher
}</span>

// Push will push data onto the queue, and wait for a confirmation.
// This will block until the server sends a confirmation. Errors are
// only returned if the push action itself fails, see UnsafePush.
func (client *Publisher) Push(message entity.Message) error <span class="cov10" title="6">{
        client.M.Lock()
        if !client.isReady </span><span class="cov0" title="0">{
                client.M.Unlock()
                return entity.PushFailedNotConnectedError
        }</span>
        <span class="cov10" title="6">client.M.Unlock()
        for </span><span class="cov10" title="6">{
                err := client.UnsafePush(message)
                if err != nil </span><span class="cov0" title="0">{
                        client.Logger.Error("push failed. Retrying...")
                        select </span>{
                        case &lt;-client.done:<span class="cov0" title="0">
                                return entity.ShutdownError</span>
                        case &lt;-time.After(entity.ResendDelay):<span class="cov0" title="0"></span>
                        }
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov10" title="6">confirm := &lt;-client.notifyConfirm
                if confirm.Ack </span><span class="cov10" title="6">{
                        if message.LogDelivery </span><span class="cov0" title="0">{
                                client.Logger.Sugar().Infof("push confirmed [%d]", confirm.DeliveryTag)
                        }</span>
                        <span class="cov10" title="6">return nil</span>
                }
        }
}

// UnsafePush will push to the queue without checking for
// confirmation. It returns an error if it fails to connect.
// No guarantees are provided for whether the server will
// receive the message.
func (client *Publisher) UnsafePush(message entity.Message) error <span class="cov10" title="6">{
        client.M.Lock()
        if !client.isReady </span><span class="cov0" title="0">{
                client.M.Unlock()
                return entity.NotConnectedError
        }</span>
        <span class="cov10" title="6">client.M.Unlock()

        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        exchangeName := ""

        if client.Exchange != nil </span><span class="cov10" title="6">{
                exchangeName = client.Exchange.Name
        }</span>

        <span class="cov10" title="6">payload := amqp091.Publishing{
                ContentType: message.ContentType,
                Body:        message.Data,
                Timestamp:   time.Now(),
        }

        if message.Type != nil </span><span class="cov0" title="0">{
                payload.Type = *message.Type
        }</span>

        <span class="cov10" title="6">if message.TTL != nil </span><span class="cov0" title="0">{
                payload.Expiration = strconv.FormatInt(message.TTL.Milliseconds(), 10)
        }</span>

        <span class="cov10" title="6">if message.IsPersistent </span><span class="cov10" title="6">{
                payload.DeliveryMode = 2
        }</span>

        <span class="cov10" title="6">if message.Priority != nil </span><span class="cov0" title="0">{
                payload.Priority = *message.Priority
        }</span>

        <span class="cov10" title="6">return client.channel.PublishWithContext(
                ctx,
                exchangeName,       // Exchange
                message.RoutingKey, // Routing key
                false,              // Mandatory
                false,              // Immediate
                payload,
        )</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package config

import (
        _ "github.com/joho/godotenv/autoload"
        "github.com/kelseyhightower/envconfig"
        "github.com/pkg/errors"
        "go.uber.org/fx"
)

type Config struct {
        Environment    string `envconfig:"ENVIRONMENT" required:"true" default:"development"`
        ServerPort     int    `envconfig:"SERVER_PORT" default:"3000"`
        PrometheusPort int    `envconfig:"PROMETHEUS_PORT" default:"3001"`
        TlsCertPath    string `envconfig:"TLS_CERT_PATH" required:"true"`
        TlsKeyPath     string `envconfig:"TLS_KEY_PATH" required:"true"`
        JwtSecret      string `envconfig:"JWT_SECRET" required:"true"`

        TestScenario string    `envconfig:"TEST_SCENARIO"`
        PodName      string    `envconfig:"POD_NAME" default:"none"`
        DBVariant    DBVariant `envconfig:"DB_VARIANT" required:"true"`

        EnableProfiling bool `envconfig:"ENABLE_PROFILING" default:"false"`
        EnableDBTracing bool `envconfig:"ENABLE_DB_TRACING" default:"false"`
        LogPoolStat     bool `envconfig:"LOG_POOL_STAT" default:"false"`

        FlowControlVariant FlowControlVariant
        SeedDropper        string `envconfig:"SEED_DROPPER" default:"no"`

        DatabaseUrl       string `envconfig:"DATABASE_URL"`
        AmqpUrl           string `envconfig:"AMQP_URL"`
        PaymentServiceUrl string `envconfig:"PAYMENT_SERVICE_URL" required:"true"`
        PaymentCertPath   string `envconfig:"PAYMENT_CERT_PATH" required:"true"`
        WebhookSecret     string `envconfig:"WEBHOOK_SECRET" required:"true"`

        WorkerMetricsPort int `envconfig:"WORKER_METRICS_PORT" default:"3000"`

        RedisHosts    string `envconfig:"REDIS_HOSTS"`
        RedisHostsMap string `envconfig:"REDIS_HOSTS_MAP"`
        RedisPassword string `envconfig:"REDIS_PASSWORD"`
}

func NewConfig() (*Config, error) <span class="cov0" title="0">{
        var config Config

        if err := envconfig.Process("", &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Missing env variable")
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

var Module = fx.Options(fx.Provide(NewConfig))
</pre>
		
		<pre class="file" id="file29" style="display: none">package memcache

import (
        gocache "github.com/patrickmn/go-cache"
        "go.uber.org/fx"
        "time"
)

type Memcache struct {
        Cache *gocache.Cache
}

func NewMemcache() (*Memcache, error) <span class="cov10" title="6">{
        cache := gocache.New(15*time.Minute, 10*time.Minute)

        return &amp;Memcache{
                Cache: cache,
        }, nil
}

var Module = fx.Options(fx.Provide(NewMemcache))
</pre>
		
		<pre class="file" id="file30" style="display: none">package postgres

import (
        "context"
        "fmt"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/jackc/pgx/v5/tracelog"
        "go.uber.org/fx"
        "time"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/pkg/logger"
)

type Postgres struct {
        Pool *pgxpool.Pool
}

type QueryExecutor interface {
        Query(ctx context.Context, query string, args ...interface{}) (pgx.Rows, error)
        QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
        Exec(ctx context.Context, sql string, arguments ...any) (pgconn.CommandTag, error)
}

const PostgresTransactionContextKey = "postgres_tx"

func (p *Postgres) GetExecutor(ctx context.Context) QueryExecutor <span class="cov10" title="74">{
        tx, ok := ctx.Value(PostgresTransactionContextKey).(pgx.Tx)

        if !ok </span><span class="cov8" title="38">{
                return p.Pool
        }</span>

        <span class="cov8" title="36">return tx</span>
}

// NewPostgres
// Example database url
// postgresql://username:password@leader.example.com:5432,follower1.example.com:5432,follower2.example.com:5432/dbname?target_session_attrs=primary
func NewPostgres(config *config.Config) (*Postgres, error) <span class="cov6" title="11">{
        c, err := pgxpool.ParseConfig(config.DatabaseUrl)
        c.ConnConfig.DefaultQueryExecMode = pgx.QueryExecModeExec

        l := logger.GetDebug()

        if config.EnableDBTracing </span><span class="cov0" title="0">{

                tlogger := NewZapTracer(l)

                tracer := tracelog.TraceLog{
                        Logger:   tlogger,
                        LogLevel: tracelog.LogLevelTrace,
                }

                c.ConnConfig.Tracer = &amp;tracer

                l.Info("Database tracing enabled")
        }</span>

        <span class="cov6" title="11">pool, err := pgxpool.NewWithConfig(context.Background(), c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="11">if config.LogPoolStat </span><span class="cov0" title="0">{
                l.Info("Log pool stat")

                go func(p *pgxpool.Pool) </span><span class="cov0" title="0">{
                        ticker := time.NewTicker(10 * time.Second)
                        defer ticker.Stop()

                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-ticker.C:<span class="cov0" title="0">
                                        currentStats := p.Stat()
                                        fmt.Printf("\n--- Pool Stats")
                                        fmt.Printf("  AcquireCount: %d\n", currentStats.AcquireCount())
                                        fmt.Printf("  AcquireDuration: %s\n", currentStats.AcquireDuration())
                                        fmt.Printf("  AcquiredConns: %d\n", currentStats.AcquiredConns())
                                        fmt.Printf("  CanceledAcquireCount: %d\n", currentStats.CanceledAcquireCount())
                                        fmt.Printf("  ConstructingConns: %d\n", currentStats.ConstructingConns())
                                        fmt.Printf("  EmptyAcquireCount: %d\n", currentStats.EmptyAcquireCount())
                                        fmt.Printf("  IdleConns: %d\n", currentStats.IdleConns())
                                        fmt.Printf("  MaxConns: %d\n", currentStats.MaxConns())
                                        fmt.Printf("  TotalConns: %d\n", currentStats.TotalConns())
                                        fmt.Printf("  NewConnsCount: %d\n", currentStats.NewConnsCount())
                                        fmt.Printf("  MaxLifetimeDestroyCount: %d\n", currentStats.MaxLifetimeDestroyCount())
                                        fmt.Printf("  MaxIdleDestroyCount: %d\n", currentStats.MaxIdleDestroyCount())
                                        fmt.Println("-----------------------------------")</span>
                                }
                        }
                }(pool)
        }

        <span class="cov6" title="11">return &amp;Postgres{
                Pool: pool,
        }, nil</span>
}

var Module = fx.Options(fx.Provide(NewPostgres))
</pre>
		
		<pre class="file" id="file31" style="display: none">package postgres

import (
        "context"
        "github.com/jackc/pgx/v5/tracelog"
        "go.uber.org/zap"
)

type ZapTracer struct {
        logger *zap.Logger
}

func NewZapTracer(logger *zap.Logger) *ZapTracer <span class="cov0" title="0">{
        return &amp;ZapTracer{logger: logger}
}</span>

func (z *ZapTracer) Log(ctx context.Context, level tracelog.LogLevel, msg string, data map[string]any) <span class="cov0" title="0">{
        fields := make([]zap.Field, 0, len(data))
        for k, v := range data </span><span class="cov0" title="0">{
                fields = append(fields, zap.Any(k, v))
        }</span>

        <span class="cov0" title="0">switch level </span>{
        case tracelog.LogLevelDebug:<span class="cov0" title="0">
                z.logger.Debug(msg, fields...)</span>
        case tracelog.LogLevelInfo:<span class="cov0" title="0">
                z.logger.Info(msg, fields...)</span>
        case tracelog.LogLevelWarn:<span class="cov0" title="0">
                z.logger.Warn(msg, fields...)</span>
        case tracelog.LogLevelError:<span class="cov0" title="0">
                z.logger.Error(msg, fields...)</span>
        default:<span class="cov0" title="0">
                z.logger.Info(msg, fields...)</span> // fallback to Info
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package redis

import (
        "context"
        "errors"
        "net"
        "strings"
        "time"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/pkg/logger"

        errors2 "github.com/pkg/errors"
        baseredis "github.com/redis/go-redis/v9"
        "go.uber.org/fx"
        "go.uber.org/zap"
)

var RedisUnhealthy = errors.New("redis cluster unhealthy")

type Redis struct {
        Client *baseredis.ClusterClient
}

func NewRedis(config *config.Config) (*Redis, error) {
        hosts := strings.Split(config.RedisHosts, ",")

        opts := baseredis.ClusterOptions{
                Addrs:        hosts,
                PoolSize:     500,
                MinIdleConns: 20,
</span>
                </span>DialTimeout:  10 * time.Second,
                ReadTimeout:  5 * time.Second,
        <span class="cov6" title="14">        WriteTimeout: 5 * time.Second,
</span>                PoolTimeout:  6 * time.Second,
        }

        if config.RedisPassword != "" {
                opts.Password = config.RedisPass</span><span class="cov9" title="42">word
        }

</span>        if len(config.RedisHostsMap) != 0 {
                <span class="cov6" title="14">hostsMap := strings.Split(config.RedisHostsMap, ",")

                mapping := make(map[string]string)

                for i, mapped := range hostsMap {
                        mapping[mapped] = hosts[i]
                }
</span>
                baseDialer := &amp;net.Dialer{
</span>                        Timeout:   5 * time.Second,
                        KeepAlive: 5 * time.Minute,
                }
</span>
                // </span>Creat<span class="cov0" title="0">e the custom dialer function using the map from the cluster setup
                customDialer := func(ctx context.Context, network, addr string) (net.Conn, error) {

</span>                        if !strings.Contains(addr, "localhost") {
                                externalAddr, found := mapping[addr]

</span>                                if found {
                                        addr = externalAddr // Use the mapped external address
                <span class="cov6" title="14">                } else {
</span>                                        return nil, errors2.Errorf("go-redis Dialer: Dialing address '%s' directly (not found in internal map)", addr)
                                }
        <span class="cov6" title="14">                }

                        return baseDialer.DialContext(ctx, network, addr)
                }

</span>                opts.Dialer = customDialer
        }

        rdb := baseredis.NewClusterClient(&amp;opts)

        return &amp;Redis{
                Client: rdb,
        }, nil
}

func (r *Redis) GetOrSetWithEx(
</span>        ctx context.Context,
        key string,
        setValue string,
        expiration time.Duration,
</span>) (string, error) {

</span>        // Create a transaction pipeline
        txf := func(tx *baseredis.Tx) error {
                //</span> Get the current value
                _<span class="cov6" title="10">, err := tx.Ge</span><span class="cov0" title="0">t(ctx, key).Result()

                if</span> errors.Is(err, baseredis.Nil) {
                        <span class="cov6" title="10">// Key doe</span>sn't exist, set it with expiration
                        _, er<span class="cov2" title="2">r = tx.TxPipeli</span><span class="cov0" title="0">ned(ctx, func(pipe baseredis.Pipeliner) error {
                                pipe.Set(ctx, key, setValue, expiration)
                                return nil
                        </span>})
                        if err != nil {
                                return err
                <span class="cov2" title="2">        }
</span>                        return nil
                } else if err != nil {
                        // Some other error occurred
                        return err
        <span class="cov6" title="12">        }
</span>
                // Key exists,</span><span class="cov6" title="12"> nothing to do in the transaction
                return</span> nil
        }

</span>        // Execute the transaction with optimistic locking
        // Retry u</span>p to 10 times if there's a race condition
        for i := 0; i &lt; 10; i++ {
                <span class="cov0" title="0">err := r.Clien</span>t.Watch(ctx, txf, key)
                if err == nil {
                        break
                }
        <span class="cov6" title="12">        if errors.Is(err, baseredis.TxFailedErr) {
                        // Optimisti</span><span class="cov0" title="0">c lock lost, retry
                        continue
                </span>}
                return "", err
        <span class="cov6" title="12">}
</span>
        // Read the final value after transaction
        val, err := r.Client.Get(ctx, key).Result()
        if err != nil {
                return "", err
        }

        return val, nil

}

</span>func (r *Redis) IsHealthy(baseCtx context.Context) error {
        l</span> := logger.FromCtx(baseCtx).With(zap.String("service", "redis-health-check"))

        <span class="cov6" title="14">ctx, cancel := context.WithTimeout(baseCtx, 5*time.Second)
        defer cancel()

</span>        _, err := r.Client.Ping(ctx).Result()
        i</span>f err != nil {
                return err
        <span class="cov6" title="14">}
</span>
        clusterInfo, err := r.Client.ClusterInfo(ctx).Result()

</span>        if err != nil {
        <span class="cov6" title="14">        return err
        }
</span>
        i</span>f !strings.Contains(clusterInfo, "cluster_state:ok") {
                l.Warn(clusterInfo)
        <span class="cov6" title="14">        return errors2.WithMessage(RedisUnhealthy, "cluster state is not ok")
        }
</span>
        clusterNodes, err := r.Client.ClusterNodes(ctx).Result()
        if err != nil {</span><span class="cov6" title="14">
                return er</span>r
        }

        l<span class="cov9" title="42">ines := strings.Split(clusterNodes, "\n")
        for _, line := range lines {
                line = strings.Tri</span><span class="cov0" title="0">mSpace(line)

</span>                if line == "" {
                        continue
                <span class="cov9" title="42">}

                parts := strings.Fields(line)

                if len(parts) &lt; 3 {
                        continue
                }
</span>
</span>                flags := strings.Split(parts[2], ",")

</span>                /<span class="cov10" title="56">/ Check if node is a master (should b</span><span class="cov0" title="0">e master since we only have masters)
                isMaster := false
                is</span>Failing := false

                for _, flag := range flags {
                        if flag == "master" {
                <span class="cov9" title="42">                isMaster = true
</span>                        }
                        if flag == "fail" || flag == "fail?" {
                        </span>        isFailing = true
                        }
                }

</span>                // If node is failing or not a master, the cluster is unhealthy
                if isFailing || !isMaster {
                        l.Warn(clusterNodes)
                        return errors2.WithMessage(RedisUnhealthy, "master node is failing")
        </span>        }
        }

        return nil
}

fun</span>c (r *Redis) Stop() error {
        return r.Client.Close()
}

var Module = fx.Options(
        fx.Provide(fx.Annotate(NewRedis,
                fx.OnStop(func(r *Redis) error {
                        return r.Stop()
                }),
        )),
)
</pre>
		
		<pre class="file" id="file33" style="display: none">package booked_seats

import (
        "context"
        "fmt"
        "github.com/georgysavva/scany/v2/pgxscan"
        errors2 "github.com/pkg/errors"
        "tugas-akhir/backend/infrastructure/postgres"
        "tugas-akhir/backend/internal/bookings/entity"
        "tugas-akhir/backend/internal/bookings/service"
        entity2 "tugas-akhir/backend/internal/events/entity"
        "tugas-akhir/backend/pkg/cursor_iterator"
)

type PGBookedSeatRepository struct {
        db        *postgres.Postgres
        generator *service.SerialNumberGenerator
}

func NewPGBookedSeatRepository(
        db *postgres.Postgres,
        generator *service.SerialNumberGenerator,
) *PGBookedSeatRepository <span class="cov10" title="6">{
        return &amp;PGBookedSeatRepository{
                db:        db,
                generator: generator,
        }
}</span>

func (r *PGBookedSeatRepository) PublishIssuedTickets(ctx context.Context, payload entity.PublishIssuedTicketDto) error <span class="cov1" title="1">{
        query := `
        INSERT INTO issued_tickets(serial_number, holder_name, ticket_seat_id, order_id, order_item_id, name, description, ticket_area_id) VALUES
    `

        if len(payload.Items) != len(payload.SeatInfos) </span><span class="cov0" title="0">{
                return errors2.WithMessage(entity.IssueTicketError, "payload items and seat info length is different")
        }</span>

        <span class="cov1" title="1">args := []interface{}{}

        for i, item := range payload.Items </span><span class="cov4" title="2">{
                if i &gt; 0 </span><span class="cov1" title="1">{
                        query += ", "
                }</span>

                <span class="cov4" title="2">info := payload.SeatInfos[i]

                serialNumber, err := r.generator.Generate(item)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov4" title="2">issuedTicketDescription := ""

                if info.SeatType == entity2.AreaType__FreeStanding </span><span class="cov0" title="0">{
                        issuedTicketDescription = fmt.Sprintf("%s (Free Standing)", info.CategoryName)
                }</span> else<span class="cov4" title="2"> if info.SeatType == entity2.AreaType__NumberedSeating </span><span class="cov4" title="2">{
                        issuedTicketDescription = fmt.Sprintf("%s - Number %s", info.CategoryName, info.SeatNumber)
                }</span>

                <span class="cov4" title="2">paramOffset := i * 8
                query += fmt.Sprintf(
                        "($%d, $%d, $%d, $%d, $%d, $%d, $%d, $%d)",
                        paramOffset+1,
                        paramOffset+2,
                        paramOffset+3,
                        paramOffset+4,
                        paramOffset+5,
                        paramOffset+6,
                        paramOffset+7,
                        paramOffset+8,
                )

                args = append(args,
                        serialNumber,
                        item.CustomerName,
                        item.TicketSeatID,
                        item.OrderID,
                        item.ID,
                        fmt.Sprintf("%s - %s", payload.EventName, payload.TicketSaleName),
                        issuedTicketDescription,
                        payload.TicketAreaID,
                )</span>
        }

        <span class="cov1" title="1">_, err := r.db.GetExecutor(ctx).Exec(ctx, query, args...)

        return err</span>
}

func (r *PGBookedSeatRepository) GetIssuedTickets(ctx context.Context, payload entity.GetIssuedTicketDto) ([]entity.IssuedTicket, error) <span class="cov4" title="2">{
        var count int

        countQuery := `
        SELECT COUNT(*) 
        FROM orders 
        WHERE id = $1 AND ticket_area_id = $3 AND external_user_id = $2
    `

        err := r.db.GetExecutor(ctx).QueryRow(ctx, countQuery, payload.OrderID, payload.UserID, payload.TicketAreaID).Scan(&amp;count)

        if err != nil </span><span class="cov0" title="0">{
                return nil, errors2.WithStack(errors2.WithMessage(entity.IssuedTicketFetchError, "cannot get the order count"))
        }</span>

        <span class="cov4" title="2">if count == 0 </span><span class="cov1" title="1">{
                return nil, entity.IssuedTicketNotFoundError
        }</span>

        <span class="cov1" title="1">query := `
                SELECT 
                        it.id, 
                        it.serial_number, 
                        it.holder_name, 
                        it.name, 
                        it.description, 
                        it.ticket_seat_id, 
                        it.order_id, 
                        it.order_item_id, 
                        it.created_at, 
                        it.updated_at,
                        ts.id AS "ticket_seat.id",
                        ts.seat_number AS "ticket_seat.seat_number",
                        ts.status AS "ticket_seat.status",
                        ts.ticket_area_id AS "ticket_seat.ticket_area_id",
                        ts.created_at AS "ticket_seat.created_at",
                        ts.updated_at AS "ticket_seat.updated_at"
                FROM issued_tickets it
                JOIN ticket_seats ts ON it.ticket_seat_id = ts.id AND it.ticket_area_id = ts.ticket_area_id
                WHERE it.order_id = $1 and it.ticket_area_id = $2
    `

        result := make([]entity.IssuedTicket, 0)

        err = pgxscan.Select(ctx, r.db.GetExecutor(ctx), &amp;result, query, payload.OrderID, payload.TicketAreaID)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if len(result) == 0 </span><span class="cov0" title="0">{
                return nil, entity.IssuedTicketNotFoundError
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}

func (r *PGBookedSeatRepository) IterSeats(ctx context.Context) ([]entity2.TicketSeat, *cursor_iterator.CursorIterator, error) <span class="cov7" title="4">{
        query := `
        SELECT 
            ts.id, ts.seat_number, ts.status, ts.ticket_area_id, ts.created_at, ts.updated_at,
            ta.id AS "ticket_area.id", 
            ta.type AS "ticket_area.type", 
            ta.ticket_package_id AS "ticket_area.ticket_package_id", 
            ta.created_at AS "ticket_area.created_at", 
            ta.updated_at AS "ticket_area.updated_at"
        FROM 
            ticket_seats ts
        JOIN 
            ticket_areas ta ON ts.ticket_area_id = ta.id 
    `

        result := make([]entity2.TicketSeat, 100)

        iter, err := cursor_iterator.NewCursorIterator(r.db.Pool, result, query)

        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov7" title="4">return result, iter, err</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package booking

import (
        "context"
        "errors"
        "github.com/georgysavva/scany/v2/pgxscan"
        "github.com/jackc/pgx/v5/pgconn"
        errors2 "github.com/pkg/errors"
        "tugas-akhir/backend/infrastructure/postgres"
        "tugas-akhir/backend/internal/bookings/entity"
        entity2 "tugas-akhir/backend/internal/events/entity"
)

type PGBookingRepository struct {
        db *postgres.Postgres
}

func NewPGBookingRepository(db *postgres.Postgres) *PGBookingRepository <span class="cov6" title="5">{
        return &amp;PGBookingRepository{
                db: db,
        }
}</span>

func (r *PGBookingRepository) Book(ctx context.Context, payload entity.BookingRequestDto) ([]entity2.TicketSeat, error) <span class="cov10" title="12">{
        finalSeats := make([]entity2.TicketSeat, 0)
        combinedIDs := make([]int64, 0)

        if len(payload.SeatIDs)+len(payload.TicketAreaIDs) == 0 </span><span class="cov0" title="0">{
                return nil, errors2.WithStack(errors2.WithMessage(entity.InternalTicketLockError, "total seat in payload must not be zero"))
        }</span>

        <span class="cov10" title="12">if len(payload.SeatIDs) != 0 &amp;&amp; len(payload.TicketAreaIDs) != 0 </span><span class="cov0" title="0">{
                return nil, errors2.WithStack(errors2.WithMessage(entity.InternalTicketLockError, "only either ticket seat or ticket area are allowed at the same time"))
        }</span>

        <span class="cov10" title="12">if len(payload.SeatIDs) &gt; 0 </span><span class="cov8" title="8">{
                numberedQuery := `
        SELECT id, seat_number, status, ticket_area_id, created_at, updated_at
        FROM ticket_seats
        WHERE ticket_area_id = $1 and id = ANY($2) and status = 'available'
        FOR UPDATE NOWAIT
    `

                numberedSeats := make([]entity2.TicketSeat, 0)

                err := pgxscan.Select(ctx, r.db.GetExecutor(ctx), &amp;numberedSeats, numberedQuery, payload.TicketAreaID, payload.SeatIDs)

                if err != nil </span><span class="cov1" title="1">{
                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) </span><span class="cov1" title="1">{
                                // PostgreSQL error codes for lock-related issues
                                // 55P03 is the error code for "no wait" lock failure
                                if pgErr.Code == "55P03" </span><span class="cov1" title="1">{
                                        return nil, entity.LockNotAcquiredError
                                }</span>
                        }
                        <span class="cov0" title="0">return nil, err</span>
                }

                <span class="cov8" title="7">if len(numberedSeats) != len(payload.SeatIDs) </span><span class="cov1" title="1">{
                        return nil, errors2.WithStack(errors2.WithMessage(entity.LockNotAcquiredError, "the result data length does not match with the param length"))
                }</span>

                <span class="cov7" title="6">finalSeats = append(finalSeats, numberedSeats...)
                combinedIDs = append(combinedIDs, payload.SeatIDs...)</span>
        }

        <span class="cov9" title="10">if len(payload.TicketAreaIDs) &gt; 0 </span><span class="cov6" title="4">{
                freeSeatedQuery := `
        SELECT id, seat_number, status, ticket_area_id, created_at, updated_at
        FROM ticket_seats
        WHERE ticket_area_id = $1 and status = 'available'
        LIMIT $2
        FOR UPDATE SKIP LOCKED
    `

                areaCountMap := make(map[int64]int)

                for _, area := range payload.TicketAreaIDs </span><span class="cov9" title="10">{
                        _, ok := areaCountMap[area]

                        if ok </span><span class="cov7" title="6">{
                                areaCountMap[area]++
                        }</span> else<span class="cov6" title="4"> {
                                areaCountMap[area] = 1
                        }</span>
                }

                <span class="cov6" title="4">for key, val := range areaCountMap </span><span class="cov6" title="4">{
                        freeSeatedSeats := make([]entity2.TicketSeat, 0)

                        err := pgxscan.Select(ctx, r.db.GetExecutor(ctx), &amp;freeSeatedSeats, freeSeatedQuery, key, val)

                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov6" title="4">if len(freeSeatedSeats) != val </span><span class="cov1" title="1">{
                                return nil, errors2.WithStack(errors2.WithMessage(entity.LockNotAcquiredError, "cannot acquire locks for the given seats"))
                        }</span>

                        <span class="cov4" title="3">finalSeats = append(finalSeats, freeSeatedSeats...)

                        for _, seat := range freeSeatedSeats </span><span class="cov7" title="6">{
                                combinedIDs = append(combinedIDs, seat.ID)
                        }</span>
                }
        }

        // update status to on hold
        <span class="cov8" title="9">updateQuery := `
        UPDATE ticket_seats
        SET status = 'on-hold'
        WHERE ticket_area_id = $1 and id = ANY($2) and status = 'available'
    `

        tag, err := r.db.GetExecutor(ctx).Exec(ctx, updateQuery, payload.TicketAreaID, combinedIDs)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="9">if tag.RowsAffected() != int64(len(combinedIDs)) </span><span class="cov0" title="0">{
                return nil, errors2.WithStack(errors2.WithMessage(entity.LockNotAcquiredError, "the updated data length does not match with the param length"))
        }</span>

        <span class="cov8" title="9">return finalSeats, nil</span>
}

func (r *PGBookingRepository) UpdateSeatStatus(ctx context.Context, payload entity.UpdateSeatStatusDto) error <span class="cov0" title="0">{
        query := `
        UPDATE ticket_seats
        SET status = $1, updated_at = now()
        WHERE id = ANY($2) and ticket_area_id = $3
    `

        _, err := r.db.GetExecutor(ctx).Exec(ctx, query, payload.Status, payload.SeatIDs, payload.TicketAreaID)

        return err
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package service

import (
        "crypto/rand"
        "encoding/base64"
        "fmt"
        "github.com/pkg/errors"
        "io"
        "strings"
        "tugas-akhir/backend/internal/orders/entity"
)

// SerialNumberGenerator handles generating unique serial numbers
type SerialNumberGenerator struct {
        randomReader io.Reader
}

// NewSerialNumberGenerator creates a new generator with defaults
func NewSerialNumberGenerator() *SerialNumberGenerator <span class="cov10" title="9">{
        return &amp;SerialNumberGenerator{
                randomReader: rand.Reader,
        }
}</span>

// Generate creates a serial number based on order item details
func (g *SerialNumberGenerator) Generate(item entity.OrderItem) (string, error) <span class="cov7" title="5">{
        // Generate random component (3 bytes = 4 chars in base64)
        randomBytes := make([]byte, 3)
        _, err := g.randomReader.Read(randomBytes)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.WithMessage(err, "failed to generate random bytes")
        }</span>

        // Convert to base64 and clean up the string
        <span class="cov7" title="5">randomStr := base64.StdEncoding.EncodeToString(randomBytes)
        randomStr = strings.ReplaceAll(randomStr, "/", "X")
        randomStr = strings.ReplaceAll(randomStr, "+", "Y")
        randomStr = strings.TrimRight(randomStr, "=")

        // Combine all components into final serial number
        serialNumber := fmt.Sprintf("TIX-%03d%03d-%s", item.OrderID%1000, item.TicketSeatID%1000, randomStr[:4])

        return serialNumber, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package entity

import "errors"

type AreaType string

const (
        AreaType__NumberedSeating AreaType = "numbered-seating"
        AreaType__FreeStanding    AreaType = "free-standing"
)

func (e *AreaType) Scan(value interface{}) error <span class="cov9" title="16000">{
        var enumValue string
        switch val := value.(type) </span>{
        case string:<span class="cov9" title="16000">
                enumValue = val</span>
        case []byte:<span class="cov0" title="0">
                enumValue = string(val)</span>
        default:<span class="cov0" title="0">
                return errors.New("invalid scan value for AreaType enum. Enum value has to be of type string or []byte")</span>
        }

        <span class="cov9" title="16000">switch enumValue </span>{
        case "numbered-seating":<span class="cov8" title="2100">
                *e = AreaType__NumberedSeating</span>
        case "free-standing":<span class="cov9" title="13900">
                *e = AreaType__FreeStanding</span>
        default:<span class="cov0" title="0">
                return errors.New("invalid scan value '" + enumValue + "' for AreaType enum")</span>
        }

        <span class="cov9" title="16000">return nil</span>
}

func (e *AreaType) Value() string <span class="cov0" title="0">{
        return string(*e)
}</span>

func (e *AreaType) String() string <span class="cov0" title="0">{
        return string(*e)
}</span>

type SeatStatus string

const (
        SeatStatus__Available SeatStatus = "available"
        SeatStatus__OnHold    SeatStatus = "on-hold"
        SeatStatus__Sold      SeatStatus = "sold"
)

func (e *SeatStatus) Scan(value interface{}) error <span class="cov10" title="17120">{
        var enumValue string
        switch val := value.(type) </span>{
        case string:<span class="cov10" title="17120">
                enumValue = val</span>
        case []byte:<span class="cov0" title="0">
                enumValue = string(val)</span>
        default:<span class="cov0" title="0">
                return errors.New("invalid scan value for SeatStatus enum. Enum value has to be of type string or []byte")</span>
        }

        <span class="cov10" title="17120">switch enumValue </span>{
        case "available":<span class="cov9" title="17118">
                *e = SeatStatus__Available</span>
        case "on-hold":<span class="cov0" title="0">
                *e = SeatStatus__OnHold</span>
        case "sold":<span class="cov1" title="2">
                *e = SeatStatus__Sold</span>
        default:<span class="cov0" title="0">
                return errors.New("invalid scan value '" + enumValue + "' for SeatStatus enum")</span>
        }

        <span class="cov10" title="17120">return nil</span>
}

func (e *SeatStatus) Value() string <span class="cov0" title="0">{
        return string(*e)
}</span>

func (e *SeatStatus) String() string <span class="cov0" title="0">{
        return string(*e)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package events

import (
        "context"
        "go.uber.org/fx"
        "tugas-akhir/backend/internal/events/repository/availability"
        "tugas-akhir/backend/internal/events/repository/event"
        "tugas-akhir/backend/internal/events/repository/seat"
        "tugas-akhir/backend/internal/events/service/redis_availability_seeder"
        "tugas-akhir/backend/internal/events/usecase"
)

var BaseModule = fx.Options(
        fx.Provide(fx.Annotate(availability.NewRedisAvailabilityRepository, fx.As(new(availability.AvailabilityRepository)))),
        fx.Provide(fx.Annotate(redis_availability_seeder.NewRedisAvailabilitySeeder,
                fx.OnStart(func(seeder *redis_availability_seeder.RedisAvailabilitySeeder, ctx context.Context) error <span class="cov0" title="0">{
                        return seeder.Run(ctx)
                }</span>),
                fx.OnStop(func(seeder *redis_availability_seeder.RedisAvailabilitySeeder) error <span class="cov0" title="0">{
                        return seeder.Stop()
                }</span>),
        )),
        fx.Provide(fx.Annotate(event.NewPGEventRepository, fx.As(new(event.EventRepository)))),
        fx.Provide(fx.Annotate(seat.NewPGSeatRepository, fx.As(new(seat.SeatRepository)))),
        fx.Provide(usecase.NewEventAvailabilityUsecase),
)
</pre>
		
		<pre class="file" id="file38" style="display: none">package availability

import (
        "context"
        "github.com/georgysavva/scany/v2/pgxscan"
        "tugas-akhir/backend/infrastructure/postgres"
        "tugas-akhir/backend/internal/events/entity"
)

type PGAvailabilityRepository struct {
        pg *postgres.Postgres
}

func NewPGAvailabilityRepository(pg *postgres.Postgres) *PGAvailabilityRepository <span class="cov0" title="0">{
        return &amp;PGAvailabilityRepository{
                pg: pg,
        }
}</span>

func (r *PGAvailabilityRepository) GetAvailability(ctx context.Context, payload entity.GetAvailabilityDto) ([]entity.AreaAvailability, error) <span class="cov0" title="0">{
        query := `
        SELECT 
                tp.id AS ticket_package_id,
                ta.id AS ticket_area_id,
                COUNT(ts.id) AS total_seats,
                COUNT(CASE WHEN ts.status = 'available' THEN 1 END) AS available_seats
        FROM 
                ticket_packages tp
        INNER JOIN 
                ticket_areas ta ON ta.ticket_package_id = tp.id
        INNER JOIN 
                ticket_seats ts ON ts.ticket_area_id = ta.id
        WHERE 
                tp.ticket_sale_id = $1
        GROUP BY 
                tp.id, ta.id
    `

        result := make([]entity.AreaAvailability, 0)

        err := pgxscan.Select(
                ctx,
                r.pg.GetExecutor(ctx),
                &amp;result,
                query,
                payload.TicketSaleID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // we expect we found data
        <span class="cov0" title="0">if len(result) == 0 </span><span class="cov0" title="0">{
                return nil, entity.AreaAvailabilityNotFoundError
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package availability

import (
        "context"
        "errors"
        "fmt"
        baseredis "github.com/redis/go-redis/v9"
        "strconv"
        "strings"
        "tugas-akhir/backend/infrastructure/redis"
        "tugas-akhir/backend/internal/events/entity"
        "tugas-akhir/backend/pkg/logger"
)

const AvailabilityPrefix = "redis-availability"

func CacheKey(ticketSaleID int64) string {
        return fmt.Sprintf("%s:sale:%d", AvailabilityPrefix, ticketSaleID)
}

func GetTotalSeatsField(data entity.AreaAvailability) string {
        return fmt.Sprintf("%d:%d:total", da<span class="cov6" title="18">ta.TicketPackageID, data.TicketAreaID)
}

</span>func GetAvailableSeatsField(data entity.AreaAvailability) string {
        return fmt.Sprintf("%d:%d:available", data.TicketPackageID<span class="cov9" title="70">, data.TicketAreaID)
}

</span>type RedisAvailabilityRepository struct {
        redis *redis.Redis
}

</span>func NewRedisAvailabilityRepository(
        redis *redis.Redis,
) *RedisAvailabilityRepository {
        return &amp;RedisAvailabilityRepository{
                redis: redis,
        }
}

func (r *RedisAvailabilityRepository) GetAvailability(ctx context.Context, payload entity.GetAvailabilityDto) ([]entity.AreaAvailability, error) {
        l := logger.FromCtx(ctx)
        key := CacheKey(payload.TicketSaleID)

        // Fetch all fields and values from the hash in one operation.
        fields, err := r.redis.Client.HGetAll(ctx, key).Result()
        </span>if err != nil {
                // This handles cases where the command fails for reasons other than the key not existing.
                if errors.Is(err, baseredis.Nil) {
                        return nil, entity.AreaAvailabilityNotFoundError
                }
                l.Sugar().Errorf("failed to execute HGetAll for key %s: %v", key, err)
                return nil, err
        }

        if len(fields) == 0 {
</span>                return nil, entity.AreaAvailabilityNotFoundError
        }

        // Use a map to aggregate total and available seats for each unique area.
</span>        // The key is "packageID:areaID".
        areaMap := make(map[string]*entity.AreaAvailability)

</span>        for field, value := range fields {
                parts := strings.Split(field, ":")
                if len(parts) !=</span><span class="cov0" title="0"> 3 {
                        l.Sugar().Warnf("invalid field format in hash %s: %s", key, field)
                        co</span>ntinue
                }

                packageID, pErr := strconv.ParseInt(parts[0], 10, 64)
                areaID, aErr := strco</span><span class="cov6" title="21">nv.ParseInt(parts[1], 10, 64)
                fieldTyp</span>e := parts[2]

                if<span class="cov6" title="14"> pErr != nil || aEr</span>r != nil {
                        l.Sugar().Warnf("could not parse packageID or areaID from field: %s", field)
                        continue
                }<span class="cov6" title="21">

                areaIdentifier := fmt.Sprintf("%d:%d", packageID, areaID)

                // If we ha</span>ven't seen this area yet, create a new struct for it.
                if _, ok := areaMap[areaIdentifier]; !ok {
                        areaMap[areaIdentifier] = &amp;entity.AreaAvailability{
                <span class="cov4" title="7">                TicketSaleID</span><span class="cov0" title="0">:    payload.TicketSaleID,
                                TicketPackageID: packageID,
                        </span>        TicketAreaID:    areaID,
                        }
                <span class="cov4" title="7">}

                // Parse the s</span><span class="cov0" title="0">eat count value.
                seatCount, err := strconv.ParseInt(value, 10, 32)
                if err != nil {
                        </span>l.Sugar().Warnf("could not parse seat count '%s' for field: %s", value, field)
                        continue
                <span class="cov4" title="7">}
</span>
                // Assign the seat count to the correct field in the struct.
                s</span>witch fieldType {
                case "total":
                <span class="cov4" title="7">        areaMap[a</span>reaIdentifier].TotalSeats = int32(seatCount)
                case "available":
                        areaMap[areaIdentifier].AvailableSeats = int32(seatCount)
        <span class="cov5" title="11">        }
        }

        // Convert the map of pointers to a slice of structs.
        result := make([]en</span><span class="cov4" title="7">tity.AreaAvailability, 0, len(areaMap))
        for _, area := range areaMap {
</span>                result = append(result, *area)
        }
</span>
        re</span>turn result, nil
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package event

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "github.com/georgysavva/scany/v2/pgxscan"
        "github.com/jackc/pgx/v5"
        "go.uber.org/zap"
        "tugas-akhir/backend/infrastructure/memcache"
        "tugas-akhir/backend/infrastructure/postgres"
        "tugas-akhir/backend/internal/events/entity"
        "tugas-akhir/backend/pkg/logger"
)

type PGEventRepository struct {
        db    *postgres.Postgres
        cache *memcache.Memcache
}

func NewPGEventRepository(
        db *postgres.Postgres,
        cache *memcache.Memcache,
) *PGEventRepository {
        return &amp;PGEventRepos<span class="cov6" title="5">itory{
                db:    db,
                cache: cache,
        }
}

</span>const EventsCacheKey = "events"

func eventCacheKey(id int64) string {
        return fmt.Sprintf("%s:%d", "events<span class="cov10" title="18">:", id)
}

</span>func (r *PGEventRepository) GetEvents(ctx context.Context) ([]entity.Event, error) {
        result := make([]entity.Event, 0)

        // Attempt to get from go-cache
        cachedData, found := r.cache.Cache.Get(EventsCacheKey)

        if found {
</span>                rawBytes, ok := cachedData.([]byte) // bigcache Get</span><span class="cov0" title="0"> returns []byte, go-cache Get returns interface{}
                if !ok {
                        </span>logger.FromCtx(ctx).Error("Cached events data is not []byte", zap.String("key", EventsCacheKey))
                        // P<span class="cov1" title="1">roceed to DB fetch if type is wrong
                } else {
                        marshallErr := json.Unmarshal(rawBytes, &amp;result)
                        if marshallErr == nil</span><span class="cov1" title="1"> {
                                return result, nil // Cache hit and unmarshal success
                        </span>} els<span class="cov0" title="0">e {
                                logger.FromCtx(ctx).Error("Cannot unmarshal cached events", zap.Error(marshallErr), zap.String("key", EventsCacheKey))
                        </span>        // Proceed to DB fetch if unmarshal fails
                        }
                }
        <span class="cov6" title="5">} // If not found or any cache issue (type mismatch, unmarshal error), proceed to DB fetch

        query := `SELECT * FROM events`

        err := pgxscan.Select(
                ctx,
                r.db.GetExecutor(ctx),
                &amp;result,
                query,
        )
</span>
        i</span>f err != nil {
                return nil, err
        <span class="cov6" title="5">}

        raw, err := js</span><span class="cov0" title="0">on.Marshal(result)

        i</span>f err != nil {
                logger.FromCtx(ctx).Error("Cannot marshall events", zap.Error(err))
        <span class="cov6" title="5">}
</span>
        r</span>.cache.Cache.SetDefault(EventsCacheKey, raw)

        <span class="cov6" title="5">return result, nil</span>
}

func (r *PGEventRepository) GetEvent(ctx context.Context, payload entity.GetEventDto) (*entity.Event, error) <span class="cov8" title="13">{
        var event entity.Event

        cacheKey := eventCacheKey(payload.ID)
        // Attempt to get from go-cache
        cachedData, found :</span><span class="cov6" title="6">= r.cache.Cache.Get(cacheKey)

</span>        if found {
                r</span>awBytes, ok := cachedData.([]byte) // bigcache Get returns []byte, go-cache Get returns interface{}
                if !o<span class="cov7" title="7">k {
                        logger.FromCtx(ctx).Sugar().Error(fmt.Sprintf("Cached event %d data is not []byte", payload.ID), zap.String("key", cacheKey))
                        // Proceed to DB fetch if type is wrong
                } else {
</span>                        marshallErr := json.Unmarshal(rawBytes, &amp;event)
                        </span>if ma<span class="cov0" title="0">rshallErr == nil {
                                return &amp;event, nil // Cache hit and unmarshal success
                        </span>} else {
                                logger.FromCtx(ctx).Sugar().Error(fmt.Sprintf("Cannot unmarshal cached event %d", payload.ID), zap.Error(marshallErr), zap.String("key", cacheKey))
                                // Proceed to DB fetch if unmarshal fails
        <span class="cov6" title="6">                }
                }
        } // If not found or any cache issue, proceed to DB fetch

        query := `
        WITH event_data AS (
                SELECT
                        e.id, e.name, e.location, e.description, e.created_at, e.updated_at
                FROM events e
                WHERE e.id = $1
        ),
        ticket_sales_data AS (
                SELECT
                        ts.id, ts.name, ts.sale_begin_at, ts.sale_end_at, ts.event_id,
                        ts.created_at, ts.updated_at
                FROM ticket_sales ts
                WHERE ts.event_id = $1
        ),
        ticket_packages_data AS (
                SELECT
                        tp.id, tp.price, tp.ticket_category_id, tp.ticket_sale_id,
                        tp.created_at, tp.updated_at
                FROM ticket_packages tp
                JOIN ticket_sales ts ON tp.ticket_sale_id = ts.id
                WHERE ts.event_id = $1
        ),
        ticket_categories_data AS (
                SELECT
                        tc.id, tc.name, tc.event_id, tc.created_at, tc.updated_at
                FROM ticket_categories tc
                WHERE tc.event_id = $1
        ),
        ticket_areas_data AS (
                SELECT
                        ta.id, ta.type, ta.ticket_package_id, ta.created_at, ta.updated_at
                FROM ticket_areas ta
                JOIN ticket_packages tp ON ta.ticket_package_id = tp.id
                JOIN ticket_sales ts ON tp.ticket_sale_id = ts.id
                WHERE ts.event_id = $1
        )
        SELECT
                json_build_object(
                        'id', e.id,
                        'name', e.name,
                        'location', e.location,
                        'description', e.description,
                        'createdAt', e.created_at,
                        'updatedAt', e.updated_at,
                        'ticketSales', COALESCE(
                                (
                                        SELECT json_agg(
                                                json_build_object(
                                                        'id', ts.id,
                                                        'name', ts.name,
                                                        'saleBeginAt', ts.sale_begin_at,
                                                        'saleEndAt', ts.sale_end_at,
                                                        'eventId', ts.event_id,
                                                        'createdAt', ts.created_at,
                                                        'updatedAt', ts.updated_at,
                                                        'ticketPackages', COALESCE(
                                                                (
                                                                        SELECT json_agg(
                                                                                json_build_object(
                                                                                        'id', tp.id,
                                                                                        'price', tp.price,
                                                                                        'ticketCategoryId', tp.ticket_category_id,
                                                                                        'ticketSaleId', tp.ticket_sale_id,
                                                                                        'createdAt', tp.created_at,
                                                                                        'updatedAt', tp.updated_at,
                                                                                        'ticketCategory', (
                                                                                                SELECT json_build_object(
                                                                                                        'id', tc.id,
                                                                                                        'name', tc.name,
                                                                                                        'eventId', tc.event_id,
                                                                                                        'createdAt', tc.created_at,
                                                                                                        'updatedAt', tc.updated_at
                                                                                                )
                                                                                                FROM ticket_categories_data tc
                                                                                                WHERE tc.id = tp.ticket_category_id
                                                                                        ),
                                                                                        'ticketAreas', COALESCE(
                                                                                                (
                                                                                                        SELECT json_agg(
                                                                                                                json_build_object(
                                                                                                                        'id', ta.id,
                                                                                                                        'type', ta.type,
                                                                                                                        'ticketPackageId', ta.ticket_package_id,
                                                                                                                        'createdAt', ta.created_at,
                                                                                                                        'updatedAt', ta.updated_at
                                                                                                                )
                                                                                                        )
                                                                                                        FROM ticket_areas_data ta
                                                                                                        WHERE ta.ticket_package_id = tp.id
                                                                                                ),
                                                                                                '[]'::json
                                                                                        )
                                                                                )
                                                                        )
                                                                        FROM ticket_packages_data tp
                                                                        WHERE tp.ticket_sale_id = ts.id
                                                                ),
                                                                '[]'::json
                                                        )
                                                )
                                        )
                                        FROM ticket_sales_data ts
                                ),
                                '[]'::json
                        )
                ) as event_json
        FROM event_data e;
    `
</span>
</span>        var eventJSON json.RawMessage
        er</span>r := r.db.GetExecutor(ctx).QueryRow(ctx, query, payload.ID).Scan(&amp;eventJSON)
        i<span class="cov0" title="0">f err != nil {
</span>                if errors.Is(err, pgx.ErrNoRows) {
                        return nil, entity.EventNotFoundError
        <span class="cov6" title="5">        }
</span>                return nil, err
        }</span>

        <span class="cov6" title="5">rawBytes, merr := eventJSON.MarshalJSON()
</span>
        if merr != nil {
                </span>logger.FromCtx(ctx).Error("cannot marshal event json", zap.Error(merr))
        } else {
        <span class="cov6" title="5">        r.cache.Cache.Set</span>Default(eventCacheKey(payload.ID), rawBytes)
        }

        if err := json.Unmarshal(eventJSON, &amp;event); err != nil {
                logger.FromCtx(ctx).Error("cannot unmarshal eventjson", zap.Error(err))
                return nil, err
        }

        return &amp;event, nil
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package seat

import (
        "context"
        "github.com/georgysavva/scany/v2/pgxscan"
        "tugas-akhir/backend/infrastructure/postgres"
        "tugas-akhir/backend/internal/events/entity"
)

type PGSeatRepository struct {
        db *postgres.Postgres
}

func NewPGSeatRepository(
        db *postgres.Postgres,
) *PGSeatRepository <span class="cov7" title="5">{
        return &amp;PGSeatRepository{
                db: db,
        }
}</span>

func (r *PGSeatRepository) GetSeats(ctx context.Context, payload entity.GetSeatsDto) ([]entity.TicketSeat, error) <span class="cov10" title="8">{
        query := `
        SELECT *
        FROM ticket_seats
        WHERE ticket_area_id = $1
        ORDER BY seat_number
        `

        result := make([]entity.TicketSeat, 0)

        err := pgxscan.Select(
                ctx,
                r.db.GetExecutor(ctx),
                &amp;result,
                query,
                payload.TicketAreaID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="8">if len(result) == 0 </span><span class="cov1" title="1">{
                return nil, entity.SeatNotFoundError
        }</span>

        <span class="cov9" title="7">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package redis_availability_seeder

import (
        "context"
        "fmt"
        "go.uber.org/zap"
        "time"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/infrastructure/postgres"
        "tugas-akhir/backend/infrastructure/redis"
        entity2 "tugas-akhir/backend/internal/events/entity"
        availability2 "tugas-akhir/backend/internal/events/repository/availability"
        "tugas-akhir/backend/pkg/cursor_iterator"
        "tugas-akhir/backend/pkg/logger"
)

const seederRedisKey = "redis-availability-seeder-node"

type RedisAvailabilitySeeder struct {
        ctx        context.Context
        cancelFunc context.CancelFunc
        config     *config.Config
        redis      *redis.Redis
        db         *postgres.Postgres
}

func NewRedisAvailabilitySeeder(
        config *config.Config,
        redis *redis.Redis,
        db *postgres.Postgres,
) *RedisAvailabilitySeeder <span class="cov5" title="11">{
        ctx, cancel := context.WithCancel(context.Background())
        return &amp;RedisAvailabilitySeeder{
                ctx:        ctx,
                cancelFunc: cancel,
                config:     config,
                redis:      redis,
                db:         db,
        }
}</span>

func (s *RedisAvailabilitySeeder) iterAvailability() ([]entity2.AreaAvailability, *cursor_iterator.CursorIterator, error) <span class="cov5" title="10">{
        query := `
        SELECT 
            tp.ticket_sale_id AS ticket_sale_id,
                tp.id AS ticket_package_id,
                ta.id AS ticket_area_id,
                COUNT(ts.id) AS total_seats,
                COUNT(CASE WHEN ts.status = 'available' THEN 1 END) AS available_seats
        FROM 
                ticket_packages tp
        INNER JOIN 
                ticket_areas ta ON ta.ticket_package_id = tp.id
        INNER JOIN 
                ticket_seats ts ON ts.ticket_area_id = ta.id
        GROUP BY 
                tp.id, ta.id, tp.ticket_sale_id
    `

        result := make([]entity2.AreaAvailability, 500)

        iter, err := cursor_iterator.NewCursorIterator(s.db.Pool, result, query)

        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov5" title="10">return result, iter, err</span>
}

func (s *RedisAvailabilitySeeder) tryAcquireSeeder() (bool, error) <span class="cov5" title="9">{
        result, err := s.redis.GetOrSetWithEx(s.ctx, seederRedisKey, s.config.PodName, 3*time.Hour)
        if err != nil {
                return false,</span><span class="cov0" title="0"> err
        }
        r</span>eturn result == s.config.PodName, nil
}

</span>func (s *RedisAvailabilitySeeder) refreshData(returnOnError bool) error {
        l := logger.FromCtx(s.ctx)

        shouldGo, err := s.tryAcquireSeeder()

        if err != nil {
                l.Sugar().Error(err)
                if returnOnEr</span><span class="cov0" title="0">ror {
                        return err
                }
</span>                return nil
        }
</span>
</span>        if !shouldGo {
                l.Info("skipping refresh redis availability because not instance with lock")
        <span class="cov4" title="6">        if returnOnE</span><span class="cov0" title="0">rror {
                        return fmt.Errorf("skipping refresh redis availability because not instance with lock")
                }
</span>                return nil
        }
</span>
</span>        l.Info("refreshing redis availability")

        <span class="cov4" title="6">// refresh data
        data, iter, err := s.iterAvailability()

        if err != nil {
                l.Sugar().Error(err)
                if returnOnEr</span><span class="cov0" title="0">ror {
                        return err
                }
</span>                return nil
        }
</span>
</span>        defer iter.Close(s.ctx)

        <span class="cov4" title="6">// toSet now maps a hash key (for a ticket sale) to its fields and values.
        // map[hashKey] -&gt; map[field]value
        toSet := make(map[string]map[string]interface{})
        batchSize := 200 // Number of fields to process before sending a batch
        totalFieldsSet := 0

        sendBatch := func() error {
                pipe := s.redis.Client.Pi</span><span class="cov4" title="6">peline()
                for key, fields := range toSet {
                        // Use HSet to set mult</span><span class="cov10" title="120">iple fields in the hash for the given key.
                        pipe.HSet(s.ctx, key, fields)
                        totalFieldsSet += len(fields)
                }</span>

                <span class="cov4" title="6">if _, err := pipe.Exec(s.ctx); err != nil </span><span class="cov0" title="0">{
                        l.Sugar().Error("error executing pipeline for HSet", zap.Error(err))
                        if returnOnError </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov4" title="6">// Clear the map for the next batch.
                toSet = ma</span>ke(map[string]map[string]interface{})
                return nil
        }

</span>        for iter.Next(s.ctx) {
                availability := data[iter.ValueIndex()]
                key := availability2.CacheKey(availability.TicketSaleID)

                // Initialize the inner map if it doesn't exist for the current key.
                if _, ok := toSet[key]; !ok</span><span class="cov0" title="0"> {
                        toSet[key] = make(map[string]interface{})
                }
</span>
                //</span> Add the total and available seats as fields to the hash.
                toSet[key][availability2.GetTotalSeatsField(availability)] = availability.TotalSeats
                toSet[key][availability2.GetAvailableSeatsField(availability)] = availability.AvailableSeats

        <span class="cov4" title="6">        // Check if the number of fields i</span><span class="cov0" title="0">n the current hash key batch is large enough to send.
                if len(toSet[key]) &gt;= batchSize {
                        if err = sendBat</span><span class="cov0" title="0">ch(); returnOnError &amp;&amp; err != nil {
                                return err
                        </span>}
                }
        }

</span>        if err := iter.Error(); err != nil {
                l.Sugar().Error("error during c</span><span class="cov0" title="0">ursor iteration", zap.Error(err))
                if returnOnError {
                        </span>return err
                }
        }

        // Send an</span>y remaining data that didn't fill a full batch.
        if len(toSet) &gt; 0 {
                if err = sendBatch(); returnOnError &amp;&amp; err != nil {
                        return err
                }
        }

</span>        l.Info("completed seeder availability data with hashes", zap.Int("totalFieldsSet", totalFieldsSet))
        return nil
}

</span>func (s *RedisAvailabilitySeeder) Stop() error {
        s.cancelFunc()
        return nil
}</span>

func (s *RedisAvailabilitySeeder) RunSync(ctx context.Context) error {
        return s.refreshData(true)
}

</span>func (s *RedisAvailabilitySeeder) Run(ctx context.Context) error {
        r</span>eturn s.refreshData(false)
}

func (s *RedisAvailabilitySeeder) ApplyAvailability(ctx context.Context, items []entity2.AreaAvailability) error {
        pipe := s.</span>redis.Client.TxPipeline()

        for _, item := range items {
                key := availability2.CacheKey(item.TicketSaleID)
                field := availability2.GetAvailableSeatsField(item)
                // Use HIncrBy to decrement the value of a field within the hash.
                pipe.HIncrBy(ctx, key, fie</span><span class="cov4" title="6">ld, -1)
        }

</span>        _, err := pipe.Exec(ctx)
        <span class="cov2" title="2">return err
}

</span>func (s *RedisAvailabilitySeeder) RevertAvailability(ctx context.Context, items []entity2.AreaAvailability) error {
        pipe := s.redis.Client.TxPipeline()

        for _, item := range items {
                key := availability2.CacheKey(item.TicketSaleID)
                field := availability2.GetAvailableSeatsField(item)
                // Use HIncrBy to increment the value of a field within the hash.
                pipe.HIncrBy(ctx, key, field, 1)
        }

        _, err := pipe.Exec(ctx)
        return err
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package usecase

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "sync"
        "time"
        "tugas-akhir/backend/internal/events/entity"
        "tugas-akhir/backend/internal/events/repository/availability"
        "tugas-akhir/backend/internal/events/repository/event"
        "tugas-akhir/backend/internal/events/repository/seat"
        myerror "tugas-akhir/backend/pkg/error"
)

type EventUsecase struct {
        availabilityRepository availability.AvailabilityRepository
        seatRepository         seat.SeatRepository
        eventRepository        event.EventRepository
        seatCache              sync.Map
        ttl                    time.Duration
}

type CacheSeat struct {
        Value     []entity.TicketSeat
        Timestamp time.Time
}

func NewEventAvailabilityUsecase(
        availabilityRepository availability.AvailabilityRepository,
        seatRepository seat.SeatRepository,
        eventRepository event.EventRepository,
) *EventUsecase <span class="cov0" title="0">{
        return &amp;EventUsecase{
                availabilityRepository: availabilityRepository,
                seatRepository:         seatRepository,
                eventRepository:        eventRepository,
                seatCache:              sync.Map{},
                ttl:                    150 * time.Millisecond,
        }
}</span>

func (u *EventUsecase) GetSeats(ctx context.Context, payload entity.GetSeatsDto) ([]entity.TicketSeat, *myerror.HttpError) <span class="cov0" title="0">{
        cacheKey := fmt.Sprintf("seats:%d", payload.TicketAreaID)

        if val, ok := u.seatCache.Load(cacheKey); ok </span><span class="cov0" title="0">{
                cs := val.(CacheSeat)
                if time.Since(cs.Timestamp) &lt; u.ttl </span><span class="cov0" title="0">{
                        return cs.Value, nil
                }</span>
                <span class="cov0" title="0">u.seatCache.Delete(cacheKey)</span>
        }

        <span class="cov0" title="0">data, err := u.seatRepository.GetSeats(ctx, payload)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, entity.SeatNotFoundError) </span><span class="cov0" title="0">{
                        return nil, &amp;myerror.HttpError{
                                Message: err.Error(),
                                Code:    http.StatusNotFound,
                        }
                }</span> else<span class="cov0" title="0"> {
                        return nil, &amp;myerror.HttpError{
                                Message:      err.Error(),
                                ErrorContext: err,
                                Code:         http.StatusInternalServerError,
                        }
                }</span>
        }

        <span class="cov0" title="0">u.seatCache.Store(cacheKey, CacheSeat{
                Value:     data,
                Timestamp: time.Now(),
        })

        return data, nil</span>
}

func (u *EventUsecase) GetAvailability(ctx context.Context, payload entity.GetAvailabilityDto) ([]entity.AreaAvailability, *myerror.HttpError) <span class="cov0" title="0">{
        data, err := u.availabilityRepository.GetAvailability(ctx, payload)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, entity.AreaAvailabilityNotFoundError) </span><span class="cov0" title="0">{
                        return nil, &amp;myerror.HttpError{
                                Message: err.Error(),
                                Code:    http.StatusNotFound,
                        }
                }</span> else<span class="cov0" title="0"> {
                        return nil, &amp;myerror.HttpError{
                                Message:      err.Error(),
                                ErrorContext: err,
                                Code:         http.StatusInternalServerError,
                        }
                }</span>
        }

        <span class="cov0" title="0">return data, nil</span>
}

func (u *EventUsecase) GetEvent(ctx context.Context, payload entity.GetEventDto) (*entity.Event, *myerror.HttpError) <span class="cov0" title="0">{
        data, err := u.eventRepository.GetEvent(ctx, payload)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, entity.EventNotFoundError) </span><span class="cov0" title="0">{
                        return nil, &amp;myerror.HttpError{
                                Message: err.Error(),
                                Code:    http.StatusNotFound,
                        }
                }</span> else<span class="cov0" title="0"> {
                        return nil, &amp;myerror.HttpError{
                                Message:      err.Error(),
                                ErrorContext: err,
                                Code:         http.StatusInternalServerError,
                        }
                }</span>
        }

        <span class="cov0" title="0">return data, nil</span>
}

func (u *EventUsecase) GetEvents(ctx context.Context) ([]entity.Event, *myerror.HttpError) <span class="cov0" title="0">{
        data, err := u.eventRepository.GetEvents(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;myerror.HttpError{
                        Message:      err.Error(),
                        ErrorContext: err,
                        Code:         http.StatusInternalServerError,
                }
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package entity

import (
        "bytes"
        "encoding/gob"
        "fmt"
        "time"
        "tugas-akhir/backend/infrastructure/amqp/entity"
        myerror "tugas-akhir/backend/pkg/error"
)

var PlaceOrderTimeout = 130 * time.Second

var PlaceOrderQueue = entity.QueueConfig{
        Name:       "place_orders",
        Durable:    true,
        AutoDelete: false,
        NoWait:     false,
        Exclusive:  false,
        Timeout:    &amp;PlaceOrderTimeout,
}

func NewPlaceOrderReplyQueue(identifier string) entity.QueueConfig <span class="cov6" title="2">{
        return entity.QueueConfig{
                Name:       fmt.Sprintf("place_orders_reply_%s", identifier),
                Durable:    false,
                AutoDelete: false,
                NoWait:     false,
                Exclusive:  false,
                Timeout:    &amp;PlaceOrderTimeout,
        }
}</span>

var PlaceOrderExchange = entity.ExchangeConfig{
        Name:       "place_order",
        Kind:       "topic",
        Durable:    true,
        AutoDelete: false,
        NoWait:     false,
        Internal:   false,
}

type PlaceOrderMessage struct {
        Data       PlaceOrderDto
        ReplyRoute string
}

func (m PlaceOrderMessage) ToMessage() (*entity.Message, error) <span class="cov10" title="3">{
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)

        err := encoder.Encode(m)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="3">res := entity.Message{
                ContentType:  "application/json",
                Data:         buffer.Bytes(),
                TTL:          nil,
                RoutingKey:   "orders",
                Type:         nil,
                IsPersistent: true,
                LogDelivery:  false,
        }

        return &amp;res, nil</span>
}

type PlaceOrderReplyMessage struct {
        Order          *Order
        HttpErr        *myerror.HttpError
        ReplyRoute     string
        IdempotencyKey string
}

func (m PlaceOrderReplyMessage) ToMessage() (*entity.Message, error) <span class="cov10" title="3">{
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)

        err := encoder.Encode(m)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="3">res := entity.Message{
                ContentType:  "application/json",
                Data:         buffer.Bytes(),
                TTL:          nil,
                RoutingKey:   m.ReplyRoute,
                Type:         nil,
                IsPersistent: true,
                LogDelivery:  false,
        }

        return &amp;res, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package entity

import "errors"

type OrderStatus string

const (
        OrderStatus__WaitingForPayment OrderStatus = "waiting-for-payment"
        OrderStatus__Failed            OrderStatus = "failed"
        OrderStatus__Success           OrderStatus = "success"
)

func (e *OrderStatus) Scan(value interface{}) error <span class="cov10" title="6">{
        var enumValue string
        switch val := value.(type) </span>{
        case string:<span class="cov10" title="6">
                enumValue = val</span>
        case []byte:<span class="cov0" title="0">
                enumValue = string(val)</span>
        default:<span class="cov0" title="0">
                return errors.New("invalid scan value for OrderStatus enum. Enum value has to be of type string or []byte")</span>
        }

        <span class="cov10" title="6">switch enumValue </span>{
        case "waiting-for-payment":<span class="cov10" title="6">
                *e = OrderStatus__WaitingForPayment</span>
        case "success":<span class="cov0" title="0">
                *e = OrderStatus__Success</span>
        case "failed":<span class="cov0" title="0">
                *e = OrderStatus__Failed</span>
        default:<span class="cov0" title="0">
                return errors.New("invalid scan value '" + enumValue + "' for OrderStatus enum")</span>
        }

        <span class="cov10" title="6">return nil</span>
}

func (e *OrderStatus) Value() string <span class="cov0" title="0">{
        return string(*e)
}</span>

func (e *OrderStatus) String() string <span class="cov0" title="0">{
        return string(*e)
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package orders

import (
        "context"
        "go.uber.org/fx"
        "tugas-akhir/backend/internal/orders/repository/order"
        "tugas-akhir/backend/internal/orders/service/early_dropper"
        "tugas-akhir/backend/internal/orders/service/pgp_place_order_connector"
        "tugas-akhir/backend/internal/orders/usecase/get_order"
        "tugas-akhir/backend/internal/orders/usecase/place_order"
        "tugas-akhir/backend/internal/orders/usecase/webhook"
)

var BaseModule = fx.Options(
        fx.Provide(fx.Annotate(order.NewPGOrderRepository, fx.As(new(order.OrderRepository)))),
        fx.Provide(fx.Annotate(get_order.NewPGGetOrderUsecase, fx.As(new(get_order.GetOrderUsecase)))),
        fx.Provide(fx.Annotate(place_order.NewBasePlaceOrderUsecase, fx.As(new(place_order.PlaceOrderUsecase)))),
        fx.Provide(fx.Annotate(webhook.NewPGWebhookUsecase, fx.As(new(webhook.WebhookOrderUsecase)))),
)

var FCWorkerModule = fx.Options(
        fx.Provide(fx.Annotate(order.NewPGOrderRepository, fx.As(new(order.OrderRepository)))),
        fx.Provide(fx.Annotate(place_order.NewBasePlaceOrderUsecase, fx.As(new(place_order.PlaceOrderUsecase)))),
)

var FCModule = fx.Options(
        fx.Provide(fx.Annotate(order.NewPGOrderRepository, fx.As(new(order.OrderRepository)))),
        fx.Provide(fx.Annotate(get_order.NewPGGetOrderUsecase, fx.As(new(get_order.GetOrderUsecase)))),
        fx.Provide(fx.Annotate(pgp_place_order_connector.NewFCPlaceOrderConnector,
                fx.OnStart(func(connector *pgp_place_order_connector.FCPlaceOrderConnector, ctx context.Context) error <span class="cov0" title="0">{
                        return connector.Run(ctx)
                }</span>),
                fx.OnStop(func(connector *pgp_place_order_connector.FCPlaceOrderConnector) error <span class="cov0" title="0">{
                        return connector.Stop()
                }</span>),
        )),
        fx.Provide(fx.Annotate(early_dropper.NewFCEarlyDropper,
                fx.OnStart(func(dropper *early_dropper.EarlyDropper, ctx context.Context) error <span class="cov0" title="0">{
                        return dropper.Run(ctx)
                }</span>),
                fx.OnStop(func(dropper *early_dropper.EarlyDropper) error <span class="cov0" title="0">{
                        return dropper.Stop()
                }</span>),
        )),
        fx.Provide(fx.Annotate(
                place_order.NewFCPlaceOrderUsecase,
                fx.As(new(place_order.PlaceOrderUsecase)),
        )),
        fx.Provide(fx.Annotate(webhook.NewFCWebhookUsecase, fx.As(new(webhook.WebhookOrderUsecase)))),
)
</pre>
		
		<pre class="file" id="file47" style="display: none">package order

import (
        "context"
        "encoding/json"
        "fmt"
        "github.com/georgysavva/scany/v2/pgxscan"
        "github.com/jackc/pgx/v5"
        "github.com/pkg/errors"
        "tugas-akhir/backend/infrastructure/postgres"
        "tugas-akhir/backend/internal/orders/entity"
)

type PGOrderRepository struct {
        db *postgres.Postgres
}

func NewPGOrderRepository(db *postgres.Postgres) *PGOrderRepository <span class="cov6" title="4">{
        return &amp;PGOrderRepository{
                db: db,
        }
}</span>

func (r *PGOrderRepository) PlaceOrder(ctx context.Context, payload entity.PlaceOrderDto) (*entity.Order, error) <span class="cov7" title="6">{
        if payload.UserID == nil </span><span class="cov0" title="0">{
                return nil, errors.WithStack(errors.WithMessage(entity.OrderPlacementInternalError, "user id is nil"))
        }</span>

        <span class="cov7" title="6">if payload.TicketAreaID == nil </span><span class="cov0" title="0">{
                return nil, errors.WithStack(errors.WithMessage(entity.OrderPlacementInternalError, "first ticket area id is nil"))
        }</span>
        <span class="cov7" title="6">querier := r.db.GetExecutor(ctx)

        orderQuery := `
        INSERT INTO orders(external_user_id, ticket_area_id, status, ticket_sale_id, event_id)
        VALUES ($1, $2, 'waiting-for-payment', $3, $4)
        RETURNING *
    `

        var order entity.Order

        err := pgxscan.Get(ctx, querier, &amp;order, orderQuery, *payload.UserID, *payload.TicketAreaID, payload.TicketSaleID, payload.EventID)

        if err != nil </span><span class="cov0" title="0">{
                if pgxscan.NotFound(err) </span><span class="cov0" title="0">{
                        return nil, errors.WithStack(errors.WithMessage(entity.OrderPlacementInternalError, "no rows returned for order"))
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov7" title="6">orderItems := make([]entity.OrderItem, 0)

        orderItemQuery := `
        INSERT INTO order_items(customer_name, customer_email, price, order_id, ticket_seat_id, ticket_category_id, ticket_area_id) VALUES
    `

        args := []interface{}{}

        for i, item := range payload.Items </span><span class="cov10" title="12">{
                if i &gt; 0 </span><span class="cov7" title="6">{
                        orderItemQuery += ", "
                }</span>

                <span class="cov10" title="12">if item.Price == nil </span><span class="cov0" title="0">{
                        return nil, errors.WithStack(errors.WithMessage(entity.OrderPlacementInternalError, "order item price is nil"))
                }</span>

                <span class="cov10" title="12">if item.TicketCategoryID == nil </span><span class="cov0" title="0">{
                        return nil, errors.WithStack(errors.WithMessage(entity.OrderPlacementInternalError, "order item ticket category is nil"))
                }</span>

                <span class="cov10" title="12">paramOffset := i * 7
                orderItemQuery += fmt.Sprintf("($%d, $%d, $%d, $%d, $%d, $%d, $%d)",
                        paramOffset+1, paramOffset+2, paramOffset+3, paramOffset+4, paramOffset+5, paramOffset+6, paramOffset+7)
                args = append(args, item.CustomerName, item.CustomerEmail, *item.Price, order.ID, item.TicketSeatID, *item.TicketCategoryID, order.TicketAreaID)</span>
        }

        <span class="cov7" title="6">orderItemQuery += " RETURNING id, customer_name, customer_email, price, order_id, ticket_seat_id, ticket_category_id, created_at, updated_at"

        err = pgxscan.Select(ctx, querier, &amp;orderItems, orderItemQuery, args...)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="6">if len(orderItems) != len(payload.Items) </span><span class="cov0" title="0">{
                return nil, errors.WithStack(errors.WithMessage(entity.OrderPlacementInternalError, "returned order items length is different form payload length"))
        }</span>

        <span class="cov7" title="6">order.Items = orderItems

        return &amp;order, nil</span>
}

func (r *PGOrderRepository) GetOrder(ctx context.Context, payload entity.GetOrderDto) (*entity.Order, error) <span class="cov0" title="0">{
        if payload.UserID == nil &amp;&amp; !payload.BypassUserID </span><span class="cov0" title="0">{
                return nil, entity.OrderFetchInternalError
        }</span>

        <span class="cov0" title="0">var order entity.Order

        query := `
                WITH order_base AS (
                   SELECT
                          o.id, o.status, o.fail_reason, o.event_id, o.ticket_sale_id,
                          o.ticket_area_id, o.external_user_id, o.created_at, o.updated_at
                   FROM orders o
                   WHERE o.id = $1
                         AND o.ticket_area_id = $4
                         AND (o.external_user_id = $2 OR $3::boolean)
                ),
                invoice_details AS (
                   SELECT
                          i.id, i.status, i.amount, i.external_id, i.order_id, i.ticket_area_id AS invoice_ticket_area_id,
                          i.created_at, i.updated_at
                   FROM invoices i
                   JOIN order_base ob ON i.order_id = ob.id AND i.ticket_area_id = ob.ticket_area_id
                   WHERE i.ticket_area_id = $4
                ),
                event_details AS (
                   SELECT
                          e.id, e.name, e.location, e.description, e.created_at, e.updated_at
                   FROM events e
                   JOIN order_base ob ON e.id = ob.event_id
                ),
                ticket_sale_details AS (
                   SELECT
                          ts.id, ts.name, ts.sale_begin_at, ts.sale_end_at, ts.event_id,
                          ts.created_at, ts.updated_at
                   FROM ticket_sales ts
                   JOIN order_base ob ON ts.id = ob.ticket_sale_id
                ),
                order_items_enriched AS (
                   SELECT
                          oi.id AS item_id, oi.customer_name, oi.customer_email, oi.price, oi.order_id AS item_order_id,
                          oi.ticket_category_id, oi.ticket_seat_id,
                          oi.ticket_area_id AS item_ticket_area_id,
                          oi.created_at AS item_created_at, oi.updated_at AS item_updated_at,
                          
                          tc.id AS category_id, tc.name AS category_name, tc.event_id AS category_event_id,
                          tc.created_at AS category_created_at, tc.updated_at AS category_updated_at,
                          
                          ts_seat.id AS seat_id, ts_seat.seat_number, ts_seat.status AS seat_status,
                          ts_seat.ticket_area_id AS seat_ticket_area_id,
                          ts_seat.created_at AS seat_created_at, ts_seat.updated_at AS seat_updated_at,
                          
                          ta.id AS area_id, ta.type AS area_type, ta.ticket_package_id AS area_ticket_package_id,
                          ta.created_at AS area_created_at, ta.updated_at AS area_updated_at
                          
                   FROM order_items oi
                   JOIN order_base ob ON oi.order_id = ob.id AND oi.ticket_area_id = ob.ticket_area_id
                   LEFT JOIN ticket_categories tc ON oi.ticket_category_id = tc.id
                   LEFT JOIN ticket_seats ts_seat ON oi.ticket_seat_id = ts_seat.id AND oi.ticket_area_id = ts_seat.ticket_area_id
                   LEFT JOIN ticket_areas ta ON ts_seat.ticket_area_id = ta.id
                   WHERE oi.ticket_area_id = $4
                ),
                aggregated_order_items AS (
                   SELECT
                          item_order_id,
                          jsonb_agg(
                                 jsonb_build_object(
                                        'id', item_id,
                                        'customerName', customer_name,
                                        'customerEmail', customer_email,
                                        'price', price,
                                        'orderId', item_order_id,
                                        'ticketCategoryId', ticket_category_id,
                                        'ticketSeatId', seat_id,
                                        'ticketAreaId', item_ticket_area_id,
                                        'createdAt', item_created_at,
                                        'updatedAt', item_updated_at,
                                        'ticketSeat', CASE WHEN seat_id IS NOT NULL THEN jsonb_build_object(
                                           'id', seat_id,
                                           'seatNumber', seat_number,
                                           'status', seat_status,
                                           'ticketAreaId', seat_ticket_area_id,
                                           'createdAt', seat_created_at,
                                           'updatedAt', seat_updated_at,
                                           'ticketArea', CASE WHEN area_id IS NOT NULL THEN jsonb_build_object(
                                                  'id', area_id,
                                                  'type', area_type,
                                                  'ticketPackageId', area_ticket_package_id,
                                                  'createdAt', area_created_at,
                                                  'updatedAt', area_updated_at
                                           ) ELSE NULL END
                                        ) ELSE NULL END,
                                        'ticketCategory', CASE WHEN category_id IS NOT NULL THEN jsonb_build_object(
                                           'id', category_id,
                                           'name', category_name,
                                           'eventId', category_event_id,
                                           'createdAt', category_created_at,
                                           'updatedAt', category_updated_at
                                        ) ELSE NULL END
                                 )
                          ORDER BY item_id
                          ) AS items_json
                   FROM order_items_enriched
                   GROUP BY item_order_id
                )
                SELECT
                   jsonb_build_object(
                          'id', o.id,
                          'status', o.status,
                          'failReason', o.fail_reason,
                          'eventId', o.event_id,
                          'ticketSaleId', o.ticket_sale_id,
                          'ticketAreaId', o.ticket_area_id,
                          'externalUserId', o.external_user_id,
                          'createdAt', o.created_at,
                          'updatedAt', o.updated_at,
                          
                          'invoice', CASE WHEN i.id IS NOT NULL THEN
                                 jsonb_build_object(
                                        'id', i.id,
                                        'status', i.status,
                                        'amount', i.amount,
                                        'externalId', i.external_id,
                                        'orderId', i.order_id,
                                        'ticketAreaId', i.invoice_ticket_area_id,
                                        'createdAt', i.created_at,
                                        'updatedAt', i.updated_at
                                 )
                          ELSE NULL END,
                          
                          'event', CASE WHEN e.id IS NOT NULL THEN
                                 jsonb_build_object(
                                        'id', e.id,
                                        'name', e.name,
                                        'location', e.location,
                                        'description', e.description,
                                        'createdAt', e.created_at,
                                        'updatedAt', e.updated_at
                                 )
                          ELSE NULL END,
                          
                          'ticketSale', CASE WHEN tsale.id IS NOT NULL THEN
                                 jsonb_build_object(
                                        'id', tsale.id,
                                        'name', tsale.name,
                                        'saleBeginAt', tsale.sale_begin_at,
                                        'saleEndAt', tsale.sale_end_at,
                                        'eventId', tsale.event_id,
                                        'createdAt', tsale.created_at,
                                        'updatedAt', tsale.updated_at
                                 )
                          ELSE NULL END,
                          
                          'items', COALESCE(aoi.items_json, '[]'::jsonb)
                   ) as order_json
                FROM order_base o
                LEFT JOIN invoice_details i ON o.id = i.order_id AND o.ticket_area_id = i.invoice_ticket_area_id
                LEFT JOIN event_details e ON o.event_id = e.id
                LEFT JOIN ticket_sale_details tsale ON o.ticket_sale_id = tsale.id
                LEFT JOIN aggregated_order_items aoi ON o.id = aoi.item_order_id;
    `

        var orderJSON </span><span class="cov0" title="0">json.RawMessage
        err := r.db.GetExecutor(ctx).Query</span><span class="cov0" title="0">Row(ctx, query, payload.OrderID, payload.UserID, payload.BypassUserID, payload.TicketAreID).Scan(&amp;orderJSON)
        if err != nil {
                i</span>f errors.Is(err, pgx.ErrNoRows) {
                <span class="cov0" title="0">        return nil, en</span>tity.OrderNotFoundError
                }
                return nil, err
        <span class="cov0" title="0">}
</span>
        i</span>f err := json.Unmarshal(orderJSON, &amp;order); err != nil {
                return nil, err
        <span class="cov0" title="0">}
</span>
        return &amp;order, nil
}

func (r *PGOrderRepository) UpdateOrderStatus(ctx context.Context, payload entity.UpdateOrderStatusDto) error {
        query := `
        UPDATE orders
        SET status = $1, fail_reason = $2, updated_at = now()
        WHERE id = $3 and ticket_area_id = $4
    `

        rows, err := r.db.GetExecuto</span><span class="cov0" title="0">r(ctx).Exec(ctx, query, payload.Status, payload.FailReason, payload.OrderID, payload.TicketAreaID)

        i</span>f rows.RowsAffected() == 0 {
                return errors.WithStack(entity.OrderNotFoundError)
        <span class="cov0" title="0">}
</span>
        return err
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package early_dropper

import (
        "context"
        "errors"
        "fmt"
        "github.com/labstack/echo/v4"
        errors2 "github.com/pkg/errors"
        baseredis "github.com/redis/go-redis/v9"
        "go.uber.org/zap"
        "strconv"
        "time"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/infrastructure/redis"
        "tugas-akhir/backend/internal/bookings/repository/booked_seats"
        entity2 "tugas-akhir/backend/internal/events/entity"
        "tugas-akhir/backend/internal/orders/entity"
        "tugas-akhir/backend/pkg/logger"
)

const DropperRedisPrefix = "early-dropper:"
const referesherRedisKey = "refresher-node"

func numberedSeatKey(areaID int64, seatID int64) string {
        </span>return fmt.Sprintf("%s{area-%d}status:numbered:%d", DropperRedisPrefix, areaID, seatID)
}

func freeStandingKey(areaID int64) string {
        </span>return fmt.Sprintf("%s{area-%d}status:free-standing:%d", DropperRedisPrefix, areaID, areaID)
}

type EarlyDropper struct {
        ctx                  context.Context
        cancelFunc           context.CancelFunc
        config               *config.Config
        redis                *redis.Redis
        bookedSeatRepository booked_seats.BookedSeatRepository
}

func NewFCEarlyDropper(
        config *config.Config,
        redis *redis.Redis,
        bookedSeatRepos<span class="cov3" title="9">itory booked_seats.BookedSeatRepository,
) *EarlyDropper {
        ctx, cancel := context.WithCancel(context.Background())
        return &amp;EarlyDropper{
                ctx:                  ctx,
                cancelFunc:           cancel,
                config:               config,
                redis:                redis,
                bookedSeatRepository: bookedSeatRepository,
        </span>}
}

func (s *EarlyDropper) tryAcquireRefresher() (bool, error) {
        result, err := s.redis.GetOrSetWithEx(s.ctx, DropperRedisPrefix+referesherRedisKey, s.config.PodName, 15*time.Minute)

</span>        if err != nil {
                </span>return false, err
        }

</span>        return result == s.config.PodName, nil
}

func (s *EarlyDropper) refreshData(returnOnError bool) error {
        l := logger.FromCtx(s.ctx)

        shouldGo, err := s.tryAcquireRefresher()

</span>        if err != nil {
                l.Sugar().Error(e</span><span class="cov0" title="0">rr)
                if returnOnError {
                        </span>return err
                <span class="cov0" title="0">}
</span>                return nil
        }

</span>        if !shouldGo {
                l.Info("skipping </span><span class="cov0" title="0">refresh early dropper because not instance with lock")
                if returnOnError {
                        </span>return fmt.Errorf("skipping refresh early dropper because not instance with lock")
                <span class="cov0" title="0">}
</span>                return nil
        }

        <span class="cov2" title="3">// refresh data
        data, iter, err := s.bookedSeatRepository.IterSeats(s.ctx)

</span>        if err != nil {
                l.Sugar().Error(e</span><span class="cov0" title="0">rr)
                if returnOnError {
                        </span>return err
                <span class="cov0" title="0">}
</span>                return nil
        }

        defer iter.Close(s.ctx)

        countSet := 0

        freeStandingAvailability := make(map[string]int)
        numberedBuffer := make([]entity2.TicketSeat, 0)
        numberedBufferBatchSize := 100

</span>        sendNumberedBatch := func() error {
                values := make(map[string]string)

</span>                for _, seat := range numberedBuffer {
                        </span>values[numberedSeatKey(seat.TicketArea.ID, seat.ID)] = string(seat.Status)
                }

                pipe := s.redis.Client.Pi</span><span class="cov8" title="2100">peline()
                for k, v := range values {
                        countSet++
                        </span>pipe.Set(s.ctx, k, v, 0)
                }

                numberedBuffer = make([]entity2.TicketSeat, 0)

</span>                if _, err := pipe.Exec(s.ctx); err != nil {
                        l.Sugar().Error(e</span><span class="cov0" title="0">rr)
                        if returnOnError {
                                </span>return err
                        }
                }

</span>                return nil
        }

</span>        for iter.Next(s.ctx) {
                seat := data[iter.ValueIndex()]

</span>                if seat.TicketArea.Type == entity2.AreaType__Free</span><span class="cov9" title="13800">Standing {
                        if seat.Status == entity2.SeatStatus__Available {
                                key := freeStandingKey(seat.TicketAreaID)

                                _, ok := freeStandingAvailability[key]

</span>                                if ok {
                                        </span>freeS<span class="cov3" title="18">tandingAvailability[key]++
                                } else {
                                        </span>freeStandingAvailability[key] = 1
                                }
                        }
                } else {
                        // numbered
                        numberedBuffer = append(numberedBuffer, seat)

</span>                        if len(numberedBuffer) &gt;= numberedBufferBatchSize {
                                err = sendNumberedBatch()
</span>                                if returnOnError &amp;&amp; err != nil {
                                        </span>return err
                                }
                        }
                }
        }

</span>        if err := iter.Error(); err != nil {
                l.Sugar().Error(e</span><span class="cov0" title="0">rr)
                if returnOnError {
                        </span>return err
                }
        }

</span>        if len(numberedBuffer) &gt; 0 {
                err = sendNumberedBatch()
</span>                if returnOnError &amp;&amp; err != nil {
                        </span>return err
                }
        }

        pipe := s.redis.Client.Pipeline()
</span>        for k, v := range freeStandingAvailability {
                countSet++
                pipe.Set(s.ctx, k, v, 0)
                // add original count here
                </span>pipe.Set(s.ctx, fmt.Sprintf("debug:%s", k), v, 0)
        }

</span>        if _, err := pipe.Exec(s.ctx); err != nil {
                l.Sugar().Error(err)
</span>                if returnOnError &amp;&amp; err != nil {
                        </span>return err
                }
        }

        l.Info("co</span>mpleted refreshing early dropper data", zap.Int("countSet", countSet))
        return nil
}

func (s *EarlyDropper) Stop() error {
        s.cancelFunc()
        </span>return nil
}

func (s *EarlyDropper) RunSync(ctx context.Context) error {
        </span>return s.refreshData(true)
}

func (s *EarlyDropper) Run(ctx context.Context) error {
        </span>return s.refreshData(false)
}

func (s *EarlyDropper) TryAcquir</span><span class="cov0" title="0">eLock(ctx context.Context, payload entity.PlaceOrderDto) (*LockReleaser, error) {
        if payload.TicketAreaID == nil {
                </span>return nil, fmt.Errorf("ticket area id must not be nil")
        }

        l := logger.FromCtx(ctx)

        // Create maps to track operations we need to perform
        numberedSeatsToLock := make(map[int64]bool)
        freeStandingAreasToLock := make(map[int64]int)

        // Group seats by area for free sta</span><span class="cov3" title="14">nding and collect numbered seats
        for _, item := range payload.</span><span class="cov2" title="8">Items {
                if item.TicketSeatID != nil {
                        </span>numbe<span class="cov2" title="6">redSeatsToLock[*item.TicketSeatID] = true
                } else {
                        </span>freeStandingAreasToLock[item.TicketAreaID]++
                }
        }

        <span class="cov2" title="7">// Collect all keys we need to watch
        var keysToWatch []string
</span>        for seatID := range numberedSeatsToLock {
                </span>keysToWatch = append(keysToWatch, numberedSeatKey(*payload.TicketAreaID, seatID))
        <span class="cov2" title="7">}
</span>        for areaID := range freeStandingAreasToLock {
                </span>keysToWatch = append(keysToWatch, freeStandingKey(areaID))
        }

        <span class="cov2" title="7">// Retry loop for optimistic locking
        var maxRetries = 5
</span>        for i := 0; i &lt; maxRetries; i++ {
</span>                err := s.redis.Client.Watch(ctx, func(tx *baseredis.Tx) error {
                        // Step 1: Check all numbered seats
                        var numberedKeysToCheck []string
                        var numberedSeatIDs []int64

</span>                        for seatID := range numberedSeatsToLock {
                                numberedKeysToCheck = append(numberedKeysToCheck, numberedSeatKey(*payload.TicketAreaID, seatID))
                                </span>numberedSeatIDs = append(numberedSeatIDs, seatID)
                        }

                        var numberedResults *baseredis.S</span><span class="cov2" title="4">liceCmd
                        if len(numberedKeysToCheck) &gt; 0 {
                                </span>numberedResults = tx.MGet(ctx, numberedKeysToCheck...)
                        }

                        <span class="cov2" title="7">// Step 2: Check all free standing areas
                        freeStandingChecks := make(map[int64]*basere</span><span class="cov2" title="3">dis.StringCmd)
                        for areaID := range freeStandingAreasToLock {
                                key := freeStandingKey(areaID)
                                </span>freeStandingChecks[areaID] = tx.Get(ctx, key)
                        }

                        <span class="cov2" title="7">// Execute all checks (implicit </span><span class="cov2" title="4">in the WATCH transaction)
                        if len(numberedKeysToCheck) &gt; 0 {
                                results, err := numberedResults.Result()
</span>                                if err != nil &amp;&amp; !errors.Is(err, baseredis.Nil) {
                                        </span>return err
                                }

</span>                                for k, result := range results {
                                        status, ok := result.(string)
</span>                                        if !ok || status != string(entity2.SeatStatus__Available) {
                                                </span>return errors2.WithMessagef(entity.DropperSeatNotAvailable, "seat %d is not available", numberedSeatIDs[k])
                                        }
                                }
                        }

                        <span class="cov2" title="6">// Validate free standing areas
</span>                        for areaID, count := range freeStandingAreasToLock {
                                availableStr, err := freeStanding</span><span class="cov0" title="0">Checks[areaID].Result()
                                if errors.Is(err, baseredis.Nil) {
                                        </span>retur<span class="cov2" title="3">n errors2.WithM</span><span class="cov0" title="0">essagef(entity.DropperInternalError, "free standing area %d not found", areaID)
                                } else if err != nil {
                                        </span>return err
                                }

                                available, err</span><span class="cov0" title="0"> := strconv.Atoi(availableStr)
                                if err != nil {
                                        </span>return err
                                }

</span>                                if available &lt; count {
                                        </span>return errors2.WithMessagef(entity.DropperSeatNotAvailable, "not enough seats available in area %d: requested %d, available %d", areaID, count, available)
                                }
                        }

                        <span class="cov2" title="5">// If we get here, all checks passed - proceed with the transaction</span><span class="cov2" title="5">
                        _, err := tx.TxPipelined(ctx, func(pipe baseredis.Pipeliner) error {
                                // Lock numbered seats by changing their</span><span class="cov2" title="6"> status to on-hold
                                for seatID := range numberedSeatsToLock {
                                        key := numberedSeatKey(*payload.TicketAreaID, seatID)
                                        </span>pipe.Set(ctx, key, string(entity2.SeatStatus__OnHold), 0)
                                }

                                <span class="cov2" title="5">// Decrement available counts for free standing are</span><span class="cov1" title="2">as
                                for areaID, count := range freeStandingAreasToLock {
                                        key := freeStandingKey(areaID)
                                        </span>pipe.DecrBy(ctx, key, int64(count))
                                <span class="cov2" title="5">}
</span>                                return nil
                        <span class="cov2" title="5">})
</span>                        return err
                }, keysToWatch...)

</span>                if err == nil {
                        requestID := ""
</span>
                        i</span>f rawRequestID, ok := ctx.Value(echo.HeaderXRequestID).(string); ok {
                                requestID = rawRequestID
                        <span class="cov2" title="5">}
</span>
                        // Success - create the releasers
                        onSuccess := func() error {
                                return nil
</span>                        }

                        on</span>Failure := func() error {
                                pipe := s.redis.Client.TxPipeline()

                                <span class="cov1" title="1">// Restore numbered seats to available
</span>                                for seatID := range numberedSeatsToLock {
                                        key := numberedSeatKey(*payload.TicketAreaID, seatID)
                                        </span>pipe.Set(ctx, key, string(entity2.SeatStatus__Available), 0)
                                }

                                // Increment f</span><span class="cov0" title="0">ree standing area availability
                                for areaID, count := range freeStandingAreasToLock {
                                        </span>key := freeStandingKey(areaID)
                                        pipe.IncrBy(ctx, key, int64(count))
                                <span class="cov1" title="1">}
</span>
                                _, err := pipe.Exec(context.Background())
                        <span class="cov2" title="5">        if err != nil {
                                        return err
                                }

</span>                                return nil
                        }

</span>                        return NewLockReleaser(requestID, onSuccess, onFailure), nil
                }

</span>                if errors.Is(err, baseredis.TxFailedErr) {
                        // Conflict occurred, retry
                        l.Sugar().Infof("Transaction conflict for %s, retrying (attempt %d/%d)", *payload.IdempotencyKey, i+1, maxRetries)
                <span class="cov1" title="2">        continue
</span>                }

                // Other error occurred
        <span class="cov0" title="0">        return nil, err
        }
</span>
        // Max retries exceeded
        l.Sugar().Warnf("max retries exceeded for seat locking %s", *payload.IdempotencyKey)
        return nil, errors2.WithStack(entity.Can</span><span class="cov0" title="0">notAcquireLock)
}

</span>func (s *EarlyDropper) FinalizeLock(ctx context.Context, items []entity.OrderItem, status entity2.SeatStatus) error {
        if status == entity2.SeatStatus__OnHold {
        <span class="cov1" title="2">        return fmt.Errorf("final seat status </span><span class="cov1" title="1">cannot be on hold")
        }

        // operation success
        if status == entity2.SeatSta</span><span class="cov2" title="3">tus__Sold {
                // only update seat status for numbered seat
</span>                pipe := s.redis.Client.TxPipeline()

                fo</span>r _, item := range items {
                        if item.TicketSeat.TicketArea.Type == entity2.AreaType__NumberedSeating {
                                key := numberedSeatKey(item.TicketSeat.TicketAreaID, item.TicketSeatID)
                <span class="cov1" title="1">                pipe.Set(ctx, key, string(entity2.SeatStatus__Sold), 0)
                        }
</span>                }

</span>                _, err := pipe.Exec(ctx)
                <span class="cov1" title="1">if err != </span>nil {
                        return err
                }

        <span class="cov1" title="1">        return nil
</span>        }

        // operation fail
        if status == entity2.SeatSta</span><span class="cov1" title="2">tus__Available {
                // only update seat status for numbered seat
</span>                pipe := s.redis.Client.TxPipeline()

                fo</span>r _, <span class="cov1" title="1">item := range items {
                        if item.TicketSeat.TicketArea.Type == entity2.AreaType__NumberedSeating {
                                key := numberedSeatKey(item.TicketSeat.TicketAreaID, item.TicketSeatID)
                                </span>pipe.Set(ctx, key, string(entity2.SeatStatus__Available), 0)
                        } else {
                                key := freeStandingKey(item.TicketSeat.TicketAreaID)
                <span class="cov1" title="1">                pipe.IncrBy(ctx, key, int64(1))
                        }
</span>                }

</span>                _, err := pipe.Exec(ctx)
                <span class="cov1" title="1">if err != </span>nil {
                        return err
                }

</span>                return nil
        }

        return fmt.Errorf("code should be unreachable")
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package early_dropper

import (
        "sync"
        "tugas-akhir/backend/internal/orders/entity"
        "tugas-akhir/backend/pkg/logger"
)

type lockHolder struct {
        Locks sync.Map
}

</span>var LockHolder = lockHolder{
        Locks: sync.Map{},
}
</span>
t<span class="cov4" title="2">ype LockReleaser struct {
</span>        requestID string
        isRun     bool
        onSuccess func() error
        onFailed  fu</span><span class="cov1" title="1">nc() error
}

fu</span>nc NewLockReleaser(
        requestID string,
        <span class="cov4" title="2">onSuccess func() error,
</span>        onFailed func() error,
) *LockReleaser {
        lock := LockReleaser{
                requestID: requestID,
                isRun:     false,
                onFailed:  onFailed,
                onSuccess: onSuccess,
        }

        if requestID == "" {
                logger.GetInfo().Warn("Lock releaser registered with empty request id. skipping timeout fallback.")
        } else {
                LockHolder.Locks.Store(requestID, &amp;lock)
        }

        return &amp;lock
}

func (r *LockReleaser) releaseFromHolder() {
        if r.requestID != "" {
                LockHolder.Locks.Delete(r.requestID)
        }
}

func (r *LockReleaser) OnSuccess() error {
        defer r.releaseFromHolder()

        if !r.isRun {
                r.isRun = true
                return r.onSuccess()
        }

        return entity.LockAlreadyReleased
}

func (r *LockReleaser) OnFailed() error {
        defer r.releaseFromHolder()

        if !r.isRun {
                r.isRun = true
                return r.onFailed()
        }

        return entity.LockAlreadyReleased
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package idempotent_place_order

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        redis2 "github.com/redis/go-redis/v9"
        "net/http"
        "time"
        "tugas-akhir/backend/infrastructure/redis"
        "tugas-akhir/backend/internal/orders/entity"
        myerror "tugas-akhir/backend/pkg/error"
        "tugas-akhir/backend/pkg/logger"
)

func buildRedisIdempotencyKey(key string) string <span class="cov7" title="3">{
        return fmt.Sprintf("place-order:%s", key)
}</span>

type idempotencyData struct {
        Entity  *entity.Order      `json:"entity"`
        HttpErr *myerror.HttpError `json:"httpErr"`
}

func WrapIdempotency(
        ctx context.Context,
        redis *redis.Redis,
        handler func(ctx context.Context, payload entity.PlaceOrderDto) (*entity.Order, *myerror.HttpError),
        payload entity.PlaceOrderDto,
) (*entity.Order, *myerror.HttpError) <span class="cov10" title="5">{
        l := logger.FromCtx(ctx)

        if payload.IdempotencyKey == nil || *payload.IdempotencyKey == "" </span><span class="cov4" title="2">{
                return nil, &amp;myerror.HttpError{
                        Code:    http.StatusBadRequest,
                        Message: entity.IdempotencyKeyNotFound.Error(),
                }
        }</span>

        <span class="cov7" title="3">redisKey := buildRedisIdempotencyKey(*payload.IdempotencyKey)

        cacheVal, cacheErr := redis.Client.Get(ctx, redisKey).Result()

        if cacheErr != nil </span><span class="cov4" title="2">{
                if errors.Is(cacheErr, redis2.Nil) </span><span class="cov4" title="2">{
                        // perform the request as usual
                        order, httpErr := handler(ctx, payload)

                        if httpErr == nil </span><span class="cov1" title="1">{
                                // store idempotency for success operation only
                                cacheData := idempotencyData{
                                        Entity:  order,
                                        HttpErr: nil,
                                }

                                marshalled, err := json.Marshal(cacheData)

                                if err != nil </span><span class="cov0" title="0">{
                                        l.Sugar().Error(err)
                                }</span> else<span class="cov1" title="1"> {
                                        if cmdErr := redis.Client.SetEx(ctx, redisKey, string(marshalled), 15*time.Minute).Err(); cmdErr != nil </span><span class="cov0" title="0">{
                                                l.Sugar().Error(cmdErr)
                                        }</span>
                                }

                        }

                        <span class="cov4" title="2">return order, httpErr</span>
                } else<span class="cov0" title="0"> {
                        return nil, &amp;myerror.HttpError{
                                Code:         http.StatusInternalServerError,
                                Message:      cacheErr.Error(),
                                ErrorContext: cacheErr,
                        }
                }</span>
        }

        // value found
        <span class="cov1" title="1">var result idempotencyData
        if err := json.Unmarshal([]byte(cacheVal), &amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;myerror.HttpError{
                        Code:         http.StatusInternalServerError,
                        Message:      err.Error(),
                        ErrorContext: err,
                }
        }</span>

        <span class="cov1" title="1">return result.Entity, result.HttpErr</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package pgp_place_order_connector

import (
        "bytes"
        "context"
        "encoding/gob"
        "errors"
        "fmt"
        "go.uber.org/zap"
        "sync"
        "time"
        "tugas-akhir/backend/infrastructure/amqp"
        entity2 "tugas-akhir/backend/infrastructure/amqp/entity"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/internal/orders/entity"
        "tugas-akhir/backend/pkg/logger"
        "tugas-akhir/backend/pkg/utility"
)

type FCPlaceOrderConnector struct {
        placeOrderPublisher     *amqp.Publisher
        placeOrderReplyConsumer *amqp.Consumer
        //ListenerChan            map[string]chan entity.PlaceOrderReplyMessage
        ListenerChan   sync.Map
        ctx            context.Context
        cancelCtx      context.CancelFunc
        config         *config.Config
        ReplyRouteName string
}

func NewFCPlaceOrderConnector(
        config *config.Config,
) *FCPlaceOrderConnector <span class="cov4" title="2">{
        placeOrderPublisher := amqp.NewPublisher(config, &amp;entity.PlaceOrderExchange)

        replyRouteName := fmt.Sprintf("place_orders_reply.%s", config.PodName)

        placeOrderReplyConsumer := amqp.NewConsumer(
                config,
                entity.NewPlaceOrderReplyQueue(config.PodName),
                &amp;entity.PlaceOrderExchange,
                entity2.ConsumeConfig{
                        PrefetchCount: 10000,
                        PrefetchSize:  0,
                        AutoAck:       false,
                        RoutingKeys:   []string{replyRouteName},
                },
        )

        ctx, cancel := context.WithCancel(context.Background())

        return &amp;FCPlaceOrderConnector{
                ctx:                     ctx,
                cancelCtx:               cancel,
                config:                  config,
                placeOrderReplyConsumer: placeOrderReplyConsumer,
                placeOrderPublisher:     placeOrderPublisher,
                ReplyRouteName:          replyRouteName,
                ListenerChan:            sync.Map{},
        }
}</span>

func (c *FCPlaceOrderConnector) Stop() error <span class="cov4" title="2">{
        c.cancelCtx()

        err1 := c.placeOrderPublisher.Close()
        err2 := c.placeOrderReplyConsumer.Close()

        if err1 != nil </span><span class="cov0" title="0">{
                return err1
        }</span> else<span class="cov4" title="2"> if err2 != nil </span><span class="cov0" title="0">{
                return err2
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func (c *FCPlaceOrderConnector) Run(ctx context.Context) error <span class="cov4" title="2">{
        // run consume place order
        err := c.consumeReply()

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func (c *FCPlaceOrderConnector) consumeReply() error <span class="cov4" title="2">{
        l := logger.FromCtx(c.ctx).With(zap.String("context", "place-order-reply-consumer"))

        go func() </span><span class="cov4" title="2">{
        connLoop:
                for </span><span class="cov4" title="2">{
                        channel, consumeErr := c.placeOrderReplyConsumer.Consume(c.ctx)

                        if consumeErr != nil </span><span class="cov0" title="0">{
                                l.Sugar().Error(consumeErr)
                                continue</span>
                        }

                <span class="cov4" title="2">mainLoop:
                        for </span><span class="cov10" title="5">{
                                select </span>{
                                case rawMsg, ok := &lt;-channel:<span class="cov7" title="3">
                                        if !ok </span><span class="cov0" title="0">{
                                                l.Info("channel is closed")
                                                break mainLoop</span>
                                        }

                                        //l.Info("receiving message")

                                        <span class="cov7" title="3">go func() </span><span class="cov7" title="3">{
                                                var buffer bytes.Buffer

                                                if _, writeBufferErr := buffer.Write(rawMsg.Body); writeBufferErr != nil </span><span class="cov0" title="0">{
                                                        l.Sugar().Error(writeBufferErr)

                                                        rejectErr := rawMsg.Reject(true)

                                                        if rejectErr != nil </span><span class="cov0" title="0">{
                                                                l.Sugar().Error(rejectErr)
                                                        }</span>

                                                        <span class="cov0" title="0">return</span>
                                                }

                                                <span class="cov7" title="3">var payload entity.PlaceOrderReplyMessage

                                                decoder := gob.NewDecoder(&amp;buffer)
                                                if decodeErr := decoder.Decode(&amp;payload); decodeErr != nil </span><span class="cov0" title="0">{
                                                        l.Sugar().Error(decodeErr)

                                                        rejectErr := rawMsg.Reject(true)

                                                        if rejectErr != nil </span><span class="cov0" title="0">{
                                                                l.Sugar().Error(rejectErr)

                                                        }</span>

                                                        <span class="cov0" title="0">return</span>
                                                }

                                                // pass the result to channel
                                                //ch, exists := c.ListenerChan[payload.IdempotencyKey]
                                                <span class="cov7" title="3">rawCh, exists := c.ListenerChan.Load(payload.IdempotencyKey)

                                                if exists {
                                                        ch := rawCh.(chan entity.PlaceOrderReplyMessage)

</span>                                                        ch &lt;- payload

                                                        if ackErr := rawMsg.Ack(false); ackErr != nil </span><span class="cov0" title="0">{
                                                                l.Error("ack err", zap.Error(ackErr))
                                                        }</span>

                                                } else<span class="cov0" title="0"> {
                                                        l.Warn("cannot find the corresponding listener", zap.String("idempotency-key", payload.IdempotencyKey))
                                                        // just ack in this case to prevent redelivery
                                                        if ackErr := rawMsg.Ack(false); ackErr != nil </span><span class="cov0" title="0">{
                                                                l.Error("ack err", zap.Error(ackErr))
                                                        }</span>
                                                }
                                        }()
                                case &lt;-c.ctx.Done():<span class="cov4" title="2">
                                        l.Info("consume place order reply context is done")
                                        break connLoop</span>
                                }
                        }
                }
        }()

        <span class="cov4" title="2">return nil</span>
}

func (c *FCPlaceOrderConnector) PublishRequest(ctx context.Context, message entity.PlaceOrderMessage) error <span class="cov7" title="3">{
        amqpMessage, err := message.ToMessage()

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

<span class="cov7" title="3">ensureDelivered:
        for </span><span class="cov7" title="3">{
                err := c.placeOrderPublisher.Push(*amqpMessage)

                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, entity2.NotConnectedError) </span><span class="cov0" title="0">{
                                utility.SleepWithContext(ctx, 100*time.Millisecond)
                        }</span> else<span class="cov0" title="0"> {
                                return err
                        }</span>
                }

                <span class="cov7" title="3">break ensureDelivered</span>
        }

        <span class="cov7" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package get_order

import (
        "context"
        "errors"
        "net/http"
        entity2 "tugas-akhir/backend/internal/bookings/entity"
        "tugas-akhir/backend/internal/bookings/repository/booked_seats"
        "tugas-akhir/backend/internal/orders/entity"
        "tugas-akhir/backend/internal/orders/repository/order"
        myerror "tugas-akhir/backend/pkg/error"
)

type PGGetOrderUsecase struct {
        orderRepository order.OrderRepository
        seatRepository  booked_seats.BookedSeatRepository
}

func NewPGGetOrderUsecase(
        orderRepository order.OrderRepository,
        seatRepository booked_seats.BookedSeatRepository,
) *PGGetOrderUsecase <span class="cov10" title="4">{
        return &amp;PGGetOrderUsecase{
                orderRepository: orderRepository,
                seatRepository:  seatRepository,
        }
}</span>

func (u *PGGetOrderUsecase) GetOrder(ctx context.Context, payload entity.GetOrderDto) (*entity.Order, *myerror.HttpError) <span class="cov0" title="0">{
        orderEntity, err := u.orderRepository.GetOrder(ctx, payload)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, entity.OrderNotFoundError) </span><span class="cov0" title="0">{
                        return nil, &amp;myerror.HttpError{
                                Code:         http.StatusNotFound,
                                Message:      err.Error(),
                                ErrorContext: err,
                        }
                }</span>

                <span class="cov0" title="0">return nil, &amp;myerror.HttpError{
                        Code:         http.StatusInternalServerError,
                        Message:      err.Error(),
                        ErrorContext: err,
                }</span>
        }

        <span class="cov0" title="0">return orderEntity, nil</span>
}

func (u *PGGetOrderUsecase) GetIssuedTicket(ctx context.Context, payload entity2.GetIssuedTicketDto) ([]entity2.IssuedTicket, *myerror.HttpError) <span class="cov0" title="0">{
        issuedTickets, err := u.seatRepository.GetIssuedTickets(ctx, payload)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, entity2.IssuedTicketNotFoundError) </span><span class="cov0" title="0">{
                        return nil, &amp;myerror.HttpError{
                                Code:         http.StatusNotFound,
                                Message:      err.Error(),
                                ErrorContext: err,
                        }
                }</span>

                <span class="cov0" title="0">return nil, &amp;myerror.HttpError{
                        Code:         http.StatusInternalServerError,
                        Message:      err.Error(),
                        ErrorContext: err,
                }</span>
        }

        <span class="cov0" title="0">return issuedTickets, nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package place_order

import (
        "context"
        "errors"
        "fmt"
        "github.com/jackc/pgx/v5/pgconn"
        errors2 "github.com/pkg/errors"
        "net/http"
        "time"
        "tugas-akhir/backend/infrastructure/postgres"
        entity2 "tugas-akhir/backend/internal/bookings/entity"
        "tugas-akhir/backend/internal/bookings/repository/booking"
        entity3 "tugas-akhir/backend/internal/events/entity"
        "tugas-akhir/backend/internal/events/repository/event"
        "tugas-akhir/backend/internal/events/service/redis_availability_seeder"
        "tugas-akhir/backend/internal/orders/entity"
        "tugas-akhir/backend/internal/orders/repository/order"
        entity4 "tugas-akhir/backend/internal/payments/entity"
        "tugas-akhir/backend/internal/payments/repository/invoice"
        "tugas-akhir/backend/internal/payments/service"
        myerror "tugas-akhir/backend/pkg/error"
        "tugas-akhir/backend/pkg/logger"
        "tugas-akhir/backend/pkg/mock_payment"
)

type BasePlaceOrderUsecase struct {
        eventRepository   event.EventRepository
        orderRepository   order.OrderRepository
        bookingRepository booking.BookingRepository
        invoiceRepository invoice.InvoiceRepository
        paymentGateway    service.PaymentGateway
        redisAvailability *redis_availability_seeder.RedisAvailabilitySeeder
        db                *postgres.Postgres
}

func NewBasePlaceOrderUsecase(
        eventRepository event.EventRepository,
        orderRepository order.OrderRepository,
        bookingRepository booking.BookingRepository,
        invoiceRepository invoice.InvoiceRepository,
        paymentGateway service.PaymentGateway,
        redisAvailability *redis_availability_seeder.RedisAvailabilitySeeder,
        db *postgres.Postgres,
) *BasePlaceOrderUsecase <span class="cov4" title="4">{
        return &amp;BasePlaceOrderUsecase{
                eventRepository:   eventRepository,
                orderRepository:   orderRepository,
                bookingRepository: bookingRepository,
                invoiceRepository: invoiceRepository,
                paymentGateway:    paymentGateway,
                db:                db,
                redisAvailability: redisAvailability,
        }
}</span>

func (u *BasePlaceOrderUsecase) PlaceOrder(ctx context.Context, payload entity.PlaceOrderDto) (*entity.Order, *myerror.HttpError) <span class="cov4" title="6">{
        // retry transaction if needed
        l := logger.FromCtx(ctx)

        var order *entity.Order
        var httpErr *myerror.HttpError

        for i := 0; i &lt; 3; i++ </span><span class="cov4" title="6">{
                order, httpErr = u.placeOrder(ctx, payload)

                // try more
                if httpErr != nil &amp;&amp; httpErr.ErrorContext != nil </span><span class="cov0" title="0">{
                        // check for the error code

                        errCtx := httpErr.ErrorContext

                        var pgErr *pgconn.PgError

                        if errors.As(errCtx, &amp;pgErr) </span><span class="cov0" title="0">{
                                // PostgreSQL error codes for transaction related issue
                                // 40001 is the error code retry read
                                if pgErr.Code == "40001" </span><span class="cov0" title="0">{
                                        l.Warn("serializability error. restarting transactions ...")
                                        continue</span>
                                }
                        }
                }

                <span class="cov4" title="6">break</span>
        }

        <span class="cov4" title="6">return order, httpErr</span>
}

func (u *BasePlaceOrderUsecase) placeOrder(ctx context.Context, payload entity.PlaceOrderDto) (*entity.Order, *myerror.HttpError) <span class="cov4" title="6">{
        l := logger.FromCtx(ctx)

        if payload.UserID == nil </span><span class="cov0" title="0">{
                err := errors2.WithStack(errors2.WithMessage(entity3.InternalOrderConfigurationError, "user id is nil"))
                return nil, &amp;myerror.HttpError{
                        Code:         http.StatusInternalServerError,
                        Message:      err.Error(),
                        ErrorContext: err,
                }
        }</span>

        <span class="cov4" title="6">tx, err := u.db.Pool.Begin(ctx)

        if err != nil {
                return nil, &amp;myerror.HttpError{
                        Code:       </span><span class="cov0" title="0">  http.StatusInternalServerError,
                        Message:      err.Error(),
                        ErrorContext: err,
                }
        }

        d</span>efer tx.Rollback(ctx)

        <span class="cov4" title="6">ctx = context.WithValue(ctx, postgres.PostgresTransactionContextKey, tx)

        eventEntity, err := u.eventRepository.GetEvent(ctx, entity3.GetEventDto{
                ID: payload.EventID,
        })

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, entity3.EventNotFoundError) </span><span class="cov0" title="0">{
                        return nil, &amp;myerror.HttpError{
                                Code:    http.StatusBadRequest,
                                Message: err.Error(),
                        }
                }</span>

                <span class="cov0" title="0">return nil, &amp;myerror.HttpError{
                        Code:         http.StatusInternalServerError,
                        Message:      err.Error(),
                        ErrorContext: err,
                }</span>
        }

        // enrich payload data
        <span class="cov4" title="6">var ticketSale *entity3.TicketSale

        for _, sale := range eventEntity.TicketSales </span><span class="cov6" title="12">{
                if sale.ID == payload.TicketSaleID </span><span class="cov4" title="6">{
                        ticketSale = &amp;sale
                }</span>
        }

        <span class="cov4" title="6">if ticketSale == nil </span><span class="cov0" title="0">{
                return nil, &amp;myerror.HttpError{
                        Code:    http.StatusBadRequest,
                        Message: entity.TicketSaleNotFoundError.Error(),
                }
        }</span>

        // check for sale time

        <span class="cov4" title="6">now := time.Now()

        if now.Before(ticketSale.SaleBeginAt) </span><span class="cov0" title="0">{
                return nil, &amp;myerror.HttpError{
                        Code:    http.StatusBadRequest,
                        Message: entity.TicketSaleNotStartedError.Error(),
                }
        }</span>

        <span class="cov4" title="6">if now.After(ticketSale.SaleEndAt) </span><span class="cov0" title="0">{
                return nil, &amp;myerror.HttpError{
                        Code:    http.StatusBadRequest,
                        Message: entity.TicketSaleEndedError.Error(),
                }
        }</span>

        <span class="cov4" title="6">bookRequest := entity2.BookingRequestDto{
                SeatIDs:       []int64{},
                TicketAreaIDs: []int64{},
                TicketAreaID:  *payload.TicketAreaID,
        }

        for _, item := range payload.Items </span><span class="cov6" title="12">{
                if item.TicketSeatID != nil </span><span class="cov5" title="8">{
                        bookRequest.SeatIDs = append(bookRequest.SeatIDs, *item.TicketSeatID)
                }</span> else<span class="cov4" title="4"> {
                        bookRequest.TicketAreaIDs = append(bookRequest.TicketAreaIDs, item.TicketAreaID)
                }</span>
        }

        <span class="cov4" title="6">ticketSeats, err := u.bookingRepository.Book(ctx, bookRequest)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, entity2.LockNotAcquiredError) </span><span class="cov0" title="0">{
                        return nil, &amp;myerror.HttpError{
                                Code:    http.StatusConflict,
                                Message: err.Error(),
                        }
                }</span>

                <span class="cov0" title="0">return nil, &amp;myerror.HttpError{
                        Code:         http.StatusInternalServerError,
                        Message:      err.Error(),
                        ErrorContext: err,
                }</span>
        }

        <span class="cov4" title="6">payload.TicketAreaID = &amp;ticketSeats[0].TicketAreaID

        for _, ticketSeat := range ticketSeats </span><span class="cov6" title="12">{
                if *payload.TicketAreaID != ticketSeat.TicketAreaID </span><span class="cov0" title="0">{
                        return nil, &amp;myerror.HttpError{
                                Code:         http.StatusBadRequest,
                                Message:      entity.OrderSameAreaID.Error(),
                                ErrorContext: entity.OrderSameAreaID,
                        }
                }</span>
        }

        <span class="cov4" title="6">total := int32(0)

        takenSeat := make(map[int64]bool)

        appliedAvailability := make([]entity3.AreaAvailability, 0)

        // enrich item data
        for i, item := range payload.Items </span><span class="cov6" title="12">{
                availabilityUpdate := entity3.AreaAvailability{
                        TicketAreaID: item.TicketAreaID,
                        TicketSaleID: ticketSale.ID,
                }

                var seat *entity3.TicketSeat

                for _, s := range ticketSeats </span><span class="cov7" title="18">{
                        if item.TicketSeatID == nil </span><span class="cov4" title="6">{
                                // free seated
                                if item.TicketAreaID == s.TicketAreaID </span><span class="cov4" title="6">{
                                        _, ok := takenSeat[s.ID]

                                        if ok </span><span class="cov2" title="2">{
                                                continue</span>
                                        } else<span class="cov4" title="4"> {
                                                seat = &amp;s
                                                takenSeat[s.ID] = true
                                                break</span>
                                        }
                                }
                        } else<span class="cov6" title="12"> {
                                if *item.TicketSeatID == s.ID </span><span class="cov5" title="8">{
                                        seat = &amp;s
                                        break</span>
                                }
                        }
                }

                <span class="cov6" title="12">if seat == nil </span><span class="cov0" title="0">{
                        err := errors2.WithStack(errors2.WithMessage(entity3.InternalOrderConfigurationError, "seat is nil"))
                        return nil, &amp;myerror.HttpError{
                                Code:         http.StatusInternalServerError,
                                Message:      err.Error(),
                                ErrorContext: err,
                        }
                }</span>

                <span class="cov6" title="12">var priceSet = false

                for _, ticketPackage := range ticketSale.TicketPackages </span><span class="cov9" title="48">{
                        for _, area := range ticketPackage.TicketAreas </span><span class="cov10" title="60">{
                                if area.ID == seat.TicketAreaID </span><span class="cov6" title="12">{
                                        if area.Type == entity3.AreaType__NumberedSeating &amp;&amp; item.TicketSeatID == nil </span><span class="cov0" title="0">{
                                                err := errors2.WithStack(errors2.WithMessage(entity3.PlaceOrderBadRequest, "seat is numbered but no seat id given"))
                                                return nil, &amp;myerror.HttpError{
                                                        Code:         http.StatusBadRequest,
                                                        Message:      err.Error(),
                                                        ErrorContext: err,
                                                }
                                        }</span>

                                        <span class="cov6" title="12">if area.Type == entity3.AreaType__FreeStanding &amp;&amp; item.TicketSeatID != nil </span><span class="cov0" title="0">{
                                                err := errors2.WithStack(errors2.WithMessage(entity3.PlaceOrderBadRequest, "seat is free standing but seat id given"))
                                                return nil, &amp;myerror.HttpError{
                                                        Code:         http.StatusBadRequest,
                                                        Message:      err.Error(),
                                                        ErrorContext: err,
                                                }
                                        }</span>

                                        <span class="cov6" title="12">item.TicketCategoryID = &amp;ticketPackage.TicketCategoryID
                                        item.Price = &amp;ticketPackage.Price
                                        total += ticketPackage.Price
                                        priceSet = true
                                        availabilityUpdate.TicketPackageID = ticketPackage.ID</span>
                                }
                        }
                }

                <span class="cov6" title="12">item.TicketSeatID = &amp;seat.ID

                if !priceSet </span><span class="cov0" title="0">{
                        err := errors2.WithStack(errors2.WithMessage(entity3.InternalOrderConfigurationError, "cannot find area from given payload"))
                        return nil, &amp;myerror.HttpError{
                                Code:         http.StatusInternalServerError,
                                Message:      err.Error(),
                                ErrorContext: err,
                        }
                }</span>

                <span class="cov6" title="12">payload.Items[i] = item
                appliedAvailability = append(appliedAvailability, availabilityUpdate)</span>
        }

        <span class="cov4" title="6">orderEntity, err := u.orderRepository.PlaceOrder(ctx, payload)

        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;myerror.HttpError{
                        Code:         http.StatusInternalServerError,
                        Message:      err.Error(),
                        ErrorContext: err,
                }
        }</span>

        <span class="cov4" title="6">description := fmt.Sprintf("Ticket purchase for %s", eventEntity.Name)

        generatedInvoice, err := u.paymentGateway.GenerateInvoice(ctx, mock_payment.CreateInvoiceRequest{
                Amount:      float32(total),
                Description: &amp;description,
                ExternalId:  fmt.Sprintf("%d-%d", orderEntity.ID, orderEntity.TicketAreaID),
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;myerror.HttpError{
                        Code:         http.StatusInternalServerError,
                        Message:      err.Error(),
                        ErrorContext: err,
                }
        }</span>

        <span class="cov4" title="6">invoiceEntity, err := u.invoiceRepository.CreateInvoice(ctx, entity4.CreateInvoiceDto{
                Amount:       total,
                ExternalID:   generatedInvoice.Id,
                OrderID:      orderEntity.ID,
                TicketAreaID: *payload.TicketAreaID,
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;myerror.HttpError{
                        Code:         http.StatusInternalServerError,
                        Message:      err.Error(),
                        ErrorContext: err,
                }
        }</span>

        <span class="cov4" title="6">orderEntity.Invoice = invoiceEntity

        if err := tx.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;myerror.HttpError{
                        Code:         http.StatusInternalServerError,
                        Message:      err.Error(),
                        ErrorContext: err,
                }
        }</span>

        // Update the counter
        <span class="cov4" title="6">if availabilityUpdateErr := u.redisAvailability.ApplyAvailability(ctx, appliedAvailability); availabilityUpdateErr != nil </span><span class="cov0" title="0">{
                l.Sugar().Error(availabilityUpdateErr)
        }</span>

        <span class="cov4" title="6">return orderEntity, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package place_order

import (
        "context"
        errors2 "github.com/pkg/errors"
        "net/http"
        "time"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/internal/orders/entity"
        "tugas-akhir/backend/internal/orders/service/early_dropper"
        "tugas-akhir/backend/internal/orders/service/pgp_place_order_connector"
        myerror "tugas-akhir/backend/pkg/error"
        "tugas-akhir/backend/pkg/logger"
)

type FCPlaceOrderUsecase struct {
        config    *config.Config
        connector *pgp_place_order_connector.FCPlaceOrderConnector
        dropper   *early_dropper.EarlyDropper
}

func NewFCPlaceOrderUsecase(
        config *config.Config,
        connector *pgp_place_order_connector.FCPlaceOrderConnector,
        dropper *early_dropper.EarlyDropper,
) *FCPlaceOrderUsecase <span class="cov6" title="2">{

        return &amp;FCPlaceOrderUsecase{
                connector: connector,
                config:    config,
                dropper:   dropper,
        }
}</span>

func (u *FCPlaceOrderUsecase) PlaceOrder(ctx context.Context, payload entity.PlaceOrderDto) (*entity.Order, *myerror.HttpError) <span class="cov10" title="3">{
        lock, err := u.dropper.TryAcquireLock(ctx, payload)
        l := logger.FromCtx(ctx)

        if err != nil </span><span class="cov0" title="0">{
                err = errors2.Wrap(err, "source: early dropper")
                if errors2.Is(err, entity.DropperSeatNotAvailable) </span><span class="cov0" title="0">{
                        return nil, &amp;myerror.HttpError{
                                Code:    http.StatusConflict,
                                Message: err.Error(),
                        }
                }</span> else<span class="cov0" title="0"> if errors2.Is(err, entity.CannotAcquireLock) </span><span class="cov0" title="0">{
                        return nil, &amp;myerror.HttpError{
                                Code:    http.StatusLocked,
                                Message: err.Error(),
                        }
                }</span> else<span class="cov0" title="0"> {
                        return nil, &amp;myerror.HttpError{
                                Code:         http.StatusInternalServerError,
                                Message:      err.Error(),
                                ErrorContext: err,
                        }
                }</span>
        }

        // publish
        <span class="cov10" title="3">requestAmqpMessage := entity.PlaceOrderMessage{
                Data:       payload,
                ReplyRoute: u.connector.ReplyRouteName,
        }

        replyChan := make(chan entity.PlaceOrderReplyMessage, 1)
        u.connector.ListenerChan.Store(*payload.IdempotencyKey, replyChan)

        defer func() </span><span class="cov10" title="3">{
                u.connector.ListenerChan.Delete(*payload.IdempotencyKey)
                close(replyChan)
        }</span>()

        <span class="cov10" title="3">if err := u.connector.PublishRequest(ctx, requestAmqpMessage); err != nil </span><span class="cov0" title="0">{

                if releaseErr := lock.OnFailed(); releaseErr != nil </span><span class="cov0" title="0">{
                        l.Sugar().Error(releaseErr)
                }</span>

                <span class="cov0" title="0">return nil, &amp;myerror.HttpError{
                        Code:         http.StatusInternalServerError,
                        Message:      err.Error(),
                        ErrorContext: err,
                }</span>
        }

        <span class="cov10" title="3">select </span>{
        case reply := &lt;-replyChan:<span class="cov10" title="3">
                if reply.HttpErr == nil </span><span class="cov10" title="3">{
                        if releaseErr := lock.OnSuccess(); releaseErr != nil </span><span class="cov0" title="0">{
                                l.Sugar().Error(releaseErr)
                        }</span>
                } else<span class="cov0" title="0"> {
                        if releaseErr := lock.OnFailed(); releaseErr != nil </span><span class="cov0" title="0">{
                                l.Sugar().Error(releaseErr)
                        }</span>
                }

                <span class="cov10" title="3">return reply.Order, reply.HttpErr</span>
        case &lt;-time.After(entity.PlaceOrderTimeout + 2*time.Second):<span class="cov0" title="0">
                if releaseErr := lock.OnFailed(); releaseErr != nil </span><span class="cov0" title="0">{
                        l.Sugar().Error(releaseErr)
                }</span>
                <span class="cov0" title="0">return nil, &amp;myerror.HttpError{
                        Code:    http.StatusRequestTimeout,
                        Message: entity.PlaceOrderTimeoutError.Error(),
                }</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                if releaseErr := lock.OnFailed(); releaseErr != nil </span><span class="cov0" title="0">{
                        l.Sugar().Error(releaseErr)
                }</span>
                <span class="cov0" title="0">return nil, &amp;myerror.HttpError{
                        Code:         http.StatusInternalServerError,
                        Message:      entity.PlaceOrderCancelled.Error(),
                        ErrorContext: entity.PlaceOrderCancelled,
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package webhook

import (
        "context"
        "fmt"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/pkg/errors"
        "net/http"
        "tugas-akhir/backend/infrastructure/postgres"
        entity3 "tugas-akhir/backend/internal/bookings/entity"
        "tugas-akhir/backend/internal/bookings/repository/booked_seats"
        "tugas-akhir/backend/internal/bookings/repository/booking"
        entity4 "tugas-akhir/backend/internal/events/entity"
        "tugas-akhir/backend/internal/events/repository/event"
        "tugas-akhir/backend/internal/events/service/redis_availability_seeder"
        entity2 "tugas-akhir/backend/internal/orders/entity"
        "tugas-akhir/backend/internal/orders/repository/order"
        "tugas-akhir/backend/internal/orders/service/early_dropper"
        "tugas-akhir/backend/internal/payments/entity"
        "tugas-akhir/backend/internal/payments/repository/invoice"
        myerror "tugas-akhir/backend/pkg/error"
        "tugas-akhir/backend/pkg/logger"
        "tugas-akhir/backend/pkg/mock_payment"
        "tugas-akhir/backend/pkg/utility"
)

type PGWebhookUsecase struct {
        orderRepository         order.OrderRepository
        invoiceRepository       invoice.InvoiceRepository
        eventRepository         event.EventRepository
        bookeadSeatRepository   booked_seats.BookedSeatRepository
        bookingRepository       booking.BookingRepository
        redisAvailabilitySeeder *redis_availability_seeder.RedisAvailabilitySeeder
        db                      *postgres.Postgres
        earlyDropper            *early_dropper.EarlyDropper
}

func NewPGWebhookUsecase(
        orderRepository order.OrderRepository,
        invoiceRepository invoice.InvoiceRepository,
        bookeadSeatRepository booked_seats.BookedSeatRepository,
        bookingRepository booking.BookingRepository,
        eventRepository event.EventRepository,
        redisAvailabilitySeeder *redis_availability_seeder.RedisAvailabilitySeeder,
        db *postgres.Postgres,
) *PGWebhookUsecase <span class="cov4" title="2">{
        return &amp;PGWebhookUsecase{
                orderRepository:         orderRepository,
                invoiceRepository:       invoiceRepository,
                bookeadSeatRepository:   bookeadSeatRepository,
                eventRepository:         eventRepository,
                db:                      db,
                bookingRepository:       bookingRepository,
                redisAvailabilitySeeder: redisAvailabilitySeeder,
        }
}</span>

func NewFCWebhookUsecase(
        orderRepository order.OrderRepository,
        invoiceRepository invoice.InvoiceRepository,
        bookeadSeatRepository booked_seats.BookedSeatRepository,
        bookingRepository booking.BookingRepository,
        eventRepository event.EventRepository,
        redisAvailabilitySeeder *redis_availability_seeder.RedisAvailabilitySeeder,
        db *postgres.Postgres,
        earlyDropper *early_dropper.EarlyDropper,
) *PGWebhookUsecase <span class="cov4" title="2">{
        return &amp;PGWebhookUsecase{
                orderRepository:         orderRepository,
                invoiceRepository:       invoiceRepository,
                bookeadSeatRepository:   bookeadSeatRepository,
                eventRepository:         eventRepository,
                db:                      db,
                bookingRepository:       bookingRepository,
                redisAvailabilitySeeder: redisAvailabilitySeeder,
                earlyDropper:            earlyDropper,
        }
}</span>

func (u *PGWebhookUsecase) HandleWebhook(ctx context.Context, payload mock_payment.Invoice) *myerror.HttpError <span class="cov10" title="6">{
        // retry transaction if needed
        l := logger.FromCtx(ctx)

        var httpErr *myerror.HttpError

        for i := 0; i &lt; 3; i++ </span><span class="cov10" title="6">{
                httpErr = u.handleWebhook(ctx, payload)

                // try more
                if httpErr != nil &amp;&amp; httpErr.ErrorContext != nil </span><span class="cov10" title="6">{
                        // check for the error code

                        errCtx := httpErr.ErrorContext

                        var pgErr *pgconn.PgError

                        if errors.As(errCtx, &amp;pgErr) </span><span class="cov0" title="0">{
                                // PostgreSQL error codes for transaction related issue
                                // 40001 is the error code retry read
                                if pgErr.Code == "40001" </span><span class="cov0" title="0">{
                                        l.Warn("serializability error. restarting transactions ...")
                                        continue</span>
                                }
                        }
                }

                <span class="cov10" title="6">break</span>
        }

        <span class="cov10" title="6">return httpErr</span>
}

func (u *PGWebhookUsecase) handleWebhook(ctx context.Context, payload mock_payment.Invoice) *myerror.HttpError <span class="cov10" title="6">{
        orderID, ticketAreaID, err := utility.ParseNumberString(payload.ExternalId)

        if err != nil </span><span class="cov10" title="6">{
                err := errors.WithStack(errors.WithMessage(entity2.WebhookInternalError, fmt.Sprintf("cannot parse order id %s", payload.ExternalId)))
                return &amp;myerror.HttpError{
                        Code:         http.StatusBadRequest,
                        Message:      err.Error(),
                        ErrorContext: err,
                }
        }</span>

        <span class="cov0" title="0">orderEntity, err := u.orderRepository.GetOrder(ctx, entity2.GetOrderDto{
                OrderID:      orderID,
                TicketAreID:  ticketAreaID,
                BypassUserID: true,
        })

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, entity2.OrderNotFoundError) </span><span class="cov0" title="0">{
                        return &amp;myerror.HttpError{
                                Code:    http.StatusNotFound,
                                Message: err.Error(),
                        }
                }</span>

                <span class="cov0" title="0">return &amp;myerror.HttpError{
                        Code:         http.StatusInternalServerError,
                        Message:      err.Error(),
                        ErrorContext: err,
                }</span>
        }

        <span class="cov0" title="0">tx, err := u.db.Pool.Begin(ctx)

        defer tx.Rollback(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return &amp;myerror.HttpError{
                        Code:         http.StatusInternalServerError,
                        Message:      err.Error(),
                        ErrorContext: err,
                }
        }</span>

        <span class="cov0" title="0">ctx = context.WithValue(ctx, postgres.PostgresTransactionContextKey, tx)

        updateInvoice := entity.UpdateInvoiceStatusDto{
                ID:           orderEntity.Invoice.ID,
                TicketAreaID: orderEntity.TicketAreaID,
        }

        updateOrder := entity2.UpdateOrderStatusDto{
                OrderID:      orderID,
                TicketAreaID: orderEntity.TicketAreaID,
        }

        shouldPublish := false

        if payload.Status == "expired" </span><span class="cov0" title="0">{
                failReason := "payment expired"
                updateOrder.FailReason = &amp;failReason
                updateOrder.Status = entity2.OrderStatus__Failed
                updateInvoice.Status = entity.InvoiceStatus__Expired
        }</span> else<span class="cov0" title="0"> if payload.Status == "paid" </span><span class="cov0" title="0">{
                updateOrder.Status = entity2.OrderStatus__Success
                updateInvoice.Status = entity.InvoiceStatus__Paid
                shouldPublish = true
        }</span> else<span class="cov0" title="0"> if payload.Status == "failed" </span><span class="cov0" title="0">{
                failReason := "payment failed"
                updateOrder.FailReason = &amp;failReason
                updateOrder.Status = entity2.OrderStatus__Failed
                updateInvoice.Status = entity.InvoiceStatus__Failed
        }</span> else<span class="cov0" title="0"> {
                err := errors.WithStack(errors.WithMessage(entity2.WebhookInternalError, fmt.Sprintf("unexpected status %s", payload.Status)))
                return &amp;myerror.HttpError{
                        Code:         http.StatusBadRequest,
                        Message:      err.Error(),
                        ErrorContext: err,
                }
        }</span>

        <span class="cov0" title="0">err = u.invoiceRepository.UpdateInvoiceStatus(ctx, updateInvoice)

        if err != nil </span><span class="cov0" title="0">{
                return &amp;myerror.HttpError{
                        Code:         http.StatusInternalServerError,
                        Message:      err.Error(),
                        ErrorContext: err,
                }
        }</span>

        <span class="cov0" title="0">err = u.orderRepository.UpdateOrderStatus(ctx, updateOrder)

        if err != nil </span><span class="cov0" title="0">{
                return &amp;myerror.HttpError{
                        Code:         http.StatusInternalServerError,
                        Message:      err.Error(),
                        ErrorContext: err,
                }
        }</span>

        <span class="cov0" title="0">seatIDs := make([]int64, 0)

        for _, item := range orderEntity.Items </span><span class="cov0" title="0">{
                seatIDs = append(seatIDs, item.TicketSeatID)
        }</span>

        <span class="cov0" title="0">if shouldPublish </span><span class="cov0" title="0">{
                if u.earlyDropper != nil </span><span class="cov0" title="0">{
                        err = u.earlyDropper.FinalizeLock(ctx, orderEntity.Items, entity4.SeatStatus__Sold)

                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;myerror.HttpError{
                                        Code:         http.StatusInternalServerError,
                                        Message:      err.Error(),
                                        ErrorContext: err,
                                }
                        }</span>
                }

                <span class="cov0" title="0">err = u.bookingRepository.UpdateSeatStatus(ctx, entity3.UpdateSeatStatusDto{
                        SeatIDs:      seatIDs,
                        TicketAreaID: orderEntity.TicketAreaID,
                        Status:       entity4.SeatStatus__Sold,
                })

                if err != nil </span><span class="cov0" title="0">{
                        return &amp;myerror.HttpError{
                                Code:         http.StatusInternalServerError,
                                Message:      err.Error(),
                                ErrorContext: err,
                        }
                }</span>

                <span class="cov0" title="0">seatInfo := make([]entity3.SeatInfoDto, 0)

                for _, item := range orderEntity.Items </span><span class="cov0" title="0">{
                        seatInfo = append(seatInfo, entity3.SeatInfoDto{
                                CategoryName: item.TicketCategory.Name,
                                SeatType:     item.TicketSeat.TicketArea.Type,
                                SeatNumber:   item.TicketSeat.SeatNumber,
                        })
                }</span>

                <span class="cov0" title="0">err = u.bookeadSeatRepository.PublishIssuedTickets(ctx, entity3.PublishIssuedTicketDto{
                        EventName:      fmt.Sprintf("%s - %s", orderEntity.Event.Name, orderEntity.Event.Location),
                        TicketSaleName: orderEntity.TicketSale.Name,
                        SeatInfos:      seatInfo,
                        Items:          orderEntity.Items,
                        TicketAreaID:   orderEntity.TicketAreaID,
                })

                if err != nil </span><span class="cov0" title="0">{
                        return &amp;myerror.HttpError{
                                Code:         http.StatusInternalServerError,
                                Message:      err.Error(),
                                ErrorContext: err,
                        }
                }</span>
        } else<span class="cov0" title="0"> {
                err = u.bookingRepository.UpdateSeatStatus(ctx, entity3.UpdateSeatStatusDto{
                        SeatIDs:      seatIDs,
                        TicketAreaID: orderEntity.TicketAreaID,
                        Status:       entity4.SeatStatus__Available,
                })

                if err != nil </span><span class="cov0" title="0">{
                        return &amp;myerror.HttpError{
                                Code:         http.StatusInternalServerError,
                                Message:      err.Error(),
                                ErrorContext: err,
                        }
                }</span>

                <span class="cov0" title="0">revertedAvailability := make([]entity4.AreaAvailability, 0)

                for _, item := range orderEntity.Items </span><span class="cov0" title="0">{
                        revertedAvailability = append(revertedAvailability, entity4.AreaAvailability{
                                TicketAreaID:    item.TicketSeat.TicketAreaID,
                                TicketPackageID: item.TicketSeat.TicketArea.TicketPackageID,
                                TicketSaleID:    orderEntity.TicketSaleID,
                        })
                }</span>

                <span class="cov0" title="0">if u.earlyDropper != nil </span><span class="cov0" title="0">{
                        err = u.earlyDropper.FinalizeLock(ctx, orderEntity.Items, entity4.SeatStatus__Available)

                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;myerror.HttpError{
                                        Code:         http.StatusInternalServerError,
                                        Message:      err.Error(),
                                        ErrorContext: err,
                                }
                        }</span>
                }

                <span class="cov0" title="0">err = u.redisAvailabilitySeeder.RevertAvailability(ctx, revertedAvailability)

                if err != nil </span><span class="cov0" title="0">{
                        return &amp;myerror.HttpError{
                                Code:         http.StatusInternalServerError,
                                Message:      err.Error(),
                                ErrorContext: err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if err := tx.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                return &amp;myerror.HttpError{
                        Code:         http.StatusInternalServerError,
                        Message:      err.Error(),
                        ErrorContext: err,
                }
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package entity

import "errors"

type InvoiceStatus string

const (
        InvoiceStatus__Pending InvoiceStatus = "pending"
        InvoiceStatus__Expired InvoiceStatus = "expired"
        InvoiceStatus__Failed  InvoiceStatus = "failed"
        InvoiceStatus__Paid    InvoiceStatus = "paid"
)

func (e *InvoiceStatus) Scan(value interface{}) error <span class="cov10" title="6">{
        var enumValue string
        switch val := value.(type) </span>{
        case string:<span class="cov10" title="6">
                enumValue = val</span>
        case []byte:<span class="cov0" title="0">
                enumValue = string(val)</span>
        default:<span class="cov0" title="0">
                return errors.New("invalid scan value for InvoiceStatus enum. Enum value has to be of type string or []byte")</span>
        }

        <span class="cov10" title="6">switch enumValue </span>{
        case "pending":<span class="cov10" title="6">
                *e = InvoiceStatus__Pending</span>
        case "expired":<span class="cov0" title="0">
                *e = InvoiceStatus__Expired</span>
        case "paid":<span class="cov0" title="0">
                *e = InvoiceStatus__Paid</span>
        default:<span class="cov0" title="0">
                return errors.New("invalid scan value '" + enumValue + "' for InvoiceStatus enum")</span>
        }

        <span class="cov10" title="6">return nil</span>
}

func (e *InvoiceStatus) Value() string <span class="cov0" title="0">{
        return string(*e)
}</span>

func (e *InvoiceStatus) String() string <span class="cov0" title="0">{
        return string(*e)
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package invoice

import (
        "context"
        "github.com/georgysavva/scany/v2/pgxscan"
        "github.com/pkg/errors"
        "tugas-akhir/backend/infrastructure/postgres"
        "tugas-akhir/backend/internal/payments/entity"
)

type PGInvoiceRepository struct {
        db *postgres.Postgres
}

func NewPGInvoiceRepository(db *postgres.Postgres) *PGInvoiceRepository <span class="cov7" title="4">{
        return &amp;PGInvoiceRepository{
                db: db,
        }
}</span>

func (r *PGInvoiceRepository) CreateInvoice(ctx context.Context, payload entity.CreateInvoiceDto) (*entity.Invoice, error) <span class="cov10" title="6">{
        query := `
        INSERT INTO invoices(status, amount, external_id, order_id, ticket_area_id)
        VALUES ('pending', $1, $2, $3, $4)
        RETURNING id, status, amount, external_id, order_id, created_at, updated_at
    `

        var invoice entity.Invoice

        err := pgxscan.Get(ctx, r.db.GetExecutor(ctx), &amp;invoice, query, payload.Amount, payload.ExternalID, payload.OrderID, payload.TicketAreaID)

        if err != nil </span><span class="cov0" title="0">{
                if pgxscan.NotFound(err) </span><span class="cov0" title="0">{
                        return nil, errors.WithMessage(entity.CreateInvoiceInternalError, "no invoice returned")
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov10" title="6">return &amp;invoice, nil</span>
}

func (r *PGInvoiceRepository) UpdateInvoiceStatus(ctx context.Context, payload entity.UpdateInvoiceStatusDto) error <span class="cov0" title="0">{
        query := `
        UPDATE invoices
        SET status = $1, updated_at = now()
        WHERE id = $2 AND ticket_area_id = $3
    `

        _, err := r.db.GetExecutor(ctx).Exec(ctx, query, payload.Status, payload.ID, payload.TicketAreaID)

        return err
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package service

import (
        "context"
        "crypto/tls"
        "crypto/x509"
        "github.com/pkg/errors"
        "golang.org/x/net/http2"
        "net/http"
        "net/url"
        "os"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/internal/payments/entity"
        "tugas-akhir/backend/pkg/mock_payment"
)

type PaymentGatewayExt struct {
        mockPayment *mock_payment.APIClient
        protocol    string
        baseHost    string
}

func NewPaymentGatewayExt(config *config.Config) (*PaymentGatewayExt, error) <span class="cov0" title="0">{
        caCertPool := x509.NewCertPool()

        certData, err := os.ReadFile(config.PaymentCertPath)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if ok := caCertPool.AppendCertsFromPEM(certData); !ok </span><span class="cov0" title="0">{
                return nil, errors.WithStack(errors.WithMessage(entity.PaymentServiceInternalError, "failed to append cert to pool"))
        }</span>

        // Create a custom transport with HTTP/2 support
        <span class="cov0" title="0">transport := &amp;http.Transport{
                TLSClientConfig: &amp;tls.Config{
                        RootCAs: caCertPool,
                },
        }

        // Explicitly enable HTTP/2
        err = http2.ConfigureTransport(transport)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create custom HTTP client with the transport
        <span class="cov0" title="0">httpClient := &amp;http.Client{
                Transport: transport,
        }

        // Configure your API client to use this custom HTTP client
        cfg := mock_payment.NewConfiguration()
        cfg.HTTPClient = httpClient

        mockPayment := mock_payment.NewAPIClient(cfg)

        // Validate base URL
        parsedURL, err := url.Parse(config.PaymentServiceUrl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.WithStack(errors.WithMessage(entity.PaymentServiceInternalError, "failed to parse payment service url"))
        }</span>

        <span class="cov0" title="0">return &amp;PaymentGatewayExt{
                mockPayment: mockPayment,
                protocol:    parsedURL.Scheme,
                baseHost:    parsedURL.Host + parsedURL.Path,
        }, nil</span>
}

func (s *PaymentGatewayExt) GenerateInvoice(ctx context.Context, payload mock_payment.CreateInvoiceRequest) (*mock_payment.Invoice, error) <span class="cov0" title="0">{
        ctx = context.WithValue(context.Background(), mock_payment.ContextServerVariables, map[string]string{
                "protocol": s.protocol,
                "server":   s.baseHost,
        })

        request := s.mockPayment.DefaultAPI.InvoicesPost(ctx)

        invoiceRequest := mock_payment.NewCreateInvoiceRequest(payload.Amount, payload.ExternalId)
        invoiceRequest.Description = payload.Description

        request = request.CreateInvoiceRequest(*invoiceRequest)

        invoice, _, err := request.Execute()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return invoice, nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package service

import (
        "context"
        "time"
        "tugas-akhir/backend/pkg/mock_payment"
)

type PaymentGatewayMock struct {
}

func NewPaymentGatewayMock() (*PaymentGatewayMock, error) <span class="cov7" title="4">{
        return &amp;PaymentGatewayMock{}, nil
}</span>

func (s *PaymentGatewayMock) GenerateInvoice(ctx context.Context, payload mock_payment.CreateInvoiceRequest) (*mock_payment.Invoice, error) <span class="cov10" title="6">{
        now := time.Now().String()
        exp := time.Now().Add(30 * time.Minute).String()
        return &amp;mock_payment.Invoice{
                Id:         "1",
                Amount:     payload.Amount,
                ExternalId: payload.ExternalId,
                CreatedAt:  *mock_payment.NewNullableString(&amp;now),
                ExpiredAt:  *mock_payment.NewNullableString(&amp;exp),
                Status:     "pending",
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package seeder

import (
        "context"
        "fmt"
        "time"
        "tugas-akhir/backend/infrastructure/postgres"
        "tugas-akhir/backend/pkg/logger"

        "github.com/jackc/pgx/v5"
)

type CategoryPayload struct {
        Name        string
        Price       int
        AreaCount   int
        SeatPerArea int
}

type SeederPayload struct {
        DayCount               int
        SeatedCategories       []CategoryPayload
        FreeStandingCategories []CategoryPayload
}

type CaseSeeder struct {
        db *postgres.Postgres
}

func NewCaseSeeder(db *postgres.Postgres) *CaseSeeder <span class="cov3" title="11">{
        return &amp;CaseSeeder{
                db: db,
        }
}</span>

const seatBatchSize = 500

func (c *CaseSeeder) Seed(ctx context.Context, payload SeederPayload) (err error) <span class="cov3" title="11">{
        l := logger.FromCtx(ctx)

        // Start transaction
        tx, err := c.db.Pool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>

        // Ensure rollback on error or panic, commit on success
        <span class="cov3" title="11">defer func() </span><span class="cov3" title="11">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        _ = tx.Rollback(ctx)
                        panic(r)</span>
                } else<span class="cov3" title="11"> if err != nil </span><span class="cov0" title="0">{
                        if rbErr := tx.Rollback(ctx); rbErr != nil </span><span class="cov0" title="0">{
                                err = fmt.Errorf("seed error: %w; rollback error: %w", err, rbErr)
                                l.Sugar().Error(err)
                        }</span> else<span class="cov0" title="0"> {
                                l.Sugar().Error(err)
                        }</span>
                } else<span class="cov3" title="11"> {
                        err = tx.Commit(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                err = fmt.Errorf("failed to commit transaction: %w", err)
                                l.Sugar().Error(err)
                        }</span>
                }
        }()

        // --- 1. Create Event ---
        <span class="cov3" title="11">var eventID int64
        err = tx.QueryRow(ctx, `
                INSERT INTO events (name, location, description)
                VALUES ($1, $2, $3)
                RETURNING id
        `, "Music World Tour", "Gelora Bung Karno Stadium", "").Scan(&amp;eventID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert event: %w", err)
        }</span>
        <span class="cov3" title="11">l.Sugar().Infof("Created event with ID: %d", eventID)

        // --- 2. Create Ticket Categories ---
        categoryIDs := make(map[string]int64)
        allCategories := append([]CategoryPayload{}, payload.SeatedCategories...)
        allCategories = append(allCategories, payload.FreeStandingCategories...)

        for _, catPayload := range allCategories </span><span class="cov4" title="42">{
                var categoryID int64
                err = tx.QueryRow(ctx, `
                        INSERT INTO ticket_categories (name, event_id)
                        VALUES ($1, $2)
                        RETURNING id
                `, catPayload.Name, eventID).Scan(&amp;categoryID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to insert ticket category '%s': %w", catPayload.Name, err)
                }</span>
                <span class="cov4" title="42">categoryIDs[catPayload.Name] = categoryID
                l.Sugar().Infof("Created category '%s' with ID: %d", catPayload.Name, categoryID)</span>
        }

        // --- 3. Create Ticket Sales ---
        <span class="cov3" title="11">var ticketSaleID int64
        saleBeginAt := time.Now()
        saleEndAt := saleBeginAt.AddDate(0, 0, 7)

        for i := 1; i &lt;= payload.DayCount; i++ </span><span class="cov3" title="21">{
                saleName := fmt.Sprintf("Day %d", i)

                err = tx.QueryRow(ctx, `
                INSERT INTO ticket_sales (name, sale_begin_at, sale_end_at, event_id)
                VALUES ($1, $2, $3, $4)
                RETURNING id
        `, saleName, saleBeginAt, saleEndAt, eventID).Scan(&amp;ticketSaleID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to insert ticket sale '%s': %w", saleName, err)
                }</span>
                <span class="cov3" title="21">l.Sugar().Infof("Created ticket sale '%s' with ID: %d (Ends: %s)", saleName, ticketSaleID, saleEndAt.Format(time.RFC3339))

                // --- Prepare for batch seat insertion ---
                seatData := make([][]interface{}, 0, seatBatchSize)
                totalSeatsCreated := 0

                // --- 4. Create Ticket Packages, Areas, and Seats (Batched) ---

                // --- Handle Seated Categories ---
                //fmt.Println("Processing Seated Categories...")
                for _, catPayload := range payload.SeatedCategories </span><span class="cov4" title="41">{
                        categoryID, ok := categoryIDs[catPayload.Name]
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("internal error: category ID for '%s' not found", catPayload.Name)
                        }</span>

                        // Create Ticket Package
                        <span class="cov4" title="41">var ticketPackageID int64
                        err = tx.QueryRow(ctx, `
                        INSERT INTO ticket_packages (price, ticket_category_id, ticket_sale_id)
                        VALUES ($1, $2, $3)
                        RETURNING id
                `, catPayload.Price, categoryID, ticketSaleID).Scan(&amp;ticketPackageID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to insert ticket package for seated category '%s': %w", catPayload.Name, err)
                        }</span>
                        <span class="cov4" title="41">l.Sugar().Infof("Created package for seated category '%s' with ID: %d", catPayload.Name, ticketPackageID)

                        // Create Ticket Areas and Seats for this package
                        for areaIdx := 0; areaIdx &lt; catPayload.AreaCount; areaIdx++ </span><span class="cov4" title="42">{
                                // Create Ticket Area
                                var ticketAreaID int64
                                err = tx.QueryRow(ctx, `
                                INSERT INTO ticket_areas (type, ticket_package_id)
                                VALUES ($1, $2)
                                RETURNING id
                        `, "numbered-seating", ticketPackageID).Scan(&amp;ticketAreaID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to insert numbered-seating area %d for package %d: %w", areaIdx+1, ticketPackageID, err)
                                }</span>
                                <span class="cov4" title="42">l.Sugar().Infof("Created numbered-seating area with ID: %d", ticketAreaID)

                                // Prepare seats for batch insert
                                for seatIdx := 0; seatIdx &lt; catPayload.SeatPerArea; seatIdx++ </span><span class="cov8" title="7020">{
                                        seatNumber := fmt.Sprintf("S-%d-%d", areaIdx+1, seatIdx+1)
                                        seatData = append(seatData, []interface{}{
                                                seatNumber,
                                                "available", // default status
                                                ticketAreaID,
                                        })

                                        // If batch is full, insert it
                                        if len(seatData) &gt;= seatBatchSize </span><span class="cov0" title="0">{
                                                count, insertErr := insertSeatBatch(ctx, tx, seatData)
                                                if insertErr != nil </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("failed to batch insert seats (seated): %w", insertErr)
                                                }</span>
                                                <span class="cov0" title="0">totalSeatsCreated += int(count)
                                                l.Sugar().Infof("Inserted batch of %d seats (Total: %d)", count, totalSeatsCreated)
                                                seatData = seatData[:0]</span> // Clear the batch slice
                                        }
                                } // End seat loop
                        } // End area loop
                } // End seated category loop

                // --- Handle Free Standing Categories ---
                //fmt.Println("Processing Free Standing Categories...")
                <span class="cov3" title="21">for _, catPayload := range payload.FreeStandingCategories </span><span class="cov4" title="41">{
                        categoryID, ok := categoryIDs[catPayload.Name]
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("internal error: category ID for '%s' not found", catPayload.Name)
                        }</span>

                        // Create Ticket Package
                        <span class="cov4" title="41">var ticketPackageID int64
                        err = tx.QueryRow(ctx, `
                        INSERT INTO ticket_packages (price, ticket_category_id, ticket_sale_id)
                        VALUES ($1, $2, $3)
                        RETURNING id
                `, catPayload.Price, categoryID, ticketSaleID).Scan(&amp;ticketPackageID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to insert ticket package for free-standing category '%s': %w", catPayload.Name, err)
                        }</span>
                        <span class="cov4" title="41">l.Sugar().Infof("Created package for free-standing category '%s' with ID: %d", catPayload.Name, ticketPackageID)

                        // Create Ticket Areas and Seats for this package
                        for areaIdx := 0; areaIdx &lt; catPayload.AreaCount; areaIdx++ </span><span class="cov4" title="62">{
                                // Create Ticket Area
                                var ticketAreaID int64
                                err = tx.QueryRow(ctx, `
                                INSERT INTO ticket_areas (type, ticket_package_id)
                                VALUES ($1, $2)
                                RETURNING id
                        `, "free-standing", ticketPackageID).Scan(&amp;ticketAreaID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to insert free-standing area %d for package %d: %w", areaIdx+1, ticketPackageID, err)
                                }</span>
                                <span class="cov4" title="62">l.Sugar().Infof("Created free-standing area with ID: %d", ticketAreaID)

                                // Prepare seats (conceptual spots) for batch insert
                                for seatIdx := 0; seatIdx &lt; catPayload.SeatPerArea; seatIdx++ </span><span class="cov10" title="46040">{
                                        seatNumber := fmt.Sprintf("FS-%d-%d", areaIdx+1, seatIdx+1) // Use a distinct naming scheme
                                        seatData = append(seatData, []interface{}{
                                                seatNumber,
                                                "available", // default status
                                                ticketAreaID,
                                        })

                                        // If batch is full, insert it
                                        if len(seatData) &gt;= seatBatchSize </span><span class="cov4" title="100">{
                                                count, insertErr := insertSeatBatch(ctx, tx, seatData)
                                                if insertErr != nil </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("failed to batch insert seats (free-standing): %w", insertErr)
                                                }</span>
                                                <span class="cov4" title="100">totalSeatsCreated += int(count)
                                                l.Sugar().Infof("Inserted batch of %d spots (Total: %d)", count, totalSeatsCreated)
                                                seatData = seatData[:0]</span> // Clear the batch slice
                                        }
                                } // End seat loop
                        } // End area loop
                } // End free-standing category loop

                // --- 5. Insert any remaining seats in the last batch ---
                <span class="cov3" title="21">if len(seatData) &gt; 0 </span><span class="cov3" title="21">{
                        count, insertErr := insertSeatBatch(ctx, tx, seatData)
                        if insertErr != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to batch insert remaining seats/spots: %w", insertErr)
                        }</span>
                        <span class="cov3" title="21">totalSeatsCreated += int(count)
                        l.Sugar().Infof("Inserted final batch of %d seats/spots (Grand Total: %d)", count, totalSeatsCreated)</span>
                }

        }

        <span class="cov3" title="11">l.Info("Seeding completed successfully.")
        // Transaction commit/rollback is handled by the defer function

        return nil</span> // err is nil if commit is successful
}

// Helper function for batch inserting seats using CopyFrom
func insertSeatBatch(ctx context.Context, tx pgx.Tx, seatData [][]interface{}) (int64, error) <span class="cov5" title="121">{
        if len(seatData) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov5" title="121">copyCount, err := tx.CopyFrom(
                ctx,
                pgx.Identifier{"ticket_seats"},
                []string{"seat_number", "status", "ticket_area_id"}, // Column order must match seatData structure
                pgx.CopyFromRows(seatData),
        )

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("copyFrom failed: %w", err)
        }</span>

        // Verify copyCount matches expected batch size
        <span class="cov5" title="121">if copyCount != int64(len(seatData)) </span><span class="cov0" title="0">{
                // This indicates a potential issue, treat as an error.
                return copyCount, fmt.Errorf("copyFrom reported inserting %d rows, but expected %d", copyCount, len(seatData))
        }</span>

        <span class="cov5" title="121">return copyCount, nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package seeder

import (
        "context"
        _ "embed"
        "strings"
        "tugas-akhir/backend/infrastructure/postgres"
)

//go:embed schemas/schema_up.sql
var SchemaUp string

//go:embed schemas/schema_down.sql
var SchemaDown string

//go:embed schemas/citus_setup.sql
var CitusSetup string

//go:embed schemas/pg_prewarm.sql
var Prewarm string

//go:embed schemas/extension_setup.sql
var ExtensionSetup string

//go:embed schemas/yugabyte_prewarm.sql
var YugabytePrewarm string

//go:embed schemas/yugabyte_up.sql
var YugabyteSchemaUp string

type SchemaManager struct {
        db *postgres.Postgres
}</span>

func NewSchemaManager(db *postgres.Postgres) *SchemaManager <span class="cov7" title="11">{
        return &amp;SchemaManager{
                db: db,
        </span>}
}

func (m *SchemaManager) SchemaUp(ctx context.Context) error {
        _, err := m.db.Pool.Exec(ctx, SchemaUp)
        </span>return err
}

func (m *SchemaManager) YugabyteSchemaUp(ctx context.Context) error {
        _, err := m.db.Pool.Exec(ctx, YugabyteSchemaUp)
        </span>return err
}

func (m *SchemaManager) ExtensionSetup(ctx context.Context) error </span><span class="cov10" title="22">{
        _, err := m.db.Pool.Exec(ctx, ExtensionSetup)
        return err
}
</span>
fun</span>c (m *SchemaManager) SchemaDown(ctx context.Context) error {
        _, err := m.db.Pool.Exec(ctx, SchemaDown)
        return err
}<span class="cov7" title="11">
</span>
func (m *SchemaManager) CitusSetup(ctx context.Context) error {
        for _, cmd := range strings.Split(CitusSetup, "-- marker s<span class="cov0" title="0">plit") {
                _, err := m.db.Pool.Exec(ctx, cmd)

        </span>        if err != nil {
                        return err
                }
        }

        return nil
}

func (m *SchemaManager) Prewarm(ctx context.Context) error {
        _, err := m.db.Pool.Exec(ctx, Prewarm)
        return err
}

func (m *SchemaManager) YugabytePrewarm(ctx context.Context) error {
        _, err := m.db.Pool.Exec(ctx, YugabytePrewarm)
        return err
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package seeder

import (
        "context"
        "fmt"
        "github.com/docker/go-connections/nat"
        "github.com/stretchr/testify/require"
        "testing"
        "tugas-akhir/backend/infrastructure/config"
        "tugas-akhir/backend/infrastructure/postgres"
        test_containers "tugas-akhir/backend/test-containers"
)

func GetConnAndSchema(t *testing.T, variant test_containers.RelationalDBVariant) *postgres.Postgres <span class="cov10" title="11">{
        ctx := t.Context()
        container, err := test_containers.NewRelationalDB(ctx, variant)
        require.NoError(t, err)
        container.Cleanup(t)

        host, err := container.Host(ctx)
        require.NoError(t, err)

        var port nat.Port

        if variant == test_containers.RelationalDBVariant__YugabyteDB </span><span class="cov0" title="0">{
                port, err = container.MappedPort(ctx, "5433/tcp")
                require.NoError(t, err)
        }</span> else<span class="cov10" title="11"> {
                port, err = container.MappedPort(ctx, "5432/tcp")
                require.NoError(t, err)
        }</span>

        <span class="cov10" title="11">conf := config.Config{
                DatabaseUrl: fmt.Sprintf("postgresql://%s:%s@%s:%s/%s", test_containers.TestDBUser, test_containers.TestDBPassword, host, port.Port(), test_containers.TestDBName),
        }

        conn, err := postgres.NewPostgres(&amp;conf)
        require.NoError(t, err)

        schemaManager := NewSchemaManager(conn)

        if variant != test_containers.RelationalDBVariant__YugabyteDB {
                require.NoError(t, schemaManager.SchemaUp(ctx))
        } else {
</span>                require.NoError(t, schemaManager.YugabyteSchemaUp(ctx))
        }</span>

        <span class="cov10" title="11">if variant </span>== test_containers.RelationalDBVariant__Citus {
                require.NoError(t, schemaManager.CitusSetup(ctx))
        }

        return conn
}

func SeedSchema(t *testing.T, ctx context.Context, conn *postgres.Postgres) {
        seeder := NewCaseSeeder(conn)

        payload := SeederPayload{
                DayCount: 2,
                SeatedCategories: []CategoryPayload{
                        {Name: "Grandstand Row A-E", Price: 750000, AreaCount: 1, SeatPerArea: 100},
                        {Name: "Grandstand Row F-M", Price: 500000, AreaCount: 1, SeatPerArea: 250},
                },
                FreeStandingCategories: []CategoryPayload{
                        {Name: "Front Stage Pit", Price: 600000, AreaCount: 1, SeatPerArea: 300},
                        {Name: "General Lawn Area", Price: 300000, AreaCount: 2, SeatPerArea: 1000},
                },
        }

        require.NoError(t, seeder.Seed(ctx, payload))

        // Check for inserted rows from various tables

        // 1. Check events table - should have 1 event
        var eventCount int
        err := conn.Pool.QueryRow(ctx, "SELECT COUNT(*) FROM events").Scan(&amp;eventCount)
        require.NoError(t, err)
        require.Equal(t, 1, eventCount, "Expected 1 event to be created")

        // 2. Check ticket_categories table - should have 4 categories (2 seated + 2 free-standing)
        var categoryCount int
        err = conn.Pool.QueryRow(ctx, "SELECT COUNT(*) FROM ticket_categories").Scan(&amp;categoryCount)
        require.NoError(t, err)
        require.Equal(t, 4, categoryCount, "Expected 4 ticket categories to be created")

        // 3. Check ticket_sales table - should have 2 days as specified in DayCount
        var saleCount int
        err = conn.Pool.QueryRow(ctx, "SELECT COUNT(*) FROM ticket_sales").Scan(&amp;saleCount)
        require.NoError(t, err)
        require.Equal(t, 2, saleCount, "Expected 2 ticket sales (days) to be created")

        // 4. Check ticket_packages table - should have 8 packages (4 categories × 2 days)
        var packageCount int
        err = conn.Pool.QueryRow(ctx, "SELECT COUNT(*) FROM ticket_packages").Scan(&amp;packageCount)
        require.NoError(t, err)
        require.Equal(t, 8, packageCount, "Expected 8 ticket packages to be created (4 categories × 2 days)")

        // 5. Check ticket_areas table - should have 10 areas
        // Calculation:
        // - Seated Categories: (1 area × 1 category + 1 area × 1 category) × 2 days = 4 areas
        // - Free Standing: (1 area × 1 category + 2 areas × 1 category) × 2 days = 6 areas
        var areaCount int
        err = conn.Pool.QueryRow(ctx, "SELECT COUNT(*) FROM ticket_areas").Scan(&amp;areaCount)
        require.NoError(t, err)
        require.Equal(t, 10, areaCount, "Expected 10 ticket areas to be created")

        // 6. Check ticket_seats table - should have the sum of all seats
        // Calculation:
        // - Seated Categories: (100 + 250) × 2 days = 700 seats
        // - Free Standing: (300 + 2×1000) × 2 days = 4600 spots
        // Total: 5300 seats/spots
        var seatCount int
        err = conn.Pool.QueryRow(ctx, "SELECT COUNT(*) FROM ticket_seats").Scan(&amp;seatCount)
        require.NoError(t, err)
        require.Equal(t, 5300, seatCount, "Expected 5300 ticket seats to be created")

        // 7. Verify the correct distribution of seats by area type
        var numberedSeatingCount int
        err = conn.Pool.QueryRow(ctx, `
           SELECT COUNT(*) FROM ticket_seats ts
           JOIN ticket_areas ta ON ts.ticket_area_id = ta.id
           WHERE ta.type = 'numbered-seating'
       `).Scan(&amp;numberedSeatingCount)
        require.NoError(t, err)
        require.Equal(t, 700, numberedSeatingCount, "Expected 700 numbered seats")

        var freeStandingCount int
        err = conn.Pool.QueryRow(ctx, `
           SELECT COUNT(*) FROM ticket_seats ts
           JOIN ticket_areas ta ON ts.ticket_area_id = ta.id
           WHERE ta.type = 'free-standing'
       `).Scan(&amp;freeStandingCount)
        require.NoError(t, err)
        require.Equal(t, 4600, freeStandingCount, "Expected 4600 free-standing spots")

        // 8. Verify all seats are initially available
        </span>var availableSeatsCount int
        err = conn.Pool.QueryRow(ctx, "SELECT COUNT(*) FROM ticket_seats WHERE status = 'available'").Scan(&amp;availableSeatsCount)
        require.NoError(t, err)
        require.Equal(t, 5300, availableSeatsCount, "Expected all 5300 seats to have 'available' status")
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package cursor_iterator

// Source https://github.com/Eun/go-pgx-cursor-iterator
// Copied because the published package are outdated and use outdated packages that used in this project
// Package cursoriterator provides functionality to iterate over big batches of postgres rows.

import (
        "context"
        "encoding/hex"
        "fmt"
        "github.com/georgysavva/scany/v2/pgxscan"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
        "github.com/pkg/errors"
        "reflect"
        "sync"
)

// CursorIterator will be returned by NewCursorIterator().
// It provides functionality to loop over postgres rows and
// holds all necessary internal information for the functionality.
type CursorIterator struct {
        connector PgxConnector
        query     string
        args      []interface{}

        fetchQuery string

        values       []interface{}
        valuesPos    int
        valuesMaxPos int

        err error

        tx pgx.Tx

        mu         sync.Mutex
        cursorName string
}

// PgxConnector implements the Begin() function from the pgx and pgxpool packages.
type PgxConnector interface {
        Begin(ctx context.Context) (pgx.Tx, error)
}

// NewCursorIterator can be used to create a new iterator.
// Required parameters:
//
//        connector                 most likely a *pgx.Conn or *pgxpool.Pool, needed to start a transaction on the database
//        values                    a slice where the fetched values should be stored in.
//        maxDatabaseExecutionTime  how long should one database operation be allowed to run.
//        query                     the query to fetch the rows
//        args                      arguments for the query
//
// Example Usage:
//
//        values := make([]User, 1000)
//        iter, err := NewCursorIterator(pool, values, time.Minute, "SELECT * FROM users WHERE role = $1", "Guest")
//        if err != nil {
//                panic(err)
//        }
//        defer iter.Close()
//        for iter.Next() {
//                fmt.Printf("Name: %s\n", values[iter.ValueIndex()].Name)
//        }
//        if err := iter.Error(); err != nil {
//                panic(err)
//        }
func NewCursorIterator(
        connector PgxConnector,
        values interface{},
        query string, args ...interface{},
) (*CursorIterator, error) <span class="cov3" title="14">{
        if connector == nil </span><span class="cov0" title="0">{
                return nil, errors.New("connector cannot be nil")
        }</span>
        <span class="cov3" title="14">if values == nil </span><span class="cov0" title="0">{
                return nil, errors.New("values cannot be nil")
        }</span>
        <span class="cov3" title="14">rv := reflect.ValueOf(values)
        if !rv.IsValid() </span><span class="cov0" title="0">{
                return nil, errors.New("values is invalid")
        }</span>

        <span class="cov3" title="14">if rv.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return nil, errors.New("values must be a slice")
        }</span>

        <span class="cov3" title="14">valuesCapacity := rv.Cap()

        if valuesCapacity &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("values must have a capacity bigger than 0")
        }</span>

        <span class="cov3" title="14">valuesSlice := make([]interface{}, valuesCapacity)
        for i := 0; i &lt; valuesCapacity; i++ </span><span class="cov8" title="5400">{
                elem := rv.Index(i)
                if !elem.CanAddr() </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("unable to reference %s", elem.Type().String())
                }</span>
                <span class="cov8" title="5400">elem = elem.Addr()
                if !elem.CanInterface() </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("unable to get interface of %s", elem.Type().String())
                }</span>
                <span class="cov8" title="5400">valuesSlice[i] = elem.Interface()</span>
        }

        <span class="cov3" title="14">cursorID := uuid.New()
        cursorName := hex.EncodeToString(cursorID[:])
        return &amp;CursorIterator{
                connector:  connector,
                query:      query,
                args:       args,
                cursorName: cursorName,

                fetchQuery: fmt.Sprintf("FETCH %d IN %q", valuesCapacity, cursorName),

                values:       valuesSlice,
                valuesPos:    -2,
                valuesMaxPos: valuesCapacity - 1,

                err: nil,

                tx: nil,
        }, nil</span>
}

func (iter *CursorIterator) fetchNextRows(ctx context.Context) <span class="cov5" title="180">{
        rows, err := iter.tx.Query(ctx, iter.fetchQuery)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        iter.close(ctx)
                        return
                }</span>
                <span class="cov0" title="0">iter.err = err
                return</span>
        }

        <span class="cov5" title="180">scanner := pgxscan.NewRowScanner(rows)

        i := 0
        for rows.Next() </span><span class="cov10" title="16100">{
                if i &gt; iter.valuesMaxPos </span><span class="cov0" title="0">{
                        iter.close(ctx)
                        iter.err = errors.New("database returned more rows than expected")
                        return
                }</span>
                <span class="cov10" title="16100">if err := scanner.Scan(iter.values[i]); err != nil </span><span class="cov0" title="0">{
                        iter.close(ctx)
                        iter.err = errors.Wrap(err, "unable to scan into values element")
                        return
                }</span>
                <span class="cov10" title="16100">i++</span>
        }

        <span class="cov5" title="180">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        iter.close(ctx)
                        return
                }</span>
                <span class="cov0" title="0">iter.close(ctx)
                iter.err = errors.Wrap(err, "unable to fetch rows")
                return</span>
        }
        <span class="cov5" title="180">if i == 0 </span><span class="cov3" title="10">{
                iter.close(ctx)
                return
        }</span>
        <span class="cov5" title="170">iter.valuesPos = 0
        iter.valuesMaxPos = i</span>
}

// Next will return true if there is a next value available, false if there is no next value available.
// Next will also fetch next values when all current values have been iterated.
func (iter *CursorIterator) Next(ctx context.Context) bool <span class="cov9" title="15989">{
        iter.mu.Lock()
        defer iter.mu.Unlock()
        // it is not the first row, and we already iterated over all rows: early exit
        if iter.valuesPos == -1 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov9" title="15989">if iter.valuesPos == -2 </span><span class="cov3" title="14">{
                // first call:
                // start a transaction
                // and declare the cursor
                // start a transaction
                iter.tx, iter.err = iter.connector.Begin(ctx)
                if iter.err != nil </span><span class="cov0" title="0">{
                        iter.err = errors.Wrap(iter.err, "unable to start transaction")
                        return false
                }</span>

                // declare cursor
                <span class="cov3" title="14">query := fmt.Sprintf("DECLARE %q CURSOR FOR %s", iter.cursorName, iter.query)
                if _, err := iter.tx.Exec(ctx, query, iter.args...); err != nil </span><span class="cov0" title="0">{
                        iter.err = errors.Wrap(err, "unable to declare cursor")
                        return false
                }</span>
                // fetch the initial rows
                <span class="cov3" title="14">iter.fetchNextRows(ctx)
                // return true if we have rows
                return iter.valuesPos == 0</span>
        }

        // do we still have items in the cache?
        <span class="cov9" title="15975">if iter.valuesPos+1 &lt; iter.valuesMaxPos </span><span class="cov9" title="15809">{
                iter.valuesPos++
                return true
        }</span>

        // we hit the end: fetch the next chunk of rows
        <span class="cov5" title="166">iter.fetchNextRows(ctx)
        return iter.valuesPos == 0</span>
}

// ValueIndex will return the current value index that can be used to fetch the current value.
// Notice that it will return values below 0 when there is no next value available or the iteration didn't started yet.
func (iter *CursorIterator) ValueIndex() int <span class="cov9" title="15977">{
        iter.mu.Lock()
        i := iter.valuesPos
        iter.mu.Unlock()
        return i
}</span>

// Error will return the last error that appeared during fetching.
func (iter *CursorIterator) Error() error <span class="cov3" title="11">{
        iter.mu.Lock()
        err := iter.err
        iter.mu.Unlock()
        return err
}</span>

func (iter *CursorIterator) close(ctx context.Context) <span class="cov3" title="23">{
        if iter.tx == nil </span><span class="cov3" title="10">{
                iter.err = nil
                return
        }</span>

        <span class="cov3" title="13">iter.err = iter.tx.Rollback(ctx)
        iter.tx = nil
        iter.valuesPos = -1</span>
}

// Close will close the iterator and all Next() calls will return false.
// After Close the iterator is unusable and can not be used again.
func (iter *CursorIterator) Close(ctx context.Context) error <span class="cov3" title="13">{
        iter.mu.Lock()
        defer iter.mu.Unlock()
        iter.close(ctx)
        return iter.err
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package myerror

import (
        "context"
        "fmt"
        "go.uber.org/zap"
        "tugas-akhir/backend/pkg/logger"
)

type FieldError struct {
        Field   string `json:"field"`
        Message string `json:"message"`
        Tag     string `json:"tag"`
}

type HttpError struct {
        Code         int          `json:"-"`
        Message      string       `json:"message"`
        Errors       []FieldError `json:"errors,omitempty"`
        ErrorContext error        `json:"-"`
}

func (e *HttpError) Log(ctx context.Context) <span class="cov0" title="0">{
        if e.ErrorContext != nil </span><span class="cov0" title="0">{
                l := logger.FromCtx(ctx)
                l.Error("an error occured",
                        zap.String("error", e.ErrorContext.Error()),
                        zap.String("stackTrace", fmt.Sprintf("%+v", e.ErrorContext)))
        }</span>
}

type HttpPayload struct {
        Data    interface{} `json:"data,omitempty"`
        Meta    interface{} `json:"meta,omitempty"`
        Message string      `json:"message,omitempty"`
}

func NewFromFieldError(payload []FieldError) HttpError <span class="cov0" title="0">{
        return HttpError{
                Message: "Input validation error",
                Errors:  payload,
        }
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package go_metrics_prometheus

import (
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/rcrowley/go-metrics"
)

// Source
// https://github.com/deathowl/go-metrics-prometheus

// PrometheusConfig provides a container with config parameters for the
// Prometheus Exporter

type PrometheusConfig struct {
        namespace        string
        Registry         metrics.Registry // Registry to be exported
        subsystem        string
        promRegistry     prometheus.Registerer //Prometheus registry
        FlushInterval    time.Duration         //interval to update prom metrics
        gauges           map[string]prometheus.Gauge
        customMetrics    map[string]*CustomCollector
        histogramBuckets []float64
        timerBuckets     []float64
        mutex            *sync.Mutex
}

// NewPrometheusProvider returns a Provider that produces Prometheus metrics.
// Namespace and subsystem are applied to all produced metrics.
func NewPrometheusProvider(r metrics.Registry, namespace string, subsystem string, promRegistry prometheus.Registerer, FlushInterval time.Duration) *PrometheusConfig <span class="cov2" title="3">{
        return &amp;PrometheusConfig{
                namespace:        namespace,
                subsystem:        subsystem,
                Registry:         r,
                promRegistry:     promRegistry,
                FlushInterval:    FlushInterval,
                gauges:           make(map[string]prometheus.Gauge),
                customMetrics:    make(map[string]*CustomCollector),
                histogramBuckets: []float64{0.05, 0.1, 0.25, 0.50, 0.75, 0.9, 0.95, 0.99},
                timerBuckets:     []float64{0.50, 0.95, 0.99, 0.999},
                mutex:            new(sync.Mutex),
        }
}</span>

func (c *PrometheusConfig) WithHistogramBuckets(b []float64) *PrometheusConfig <span class="cov0" title="0">{
        c.histogramBuckets = b
        return c
}</span>

func (c *PrometheusConfig) WithTimerBuckets(b []float64) *PrometheusConfig <span class="cov0" title="0">{
        c.timerBuckets = b
        return c
}</span>

func (c *PrometheusConfig) flattenKey(key string) string <span class="cov9" title="3942">{
        key = strings.Replace(key, " ", "_", -1)
        key = strings.Replace(key, ".", "_", -1)
        key = strings.Replace(key, "-", "_", -1)
        key = strings.Replace(key, "=", "_", -1)
        key = strings.Replace(key, "/", "_", -1)
        return key
}</span>

func (c *PrometheusConfig) createKey(name string) string <span class="cov9" title="3039">{
        return fmt.Sprintf("%s_%s_%s", c.namespace, c.subsystem, name)
}</span>

func (c *PrometheusConfig) gaugeFromNameAndValue(name string, val float64) <span class="cov8" title="2073">{
        key := c.createKey(name)
        g, ok := c.gauges[key]
        if !ok </span><span class="cov4" title="26">{
                g = prometheus.NewGauge(prometheus.GaugeOpts{
                        Namespace: c.flattenKey(c.namespace),
                        Subsystem: c.flattenKey(c.subsystem),
                        Name:      c.flattenKey(name),
                        Help:      name,
                })
                c.promRegistry.Register(g)
                c.gauges[key] = g
        }</span>
        <span class="cov8" title="2073">g.Set(val)</span>
}

func (c *PrometheusConfig) histogramFromNameAndMetric(name string, goMetric interface{}, buckets []float64) <span class="cov7" title="966">{
        key := c.createKey(name)

        collector, ok := c.customMetrics[key]
        if !ok </span><span class="cov3" title="12">{
                collector = NewCustomCollector(c.mutex)
                c.promRegistry.MustRegister(collector)
                c.customMetrics[key] = collector
        }</span>

        <span class="cov7" title="966">var ps []float64
        var count uint64
        var sum float64
        var typeName string

        switch metric := goMetric.(type) </span>{
        case metrics.Histogram:<span class="cov7" title="805">
                snapshot := metric.Snapshot()
                ps = snapshot.Percentiles(buckets)
                count = uint64(snapshot.Count())
                sum = float64(snapshot.Sum())
                typeName = "histogram"</span>
        case metrics.Timer:<span class="cov6" title="161">
                snapshot := metric.Snapshot()
                ps = snapshot.Percentiles(buckets)
                count = uint64(snapshot.Count())
                sum = float64(snapshot.Sum())
                typeName = "timer"</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("unexpected metric type %T", goMetric))</span>
        }

        <span class="cov7" title="966">bucketVals := make(map[float64]uint64)
        for ii, bucket := range buckets </span><span class="cov10" title="7084">{
                bucketVals[bucket] = uint64(ps[ii])
        }</span>

        <span class="cov7" title="966">desc := prometheus.NewDesc(
                prometheus.BuildFQName(
                        c.flattenKey(c.namespace),
                        c.flattenKey(c.subsystem),
                        fmt.Sprintf("%s_%s", c.flattenKey(name), typeName),
                ),
                c.flattenKey(name),
                []string{},
                map[string]string{},
        )

        if constHistogram, err := prometheus.NewConstHistogram(
                desc,
                count,
                sum,
                bucketVals,
        ); err == nil </span><span class="cov7" title="966">{
                c.mutex.Lock()
                collector.metric = constHistogram
                c.mutex.Unlock()
        }</span>
}

func (c *PrometheusConfig) UpdatePrometheusMetrics() <span class="cov1" title="2">{
        for _ = range time.Tick(c.FlushInterval) </span><span class="cov6" title="161">{
                c.UpdatePrometheusMetricsOnce()
        }</span>
}

func (c *PrometheusConfig) UpdatePrometheusMetricsOnce() error <span class="cov6" title="161">{
        c.Registry.Each(func(name string, i interface{}) </span><span class="cov8" title="1127">{
                switch metric := i.(type) </span>{
                case metrics.Counter:<span class="cov6" title="161">
                        c.gaugeFromNameAndValue(name, float64(metric.Count()))</span>
                case metrics.Gauge:<span class="cov0" title="0">
                        c.gaugeFromNameAndValue(name, float64(metric.Value()))</span>
                case metrics.GaugeFloat64:<span class="cov0" title="0">
                        c.gaugeFromNameAndValue(name, metric.Value())</span>
                case metrics.Histogram:<span class="cov7" title="805">
                        samples := metric.Snapshot().Sample().Values()
                        if len(samples) &gt; 0 </span><span class="cov6" title="141">{
                                lastSample := samples[len(samples)-1]
                                c.gaugeFromNameAndValue(name, float64(lastSample))
                        }</span>
                        <span class="cov7" title="805">c.histogramFromNameAndMetric(name, metric, c.histogramBuckets)</span>
                case metrics.Meter:<span class="cov0" title="0">
                        snapshot := metric.Snapshot()
                        c.gaugeFromNameAndValue(name+"_rate1", snapshot.Rate1())
                        c.gaugeFromNameAndValue(name+"_rate5", snapshot.Rate5())
                        c.gaugeFromNameAndValue(name+"_rate15", snapshot.Rate15())
                        c.gaugeFromNameAndValue(name+"_rate_mean", snapshot.RateMean())
                        c.gaugeFromNameAndValue(name+"_count", float64(snapshot.Count()))</span>
                case metrics.Timer:<span class="cov6" title="161">
                        snapshot := metric.Snapshot()
                        c.gaugeFromNameAndValue(name+"_rate1", snapshot.Rate1())
                        c.gaugeFromNameAndValue(name+"_rate5", snapshot.Rate5())
                        c.gaugeFromNameAndValue(name+"_rate15", snapshot.Rate15())
                        c.gaugeFromNameAndValue(name+"_rate_mean", snapshot.RateMean())
                        c.gaugeFromNameAndValue(name+"_count", float64(snapshot.Count()))
                        c.gaugeFromNameAndValue(name+"_sum", float64(snapshot.Sum()))
                        c.gaugeFromNameAndValue(name+"_max", float64(snapshot.Max()))
                        c.gaugeFromNameAndValue(name+"_min", float64(snapshot.Min()))
                        c.gaugeFromNameAndValue(name+"_mean", snapshot.Mean())
                        c.gaugeFromNameAndValue(name+"_variance", snapshot.Variance())
                        c.gaugeFromNameAndValue(name+"_std_dev", snapshot.StdDev())
                        c.histogramFromNameAndMetric(name, metric, c.timerBuckets)</span>
                }
        })
        <span class="cov6" title="161">return nil</span>
}

// for collecting prometheus.constHistogram objects
type CustomCollector struct {
        prometheus.Collector

        metric prometheus.Metric
        mutex  *sync.Mutex
}

func NewCustomCollector(mutex *sync.Mutex) *CustomCollector <span class="cov3" title="12">{
        return &amp;CustomCollector{
                mutex: mutex,
        }
}</span>

func (c *CustomCollector) Collect(ch chan&lt;- prometheus.Metric) <span class="cov0" title="0">{
        c.mutex.Lock()
        if c.metric != nil </span><span class="cov0" title="0">{
                val := c.metric
                ch &lt;- val
        }</span>
        <span class="cov0" title="0">c.mutex.Unlock()</span>
}

func (p *CustomCollector) Describe(ch chan&lt;- *prometheus.Desc) {<span class="cov3" title="12">
        // empty method to fulfill prometheus.Collector interface
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package logger

import (
        "context"
        prettyconsole "github.com/thessem/zap-prettyconsole"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "os"
        "sync"
)

type ctxKey struct{}

var infoOnce sync.Once

var infoLogger *zap.Logger

func GetInfo() *zap.Logger <span class="cov6" title="18">{
        infoOnce.Do(func() </span><span class="cov5" title="10">{
                stdout := zapcore.AddSync(os.Stdout)

                level := zap.InfoLevel

                logLevel := zap.NewAtomicLevelAt(level)

                isProduction := os.Getenv("ENVIRONMENT") == "production"

                var encoder zapcore.Encoder

                if isProduction </span><span class="cov0" title="0">{
                        encoder = zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig())
                }</span> else<span class="cov5" title="10"> {
                        //encoder = zapcore.NewConsoleEncoder(zap.NewProductionEncoderConfig())
                        encoder = prettyconsole.NewEncoder(prettyconsole.NewEncoderConfig())
                }</span>

                <span class="cov5" title="10">core := zapcore.NewTee(
                        zapcore.NewCore(encoder, stdout, logLevel),
                )

                infoLogger = zap.New(core)
                defer infoLogger.Sync()</span>
        })

        <span class="cov6" title="18">return infoLogger</span>
}

var debugOnce sync.Once

var debugLogger *zap.Logger

func GetDebug() *zap.Logger <span class="cov5" title="11">{
        debugOnce.Do(func() </span><span class="cov5" title="8">{
                stdout := zapcore.AddSync(os.Stdout)

                level := zap.DebugLevel

                logLevel := zap.NewAtomicLevelAt(level)

                isProduction := os.Getenv("ENVIRONMENT") == "production"

                var encoder zapcore.Encoder

                if isProduction </span><span class="cov0" title="0">{
                        encoder = zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig())
                }</span> else<span class="cov5" title="8"> {
                        //encoder = zapcore.NewConsoleEncoder(zap.NewProductionEncoderConfig())
                        encoder = prettyconsole.NewEncoder(prettyconsole.NewEncoderConfig())
                }</span>

                <span class="cov5" title="8">core := zapcore.NewTee(
                        zapcore.NewCore(encoder, stdout, logLevel),
                )

                debugLogger = zap.New(core)
                defer debugLogger.Sync()</span>
        })

        <span class="cov5" title="11">return debugLogger</span>
}

// FromCtx returns the Logger associated with the ctx. If no logger
// is associated, the default logger is returned, unless it is nil
// in which case a disabled logger is returned.
func FromCtx(ctx context.Context) *zap.Logger <span class="cov10" title="90">{
        if l, ok := ctx.Value(ctxKey{}).(*zap.Logger); ok </span><span class="cov0" title="0">{
                return l
        }</span> else<span class="cov10" title="90"> if l := infoLogger; l != nil </span><span class="cov9" title="80">{
                return l
        }</span>

        <span class="cov5" title="10">return GetInfo()</span>
}

// WithCtx returns a copy of ctx with the Logger attached.
func WithCtx(ctx context.Context, l *zap.Logger) context.Context <span class="cov0" title="0">{
        if lp, ok := ctx.Value(ctxKey{}).(*zap.Logger); ok </span><span class="cov0" title="0">{
                if lp == l </span><span class="cov0" title="0">{
                        // Do not store same logger.
                        return ctx
                }</span>
        }

        <span class="cov0" title="0">return context.WithValue(ctx, ctxKey{}, l)</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">/*
Payment Service

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mock_payment

import (
        "bytes"
        "context"
        "io"
        "net/http"
        "net/url"
        "strings"
)


// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiInvoicesIdGetRequest struct {
        ctx context.Context
        ApiService *DefaultAPIService
        id string
}

func (r ApiInvoicesIdGetRequest) Execute() (*Invoice, *http.Response, error) <span class="cov0" title="0">{
        return r.ApiService.InvoicesIdGetExecute(r)
}</span>

/*
InvoicesIdGet Get Invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiInvoicesIdGetRequest
*/
func (a *DefaultAPIService) InvoicesIdGet(ctx context.Context, id string) ApiInvoicesIdGetRequest <span class="cov0" title="0">{
        return ApiInvoicesIdGetRequest{
                ApiService: a,
                ctx: ctx,
                id: id,
        }
}</span>

// Execute executes the request
//  @return Invoice
func (a *DefaultAPIService) InvoicesIdGetExecute(r ApiInvoicesIdGetRequest) (*Invoice, *http.Response, error) <span class="cov0" title="0">{
        var (
                localVarHTTPMethod   = http.MethodGet
                localVarPostBody     interface{}
                formFiles            []formFile
                localVarReturnValue  *Invoice
        )

        localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.InvoicesIdGet")
        if err != nil </span><span class="cov0" title="0">{
                return localVarReturnValue, nil, &amp;GenericOpenAPIError{error: err.Error()}
        }</span>

        <span class="cov0" title="0">localVarPath := localBasePath + "/invoices/{id}"
        localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

        localVarHeaderParams := make(map[string]string)
        localVarQueryParams := url.Values{}
        localVarFormParams := url.Values{}
        if strlen(r.id) &lt; 3 </span><span class="cov0" title="0">{
                return localVarReturnValue, nil, reportError("id must have at least 3 elements")
        }</span>

        // to determine the Content-Type header
        <span class="cov0" title="0">localVarHTTPContentTypes := []string{}

        // set Content-Type header
        localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
        if localVarHTTPContentType != "" </span><span class="cov0" title="0">{
                localVarHeaderParams["Content-Type"] = localVarHTTPContentType
        }</span>

        // to determine the Accept header
        <span class="cov0" title="0">localVarHTTPHeaderAccepts := []string{"application/json"}

        // set Accept header
        localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
        if localVarHTTPHeaderAccept != "" </span><span class="cov0" title="0">{
                localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
        }</span>
        <span class="cov0" title="0">req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
        if err != nil </span><span class="cov0" title="0">{
                return localVarReturnValue, nil, err
        }</span>

        <span class="cov0" title="0">localVarHTTPResponse, err := a.client.callAPI(req)
        if err != nil || localVarHTTPResponse == nil </span><span class="cov0" title="0">{
                return localVarReturnValue, localVarHTTPResponse, err
        }</span>

        <span class="cov0" title="0">localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
        localVarHTTPResponse.Body.Close()
        localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
        if err != nil </span><span class="cov0" title="0">{
                return localVarReturnValue, localVarHTTPResponse, err
        }</span>

        <span class="cov0" title="0">if localVarHTTPResponse.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                newErr := &amp;GenericOpenAPIError{
                        body:  localVarBody,
                        error: localVarHTTPResponse.Status,
                }
                if localVarHTTPResponse.StatusCode == 404 </span><span class="cov0" title="0">{
                        var v InvoicesIdGet404Response
                        err = a.client.decode(&amp;v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
                        if err != nil </span><span class="cov0" title="0">{
                                newErr.error = err.Error()
                                return localVarReturnValue, localVarHTTPResponse, newErr
                        }</span>
                                        <span class="cov0" title="0">newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &amp;v)
                                        newErr.model = v</span>
                }
                <span class="cov0" title="0">return localVarReturnValue, localVarHTTPResponse, newErr</span>
        }

        <span class="cov0" title="0">err = a.client.decode(&amp;localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
        if err != nil </span><span class="cov0" title="0">{
                newErr := &amp;GenericOpenAPIError{
                        body:  localVarBody,
                        error: err.Error(),
                }
                return localVarReturnValue, localVarHTTPResponse, newErr
        }</span>

        <span class="cov0" title="0">return localVarReturnValue, localVarHTTPResponse, nil</span>
}

type ApiInvoicesIdPaymentPostRequest struct {
        ctx context.Context
        ApiService *DefaultAPIService
        id string
        payInvoiceRequest *PayInvoiceRequest
}

func (r ApiInvoicesIdPaymentPostRequest) PayInvoiceRequest(payInvoiceRequest PayInvoiceRequest) ApiInvoicesIdPaymentPostRequest <span class="cov0" title="0">{
        r.payInvoiceRequest = &amp;payInvoiceRequest
        return r
}</span>

func (r ApiInvoicesIdPaymentPostRequest) Execute() (*Invoice, *http.Response, error) <span class="cov0" title="0">{
        return r.ApiService.InvoicesIdPaymentPostExecute(r)
}</span>

/*
InvoicesIdPaymentPost Pay Invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiInvoicesIdPaymentPostRequest
*/
func (a *DefaultAPIService) InvoicesIdPaymentPost(ctx context.Context, id string) ApiInvoicesIdPaymentPostRequest <span class="cov0" title="0">{
        return ApiInvoicesIdPaymentPostRequest{
                ApiService: a,
                ctx: ctx,
                id: id,
        }
}</span>

// Execute executes the request
//  @return Invoice
func (a *DefaultAPIService) InvoicesIdPaymentPostExecute(r ApiInvoicesIdPaymentPostRequest) (*Invoice, *http.Response, error) <span class="cov0" title="0">{
        var (
                localVarHTTPMethod   = http.MethodPost
                localVarPostBody     interface{}
                formFiles            []formFile
                localVarReturnValue  *Invoice
        )

        localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.InvoicesIdPaymentPost")
        if err != nil </span><span class="cov0" title="0">{
                return localVarReturnValue, nil, &amp;GenericOpenAPIError{error: err.Error()}
        }</span>

        <span class="cov0" title="0">localVarPath := localBasePath + "/invoices/{id}/payment"
        localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

        localVarHeaderParams := make(map[string]string)
        localVarQueryParams := url.Values{}
        localVarFormParams := url.Values{}
        if strlen(r.id) &lt; 3 </span><span class="cov0" title="0">{
                return localVarReturnValue, nil, reportError("id must have at least 3 elements")
        }</span>

        // to determine the Content-Type header
        <span class="cov0" title="0">localVarHTTPContentTypes := []string{"application/json"}

        // set Content-Type header
        localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
        if localVarHTTPContentType != "" </span><span class="cov0" title="0">{
                localVarHeaderParams["Content-Type"] = localVarHTTPContentType
        }</span>

        // to determine the Accept header
        <span class="cov0" title="0">localVarHTTPHeaderAccepts := []string{"application/json"}

        // set Accept header
        localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
        if localVarHTTPHeaderAccept != "" </span><span class="cov0" title="0">{
                localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
        }</span>
        // body params
        <span class="cov0" title="0">localVarPostBody = r.payInvoiceRequest
        req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
        if err != nil </span><span class="cov0" title="0">{
                return localVarReturnValue, nil, err
        }</span>

        <span class="cov0" title="0">localVarHTTPResponse, err := a.client.callAPI(req)
        if err != nil || localVarHTTPResponse == nil </span><span class="cov0" title="0">{
                return localVarReturnValue, localVarHTTPResponse, err
        }</span>

        <span class="cov0" title="0">localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
        localVarHTTPResponse.Body.Close()
        localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
        if err != nil </span><span class="cov0" title="0">{
                return localVarReturnValue, localVarHTTPResponse, err
        }</span>

        <span class="cov0" title="0">if localVarHTTPResponse.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                newErr := &amp;GenericOpenAPIError{
                        body:  localVarBody,
                        error: localVarHTTPResponse.Status,
                }
                if localVarHTTPResponse.StatusCode == 400 </span><span class="cov0" title="0">{
                        var v InvoicesIdGet404Response
                        err = a.client.decode(&amp;v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
                        if err != nil </span><span class="cov0" title="0">{
                                newErr.error = err.Error()
                                return localVarReturnValue, localVarHTTPResponse, newErr
                        }</span>
                                        <span class="cov0" title="0">newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &amp;v)
                                        newErr.model = v
                        return localVarReturnValue, localVarHTTPResponse, newErr</span>
                }
                <span class="cov0" title="0">if localVarHTTPResponse.StatusCode == 404 </span><span class="cov0" title="0">{
                        var v InvoicesIdGet404Response
                        err = a.client.decode(&amp;v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
                        if err != nil </span><span class="cov0" title="0">{
                                newErr.error = err.Error()
                                return localVarReturnValue, localVarHTTPResponse, newErr
                        }</span>
                                        <span class="cov0" title="0">newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &amp;v)
                                        newErr.model = v</span>
                }
                <span class="cov0" title="0">return localVarReturnValue, localVarHTTPResponse, newErr</span>
        }

        <span class="cov0" title="0">err = a.client.decode(&amp;localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
        if err != nil </span><span class="cov0" title="0">{
                newErr := &amp;GenericOpenAPIError{
                        body:  localVarBody,
                        error: err.Error(),
                }
                return localVarReturnValue, localVarHTTPResponse, newErr
        }</span>

        <span class="cov0" title="0">return localVarReturnValue, localVarHTTPResponse, nil</span>
}

type ApiInvoicesPostRequest struct {
        ctx context.Context
        ApiService *DefaultAPIService
        createInvoiceRequest *CreateInvoiceRequest
}

func (r ApiInvoicesPostRequest) CreateInvoiceRequest(createInvoiceRequest CreateInvoiceRequest) ApiInvoicesPostRequest <span class="cov0" title="0">{
        r.createInvoiceRequest = &amp;createInvoiceRequest
        return r
}</span>

func (r ApiInvoicesPostRequest) Execute() (*Invoice, *http.Response, error) <span class="cov0" title="0">{
        return r.ApiService.InvoicesPostExecute(r)
}</span>

/*
InvoicesPost Create Invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInvoicesPostRequest
*/
func (a *DefaultAPIService) InvoicesPost(ctx context.Context) ApiInvoicesPostRequest <span class="cov0" title="0">{
        return ApiInvoicesPostRequest{
                ApiService: a,
                ctx: ctx,
        }
}</span>

// Execute executes the request
//  @return Invoice
func (a *DefaultAPIService) InvoicesPostExecute(r ApiInvoicesPostRequest) (*Invoice, *http.Response, error) <span class="cov0" title="0">{
        var (
                localVarHTTPMethod   = http.MethodPost
                localVarPostBody     interface{}
                formFiles            []formFile
                localVarReturnValue  *Invoice
        )

        localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.InvoicesPost")
        if err != nil </span><span class="cov0" title="0">{
                return localVarReturnValue, nil, &amp;GenericOpenAPIError{error: err.Error()}
        }</span>

        <span class="cov0" title="0">localVarPath := localBasePath + "/invoices"

        localVarHeaderParams := make(map[string]string)
        localVarQueryParams := url.Values{}
        localVarFormParams := url.Values{}

        // to determine the Content-Type header
        localVarHTTPContentTypes := []string{"application/json"}

        // set Content-Type header
        localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
        if localVarHTTPContentType != "" </span><span class="cov0" title="0">{
                localVarHeaderParams["Content-Type"] = localVarHTTPContentType
        }</span>

        // to determine the Accept header
        <span class="cov0" title="0">localVarHTTPHeaderAccepts := []string{"application/json"}

        // set Accept header
        localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
        if localVarHTTPHeaderAccept != "" </span><span class="cov0" title="0">{
                localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
        }</span>
        // body params
        <span class="cov0" title="0">localVarPostBody = r.createInvoiceRequest
        req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
        if err != nil </span><span class="cov0" title="0">{
                return localVarReturnValue, nil, err
        }</span>

        <span class="cov0" title="0">localVarHTTPResponse, err := a.client.callAPI(req)
        if err != nil || localVarHTTPResponse == nil </span><span class="cov0" title="0">{
                return localVarReturnValue, localVarHTTPResponse, err
        }</span>

        <span class="cov0" title="0">localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
        localVarHTTPResponse.Body.Close()
        localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
        if err != nil </span><span class="cov0" title="0">{
                return localVarReturnValue, localVarHTTPResponse, err
        }</span>

        <span class="cov0" title="0">if localVarHTTPResponse.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                newErr := &amp;GenericOpenAPIError{
                        body:  localVarBody,
                        error: localVarHTTPResponse.Status,
                }
                return localVarReturnValue, localVarHTTPResponse, newErr
        }</span>

        <span class="cov0" title="0">err = a.client.decode(&amp;localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
        if err != nil </span><span class="cov0" title="0">{
                newErr := &amp;GenericOpenAPIError{
                        body:  localVarBody,
                        error: err.Error(),
                }
                return localVarReturnValue, localVarHTTPResponse, newErr
        }</span>

        <span class="cov0" title="0">return localVarReturnValue, localVarHTTPResponse, nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">/*
Payment Service

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mock_payment

import (
        "bytes"
        "context"
        "encoding/json"
        "encoding/xml"
        "errors"
        "fmt"
        "io"
        "log"
        "mime/multipart"
        "net/http"
        "net/http/httputil"
        "net/url"
        "os"
        "path/filepath"
        "reflect"
        "regexp"
        "strconv"
        "strings"
        "time"
        "unicode/utf8"

)

var (
        JsonCheck       = regexp.MustCompile(`(?i:(?:application|text)/(?:[^;]+\+)?json)`)
        XmlCheck        = regexp.MustCompile(`(?i:(?:application|text)/(?:[^;]+\+)?xml)`)
        queryParamSplit = regexp.MustCompile(`(^|&amp;)([^&amp;]+)`)
        queryDescape    = strings.NewReplacer( "%5B", "[", "%5D", "]" )
)

// APIClient manages communication with the Payment Service API v1.0.0
// In most cases there should be only one, shared, APIClient.
type APIClient struct {
        cfg    *Configuration
        common service // Reuse a single struct instead of allocating one for each service on the heap.

        // API Services

        DefaultAPI *DefaultAPIService
}

type service struct {
        client *APIClient
}

// NewAPIClient creates a new API client. Requires a userAgent string describing your application.
// optionally a custom http.Client to allow for advanced features such as caching.
func NewAPIClient(cfg *Configuration) *APIClient <span class="cov0" title="0">{
        if cfg.HTTPClient == nil </span><span class="cov0" title="0">{
                cfg.HTTPClient = http.DefaultClient
        }</span>

        <span class="cov0" title="0">c := &amp;APIClient{}
        c.cfg = cfg
        c.common.client = c

        // API Services
        c.DefaultAPI = (*DefaultAPIService)(&amp;c.common)

        return c</span>
}

func atoi(in string) (int, error) <span class="cov0" title="0">{
        return strconv.Atoi(in)
}</span>

// selectHeaderContentType select a content type from the available list.
func selectHeaderContentType(contentTypes []string) string <span class="cov0" title="0">{
        if len(contentTypes) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if contains(contentTypes, "application/json") </span><span class="cov0" title="0">{
                return "application/json"
        }</span>
        <span class="cov0" title="0">return contentTypes[0]</span> // use the first content type specified in 'consumes'
}

// selectHeaderAccept join all accept types and return
func selectHeaderAccept(accepts []string) string <span class="cov0" title="0">{
        if len(accepts) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if contains(accepts, "application/json") </span><span class="cov0" title="0">{
                return "application/json"
        }</span>

        <span class="cov0" title="0">return strings.Join(accepts, ",")</span>
}

// contains is a case insensitive match, finding needle in a haystack
func contains(haystack []string, needle string) bool <span class="cov0" title="0">{
        for _, a := range haystack </span><span class="cov0" title="0">{
                if strings.EqualFold(a, needle) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Verify optional parameters are of the correct type.
func typeCheckParameter(obj interface{}, expected string, name string) error <span class="cov0" title="0">{
        // Make sure there is an object.
        if obj == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Check the type is as expected.
        <span class="cov0" title="0">if reflect.TypeOf(obj).String() != expected </span><span class="cov0" title="0">{
                return fmt.Errorf("expected %s to be of type %s but received %s", name, expected, reflect.TypeOf(obj).String())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func parameterValueToString( obj interface{}, key string ) string <span class="cov0" title="0">{
        if reflect.TypeOf(obj).Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                return fmt.Sprintf("%v", obj)
        }</span>
        <span class="cov0" title="0">var param,ok = obj.(MappedNullable)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">dataMap,err := param.ToMap()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%v", dataMap[key])</span>
}

// parameterAddToHeaderOrQuery adds the provided object to the request header or url query
// supporting deep object syntax
func parameterAddToHeaderOrQuery(headerOrQueryParams interface{}, keyPrefix string, obj interface{}, collectionType string) <span class="cov0" title="0">{
        var v = reflect.ValueOf(obj)
        var value = ""
        if v == reflect.ValueOf(nil) </span><span class="cov0" title="0">{
                value = "null"
        }</span> else<span class="cov0" title="0"> {
                switch v.Kind() </span>{
                        case reflect.Invalid:<span class="cov0" title="0">
                                value = "invalid"</span>

                        case reflect.Struct:<span class="cov0" title="0">
                                if t,ok := obj.(MappedNullable); ok </span><span class="cov0" title="0">{
                                        dataMap,err := t.ToMap()
                                        if err != nil </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                        <span class="cov0" title="0">parameterAddToHeaderOrQuery(headerOrQueryParams, keyPrefix, dataMap, collectionType)
                                        return</span>
                                }
                                <span class="cov0" title="0">if t, ok := obj.(time.Time); ok </span><span class="cov0" title="0">{
                                        parameterAddToHeaderOrQuery(headerOrQueryParams, keyPrefix, t.Format(time.RFC3339Nano), collectionType)
                                        return
                                }</span>
                                <span class="cov0" title="0">value = v.Type().String() + " value"</span>
                        case reflect.Slice:<span class="cov0" title="0">
                                var indValue = reflect.ValueOf(obj)
                                if indValue == reflect.ValueOf(nil) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">var lenIndValue = indValue.Len()
                                for i:=0;i&lt;lenIndValue;i++ </span><span class="cov0" title="0">{
                                        var arrayValue = indValue.Index(i)
                                        parameterAddToHeaderOrQuery(headerOrQueryParams, keyPrefix, arrayValue.Interface(), collectionType)
                                }</span>
                                <span class="cov0" title="0">return</span>

                        case reflect.Map:<span class="cov0" title="0">
                                var indValue = reflect.ValueOf(obj)
                                if indValue == reflect.ValueOf(nil) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">iter := indValue.MapRange()
                                for iter.Next() </span><span class="cov0" title="0">{
                                        k,v := iter.Key(), iter.Value()
                                        parameterAddToHeaderOrQuery(headerOrQueryParams, fmt.Sprintf("%s[%s]", keyPrefix, k.String()), v.Interface(), collectionType)
                                }</span>
                                <span class="cov0" title="0">return</span>

                        case reflect.Interface:<span class="cov0" title="0">
                                fallthrough</span>
                        case reflect.Ptr:<span class="cov0" title="0">
                                parameterAddToHeaderOrQuery(headerOrQueryParams, keyPrefix, v.Elem().Interface(), collectionType)
                                return</span>

                        case reflect.Int, reflect.Int8, reflect.Int16,
                                reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                                value = strconv.FormatInt(v.Int(), 10)</span>
                        case reflect.Uint, reflect.Uint8, reflect.Uint16,
                                reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov0" title="0">
                                value = strconv.FormatUint(v.Uint(), 10)</span>
                        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                                value = strconv.FormatFloat(v.Float(), 'g', -1, 32)</span>
                        case reflect.Bool:<span class="cov0" title="0">
                                value = strconv.FormatBool(v.Bool())</span>
                        case reflect.String:<span class="cov0" title="0">
                                value = v.String()</span>
                        default:<span class="cov0" title="0">
                                value = v.Type().String() + " value"</span>
                }
        }

        <span class="cov0" title="0">switch valuesMap := headerOrQueryParams.(type) </span>{
                case url.Values:<span class="cov0" title="0">
                        if collectionType == "csv" &amp;&amp; valuesMap.Get(keyPrefix) != "" </span><span class="cov0" title="0">{
                                valuesMap.Set(keyPrefix, valuesMap.Get(keyPrefix) + "," + value)
                        }</span> else<span class="cov0" title="0"> {
                                valuesMap.Add(keyPrefix, value)
                        }</span>
                        <span class="cov0" title="0">break</span>
                case map[string]string:<span class="cov0" title="0">
                        valuesMap[keyPrefix] = value
                        break</span>
        }
}

// helper for converting interface{} parameters to json strings
func parameterToJson(obj interface{}) (string, error) <span class="cov0" title="0">{
        jsonBuf, err := json.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(jsonBuf), err</span>
}

// callAPI do the request.
func (c *APIClient) callAPI(request *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        if c.cfg.Debug </span><span class="cov0" title="0">{
                dump, err := httputil.DumpRequestOut(request, true)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">log.Printf("\n%s\n", string(dump))</span>
        }

        <span class="cov0" title="0">resp, err := c.cfg.HTTPClient.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">if c.cfg.Debug </span><span class="cov0" title="0">{
                dump, err := httputil.DumpResponse(resp, true)
                if err != nil </span><span class="cov0" title="0">{
                        return resp, err
                }</span>
                <span class="cov0" title="0">log.Printf("\n%s\n", string(dump))</span>
        }
        <span class="cov0" title="0">return resp, err</span>
}

// Allow modification of underlying config for alternate implementations and testing
// Caution: modifying the configuration while live can cause data races and potentially unwanted behavior
func (c *APIClient) GetConfig() *Configuration <span class="cov0" title="0">{
        return c.cfg
}</span>

type formFile struct {
                fileBytes []byte
                fileName string
                formFileName string
}

// prepareRequest build the request
func (c *APIClient) prepareRequest(
        ctx context.Context,
        path string, method string,
        postBody interface{},
        headerParams map[string]string,
        queryParams url.Values,
        formParams url.Values,
        formFiles []formFile) (localVarRequest *http.Request, err error) <span class="cov0" title="0">{

        var body *bytes.Buffer

        // Detect postBody type and post.
        if postBody != nil </span><span class="cov0" title="0">{
                contentType := headerParams["Content-Type"]
                if contentType == "" </span><span class="cov0" title="0">{
                        contentType = detectContentType(postBody)
                        headerParams["Content-Type"] = contentType
                }</span>

                <span class="cov0" title="0">body, err = setBody(postBody, contentType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // add form parameters and file if available.
        <span class="cov0" title="0">if strings.HasPrefix(headerParams["Content-Type"], "multipart/form-data") &amp;&amp; len(formParams) &gt; 0 || (len(formFiles) &gt; 0) </span><span class="cov0" title="0">{
                if body != nil </span><span class="cov0" title="0">{
                        return nil, errors.New("Cannot specify postBody and multipart form at the same time.")
                }</span>
                <span class="cov0" title="0">body = &amp;bytes.Buffer{}
                w := multipart.NewWriter(body)

                for k, v := range formParams </span><span class="cov0" title="0">{
                        for _, iv := range v </span><span class="cov0" title="0">{
                                if strings.HasPrefix(k, "@") </span><span class="cov0" title="0">{ // file
                                        err = addFile(w, k[1:], iv)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                } else<span class="cov0" title="0"> { // form value
                                        w.WriteField(k, iv)
                                }</span>
                        }
                }
                <span class="cov0" title="0">for _, formFile := range formFiles </span><span class="cov0" title="0">{
                        if len(formFile.fileBytes) &gt; 0 &amp;&amp; formFile.fileName != "" </span><span class="cov0" title="0">{
                                w.Boundary()
                                part, err := w.CreateFormFile(formFile.formFileName, filepath.Base(formFile.fileName))
                                if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                }</span>
                                <span class="cov0" title="0">_, err = part.Write(formFile.fileBytes)
                                if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                }</span>
                        }
                }

                // Set the Boundary in the Content-Type
                <span class="cov0" title="0">headerParams["Content-Type"] = w.FormDataContentType()

                // Set Content-Length
                headerParams["Content-Length"] = fmt.Sprintf("%d", body.Len())
                w.Close()</span>
        }

        <span class="cov0" title="0">if strings.HasPrefix(headerParams["Content-Type"], "application/x-www-form-urlencoded") &amp;&amp; len(formParams) &gt; 0 </span><span class="cov0" title="0">{
                if body != nil </span><span class="cov0" title="0">{
                        return nil, errors.New("Cannot specify postBody and x-www-form-urlencoded form at the same time.")
                }</span>
                <span class="cov0" title="0">body = &amp;bytes.Buffer{}
                body.WriteString(formParams.Encode())
                // Set Content-Length
                headerParams["Content-Length"] = fmt.Sprintf("%d", body.Len())</span>
        }

        // Setup path and query parameters
        <span class="cov0" title="0">url, err := url.Parse(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Override request host, if applicable
        <span class="cov0" title="0">if c.cfg.Host != "" </span><span class="cov0" title="0">{
                url.Host = c.cfg.Host
        }</span>

        // Override request scheme, if applicable
        <span class="cov0" title="0">if c.cfg.Scheme != "" </span><span class="cov0" title="0">{
                url.Scheme = c.cfg.Scheme
        }</span>

        // Adding Query Param
        <span class="cov0" title="0">query := url.Query()
        for k, v := range queryParams </span><span class="cov0" title="0">{
                for _, iv := range v </span><span class="cov0" title="0">{
                        query.Add(k, iv)
                }</span>
        }

        // Encode the parameters.
        <span class="cov0" title="0">url.RawQuery = queryParamSplit.ReplaceAllStringFunc(query.Encode(), func(s string) string </span><span class="cov0" title="0">{
                pieces := strings.Split(s, "=")
                pieces[0] = queryDescape.Replace(pieces[0])
                return strings.Join(pieces, "=")
        }</span>)

        // Generate a new request
        <span class="cov0" title="0">if body != nil </span><span class="cov0" title="0">{
                localVarRequest, err = http.NewRequest(method, url.String(), body)
        }</span> else<span class="cov0" title="0"> {
                localVarRequest, err = http.NewRequest(method, url.String(), nil)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // add header parameters, if any
        <span class="cov0" title="0">if len(headerParams) &gt; 0 </span><span class="cov0" title="0">{
                headers := http.Header{}
                for h, v := range headerParams </span><span class="cov0" title="0">{
                        headers[h] = []string{v}
                }</span>
                <span class="cov0" title="0">localVarRequest.Header = headers</span>
        }

        // Add the user agent to the request.
        <span class="cov0" title="0">localVarRequest.Header.Add("User-Agent", c.cfg.UserAgent)

        if ctx != nil </span><span class="cov0" title="0">{
                // add context to the request
                localVarRequest = localVarRequest.WithContext(ctx)

                // Walk through any authentication.

        }</span>

        <span class="cov0" title="0">for header, value := range c.cfg.DefaultHeader </span><span class="cov0" title="0">{
                localVarRequest.Header.Add(header, value)
        }</span>
        <span class="cov0" title="0">return localVarRequest, nil</span>
}

func (c *APIClient) decode(v interface{}, b []byte, contentType string) (err error) <span class="cov0" title="0">{
        if len(b) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if s, ok := v.(*string); ok </span><span class="cov0" title="0">{
                *s = string(b)
                return nil
        }</span>
        <span class="cov0" title="0">if f, ok := v.(*os.File); ok </span><span class="cov0" title="0">{
                f, err = os.CreateTemp("", "HttpClientFile")
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">_, err = f.Write(b)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">_, err = f.Seek(0, io.SeekStart)
                return</span>
        }
        <span class="cov0" title="0">if f, ok := v.(**os.File); ok </span><span class="cov0" title="0">{
                *f, err = os.CreateTemp("", "HttpClientFile")
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">_, err = (*f).Write(b)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">_, err = (*f).Seek(0, io.SeekStart)
                return</span>
        }
        <span class="cov0" title="0">if XmlCheck.MatchString(contentType) </span><span class="cov0" title="0">{
                if err = xml.Unmarshal(b, v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">if JsonCheck.MatchString(contentType) </span><span class="cov0" title="0">{
                if actualObj, ok := v.(interface{ GetActualInstance() interface{} }); ok </span><span class="cov0" title="0">{ // oneOf, anyOf schemas
                        if unmarshalObj, ok := actualObj.(interface{ UnmarshalJSON([]byte) error }); ok </span><span class="cov0" title="0">{ // make sure it has UnmarshalJSON defined
                                if err = unmarshalObj.UnmarshalJSON(b); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return errors.New("Unknown type with GetActualInstance but no unmarshalObj.UnmarshalJSON defined")
                        }</span>
                } else<span class="cov0" title="0"> if err = json.Unmarshal(b, v); err != nil </span><span class="cov0" title="0">{ // simple model
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">return errors.New("undefined response type")</span>
}

// Add a file to the multipart request
func addFile(w *multipart.Writer, fieldName, path string) error <span class="cov0" title="0">{
        file, err := os.Open(filepath.Clean(path))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = file.Close()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">part, err := w.CreateFormFile(fieldName, filepath.Base(path))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = io.Copy(part, file)

        return err</span>
}

// Set request body from an interface{}
func setBody(body interface{}, contentType string) (bodyBuf *bytes.Buffer, err error) <span class="cov0" title="0">{
        if bodyBuf == nil </span><span class="cov0" title="0">{
                bodyBuf = &amp;bytes.Buffer{}
        }</span>

        <span class="cov0" title="0">if reader, ok := body.(io.Reader); ok </span><span class="cov0" title="0">{
                _, err = bodyBuf.ReadFrom(reader)
        }</span> else<span class="cov0" title="0"> if fp, ok := body.(*os.File); ok </span><span class="cov0" title="0">{
                _, err = bodyBuf.ReadFrom(fp)
        }</span> else<span class="cov0" title="0"> if b, ok := body.([]byte); ok </span><span class="cov0" title="0">{
                _, err = bodyBuf.Write(b)
        }</span> else<span class="cov0" title="0"> if s, ok := body.(string); ok </span><span class="cov0" title="0">{
                _, err = bodyBuf.WriteString(s)
        }</span> else<span class="cov0" title="0"> if s, ok := body.(*string); ok </span><span class="cov0" title="0">{
                _, err = bodyBuf.WriteString(*s)
        }</span> else<span class="cov0" title="0"> if JsonCheck.MatchString(contentType) </span><span class="cov0" title="0">{
                err = json.NewEncoder(bodyBuf).Encode(body)
        }</span> else<span class="cov0" title="0"> if XmlCheck.MatchString(contentType) </span><span class="cov0" title="0">{
                var bs []byte
                bs, err = xml.Marshal(body)
                if err == nil </span><span class="cov0" title="0">{
                        bodyBuf.Write(bs)
                }</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if bodyBuf.Len() == 0 </span><span class="cov0" title="0">{
                err = fmt.Errorf("invalid body type %s\n", contentType)
                return nil, err
        }</span>
        <span class="cov0" title="0">return bodyBuf, nil</span>
}

// detectContentType method is used to figure out `Request.Body` content type for request header
func detectContentType(body interface{}) string <span class="cov0" title="0">{
        contentType := "text/plain; charset=utf-8"
        kind := reflect.TypeOf(body).Kind()

        switch kind </span>{
        case reflect.Struct, reflect.Map, reflect.Ptr:<span class="cov0" title="0">
                contentType = "application/json; charset=utf-8"</span>
        case reflect.String:<span class="cov0" title="0">
                contentType = "text/plain; charset=utf-8"</span>
        default:<span class="cov0" title="0">
                if b, ok := body.([]byte); ok </span><span class="cov0" title="0">{
                        contentType = http.DetectContentType(b)
                }</span> else<span class="cov0" title="0"> if kind == reflect.Slice </span><span class="cov0" title="0">{
                        contentType = "application/json; charset=utf-8"
                }</span>
        }

        <span class="cov0" title="0">return contentType</span>
}

// Ripped from https://github.com/gregjones/httpcache/blob/master/httpcache.go
type cacheControl map[string]string

func parseCacheControl(headers http.Header) cacheControl <span class="cov0" title="0">{
        cc := cacheControl{}
        ccHeader := headers.Get("Cache-Control")
        for _, part := range strings.Split(ccHeader, ",") </span><span class="cov0" title="0">{
                part = strings.Trim(part, " ")
                if part == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if strings.ContainsRune(part, '=') </span><span class="cov0" title="0">{
                        keyval := strings.Split(part, "=")
                        cc[strings.Trim(keyval[0], " ")] = strings.Trim(keyval[1], ",")
                }</span> else<span class="cov0" title="0"> {
                        cc[part] = ""
                }</span>
        }
        <span class="cov0" title="0">return cc</span>
}

// CacheExpires helper function to determine remaining time before repeating a request.
func CacheExpires(r *http.Response) time.Time <span class="cov0" title="0">{
        // Figure out when the cache expires.
        var expires time.Time
        now, err := time.Parse(time.RFC1123, r.Header.Get("date"))
        if err != nil </span><span class="cov0" title="0">{
                return time.Now()
        }</span>
        <span class="cov0" title="0">respCacheControl := parseCacheControl(r.Header)

        if maxAge, ok := respCacheControl["max-age"]; ok </span><span class="cov0" title="0">{
                lifetime, err := time.ParseDuration(maxAge + "s")
                if err != nil </span><span class="cov0" title="0">{
                        expires = now
                }</span> else<span class="cov0" title="0"> {
                        expires = now.Add(lifetime)
                }</span>
        } else<span class="cov0" title="0"> {
                expiresHeader := r.Header.Get("Expires")
                if expiresHeader != "" </span><span class="cov0" title="0">{
                        expires, err = time.Parse(time.RFC1123, expiresHeader)
                        if err != nil </span><span class="cov0" title="0">{
                                expires = now
                        }</span>
                }
        }
        <span class="cov0" title="0">return expires</span>
}

func strlen(s string) int <span class="cov0" title="0">{
        return utf8.RuneCountInString(s)
}</span>

// GenericOpenAPIError Provides access to the body, error and model on returned errors.
type GenericOpenAPIError struct {
        body  []byte
        error string
        model interface{}
}

// Error returns non-empty string if there was an error.
func (e GenericOpenAPIError) Error() string <span class="cov0" title="0">{
        return e.error
}</span>

// Body returns the raw bytes of the response
func (e GenericOpenAPIError) Body() []byte <span class="cov0" title="0">{
        return e.body
}</span>

// Model returns the unpacked model of the error
func (e GenericOpenAPIError) Model() interface{} <span class="cov0" title="0">{
        return e.model
}</span>

// format error message using title and detail when model implements rfc7807
func formatErrorMessage(status string, v interface{}) string <span class="cov0" title="0">{
        str := ""
        metaValue := reflect.ValueOf(v).Elem()

        if metaValue.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                field := metaValue.FieldByName("Title")
                if field != (reflect.Value{}) </span><span class="cov0" title="0">{
                        str = fmt.Sprintf("%s", field.Interface())
                }</span>

                <span class="cov0" title="0">field = metaValue.FieldByName("Detail")
                if field != (reflect.Value{}) </span><span class="cov0" title="0">{
                        str = fmt.Sprintf("%s (%s)", str, field.Interface())
                }</span>
        }

        <span class="cov0" title="0">return strings.TrimSpace(fmt.Sprintf("%s %s", status, str))</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">/*
Payment Service

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mock_payment

import (
        "context"
        "fmt"
        "net/http"
        "strings"
)

// contextKeys are used to identify the type of value in the context.
// Since these are string, it is possible to get a short description of the
// context key for logging and debugging using key.String().

type contextKey string

func (c contextKey) String() string <span class="cov0" title="0">{
        return "auth " + string(c)
}</span>

var (
        // ContextServerIndex uses a server configuration from the index.
        ContextServerIndex = contextKey("serverIndex")

        // ContextOperationServerIndices uses a server configuration from the index mapping.
        ContextOperationServerIndices = contextKey("serverOperationIndices")

        // ContextServerVariables overrides a server configuration variables.
        ContextServerVariables = contextKey("serverVariables")

        // ContextOperationServerVariables overrides a server configuration variables using operation specific values.
        ContextOperationServerVariables = contextKey("serverOperationVariables")
)

// BasicAuth provides basic http authentication to a request passed via context using ContextBasicAuth
type BasicAuth struct {
        UserName string `json:"userName,omitempty"`
        Password string `json:"password,omitempty"`
}

// APIKey provides API key based authentication to a request passed via context using ContextAPIKey
type APIKey struct {
        Key    string
        Prefix string
}

// ServerVariable stores the information about a server variable
type ServerVariable struct {
        Description  string
        DefaultValue string
        EnumValues   []string
}

// ServerConfiguration stores the information about a server
type ServerConfiguration struct {
        URL string
        Description string
        Variables map[string]ServerVariable
}

// ServerConfigurations stores multiple ServerConfiguration items
type ServerConfigurations []ServerConfiguration

// Configuration stores the configuration of the API client
type Configuration struct {
        Host             string            `json:"host,omitempty"`
        Scheme           string            `json:"scheme,omitempty"`
        DefaultHeader    map[string]string `json:"defaultHeader,omitempty"`
        UserAgent        string            `json:"userAgent,omitempty"`
        Debug            bool              `json:"debug,omitempty"`
        Servers          ServerConfigurations
        OperationServers map[string]ServerConfigurations
        HTTPClient       *http.Client
}

// NewConfiguration returns a new Configuration object
func NewConfiguration() *Configuration <span class="cov0" title="0">{
        cfg := &amp;Configuration{
                DefaultHeader:    make(map[string]string),
                UserAgent:        "OpenAPI-Generator/1.0.0/go",
                Debug:            false,
                Servers:          ServerConfigurations{
                        {
                                URL: "{protocol}://{server}",
                                Description: "environment",
                                Variables: map[string]ServerVariable{
                                        "protocol": ServerVariable{
                                                Description: "No description provided",
                                                DefaultValue: "https",
                                                EnumValues: []string{
                                                        "http",
                                                        "https",
                                                },
                                        },
                                        "server": ServerVariable{
                                                Description: "No description provided",
                                                DefaultValue: "localhost:3000",
                                        },
                                },
                        },
                },
                OperationServers: map[string]ServerConfigurations{
                },
        }
        return cfg
}</span>

// AddDefaultHeader adds a new HTTP header to the default header in the request
func (c *Configuration) AddDefaultHeader(key string, value string) <span class="cov0" title="0">{
        c.DefaultHeader[key] = value
}</span>

// URL formats template on a index using given variables
func (sc ServerConfigurations) URL(index int, variables map[string]string) (string, error) <span class="cov0" title="0">{
        if index &lt; 0 || len(sc) &lt;= index </span><span class="cov0" title="0">{
                return "", fmt.Errorf("index %v out of range %v", index, len(sc)-1)
        }</span>
        <span class="cov0" title="0">server := sc[index]
        url := server.URL

        // go through variables and replace placeholders
        for name, variable := range server.Variables </span><span class="cov0" title="0">{
                if value, ok := variables[name]; ok </span><span class="cov0" title="0">{
                        found := bool(len(variable.EnumValues) == 0)
                        for _, enumValue := range variable.EnumValues </span><span class="cov0" title="0">{
                                if value == enumValue </span><span class="cov0" title="0">{
                                        found = true
                                }</span>
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("the variable %s in the server URL has invalid value %v. Must be %v", name, value, variable.EnumValues)
                        }</span>
                        <span class="cov0" title="0">url = strings.Replace(url, "{"+name+"}", value, -1)</span>
                } else<span class="cov0" title="0"> {
                        url = strings.Replace(url, "{"+name+"}", variable.DefaultValue, -1)
                }</span>
        }
        <span class="cov0" title="0">return url, nil</span>
}

// ServerURL returns URL based on server settings
func (c *Configuration) ServerURL(index int, variables map[string]string) (string, error) <span class="cov0" title="0">{
        return c.Servers.URL(index, variables)
}</span>

func getServerIndex(ctx context.Context) (int, error) <span class="cov0" title="0">{
        si := ctx.Value(ContextServerIndex)
        if si != nil </span><span class="cov0" title="0">{
                if index, ok := si.(int); ok </span><span class="cov0" title="0">{
                        return index, nil
                }</span>
                <span class="cov0" title="0">return 0, reportError("Invalid type %T should be int", si)</span>
        }
        <span class="cov0" title="0">return 0, nil</span>
}

func getServerOperationIndex(ctx context.Context, endpoint string) (int, error) <span class="cov0" title="0">{
        osi := ctx.Value(ContextOperationServerIndices)
        if osi != nil </span><span class="cov0" title="0">{
                if operationIndices, ok := osi.(map[string]int); !ok </span><span class="cov0" title="0">{
                        return 0, reportError("Invalid type %T should be map[string]int", osi)
                }</span> else<span class="cov0" title="0"> {
                        index, ok := operationIndices[endpoint]
                        if ok </span><span class="cov0" title="0">{
                                return index, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return getServerIndex(ctx)</span>
}

func getServerVariables(ctx context.Context) (map[string]string, error) <span class="cov0" title="0">{
        sv := ctx.Value(ContextServerVariables)
        if sv != nil </span><span class="cov0" title="0">{
                if variables, ok := sv.(map[string]string); ok </span><span class="cov0" title="0">{
                        return variables, nil
                }</span>
                <span class="cov0" title="0">return nil, reportError("ctx value of ContextServerVariables has invalid type %T should be map[string]string", sv)</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}

func getServerOperationVariables(ctx context.Context, endpoint string) (map[string]string, error) <span class="cov0" title="0">{
        osv := ctx.Value(ContextOperationServerVariables)
        if osv != nil </span><span class="cov0" title="0">{
                if operationVariables, ok := osv.(map[string]map[string]string); !ok </span><span class="cov0" title="0">{
                        return nil, reportError("ctx value of ContextOperationServerVariables has invalid type %T should be map[string]map[string]string", osv)
                }</span> else<span class="cov0" title="0"> {
                        variables, ok := operationVariables[endpoint]
                        if ok </span><span class="cov0" title="0">{
                                return variables, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return getServerVariables(ctx)</span>
}

// ServerURLWithContext returns a new server URL given an endpoint
func (c *Configuration) ServerURLWithContext(ctx context.Context, endpoint string) (string, error) <span class="cov0" title="0">{
        sc, ok := c.OperationServers[endpoint]
        if !ok </span><span class="cov0" title="0">{
                sc = c.Servers
        }</span>

        <span class="cov0" title="0">if ctx == nil </span><span class="cov0" title="0">{
                return sc.URL(0, nil)
        }</span>

        <span class="cov0" title="0">index, err := getServerOperationIndex(ctx, endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">variables, err := getServerOperationVariables(ctx, endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return sc.URL(index, variables)</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">/*
Payment Service

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mock_payment

import (
        "encoding/json"
        "bytes"
        "fmt"
)

// checks if the InvoicesIdGet404Response type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &amp;InvoicesIdGet404Response{}

// InvoicesIdGet404Response struct for InvoicesIdGet404Response
type InvoicesIdGet404Response struct {
        Message string `json:"message"`
}

type _InvoicesIdGet404Response InvoicesIdGet404Response

// NewInvoicesIdGet404Response instantiates a new InvoicesIdGet404Response object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewInvoicesIdGet404Response(message string) *InvoicesIdGet404Response <span class="cov0" title="0">{
        this := InvoicesIdGet404Response{}
        this.Message = message
        return &amp;this
}</span>

// NewInvoicesIdGet404ResponseWithDefaults instantiates a new InvoicesIdGet404Response object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewInvoicesIdGet404ResponseWithDefaults() *InvoicesIdGet404Response <span class="cov0" title="0">{
        this := InvoicesIdGet404Response{}
        return &amp;this
}</span>

// GetMessage returns the Message field value
func (o *InvoicesIdGet404Response) GetMessage() string <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                var ret string
                return ret
        }</span>

        <span class="cov0" title="0">return o.Message</span>
}

// GetMessageOk returns a tuple with the Message field value
// and a boolean to check if the value has been set.
func (o *InvoicesIdGet404Response) GetMessageOk() (*string, bool) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return &amp;o.Message, true</span>
}

// SetMessage sets field value
func (o *InvoicesIdGet404Response) SetMessage(v string) <span class="cov0" title="0">{
        o.Message = v
}</span>

func (o InvoicesIdGet404Response) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        toSerialize,err := o.ToMap()
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}, err
        }</span>
        <span class="cov0" title="0">return json.Marshal(toSerialize)</span>
}

func (o InvoicesIdGet404Response) ToMap() (map[string]interface{}, error) <span class="cov0" title="0">{
        toSerialize := map[string]interface{}{}
        toSerialize["message"] = o.Message
        return toSerialize, nil
}</span>

func (o *InvoicesIdGet404Response) UnmarshalJSON(data []byte) (err error) <span class="cov0" title="0">{
        // This validates that all required properties are included in the JSON object
        // by unmarshalling the object into a generic map with string keys and checking
        // that every required field exists as a key in the generic map.
        requiredProperties := []string{
                "message",
        }

        allProperties := make(map[string]interface{})

        err = json.Unmarshal(data, &amp;allProperties)

        if err != nil </span><span class="cov0" title="0">{
                return err;
        }</span>

        <span class="cov0" title="0">for _, requiredProperty := range(requiredProperties) </span><span class="cov0" title="0">{
                if _, exists := allProperties[requiredProperty]; !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("no value given for required property %v", requiredProperty)
                }</span>
        }

        <span class="cov0" title="0">varInvoicesIdGet404Response := _InvoicesIdGet404Response{}

        decoder := json.NewDecoder(bytes.NewReader(data))
        decoder.DisallowUnknownFields()
        err = decoder.Decode(&amp;varInvoicesIdGet404Response)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*o = InvoicesIdGet404Response(varInvoicesIdGet404Response)

        return err</span>
}

type NullableInvoicesIdGet404Response struct {
        value *InvoicesIdGet404Response
        isSet bool
}

func (v NullableInvoicesIdGet404Response) Get() *InvoicesIdGet404Response <span class="cov0" title="0">{
        return v.value
}</span>

func (v *NullableInvoicesIdGet404Response) Set(val *InvoicesIdGet404Response) <span class="cov0" title="0">{
        v.value = val
        v.isSet = true
}</span>

func (v NullableInvoicesIdGet404Response) IsSet() bool <span class="cov0" title="0">{
        return v.isSet
}</span>

func (v *NullableInvoicesIdGet404Response) Unset() <span class="cov0" title="0">{
        v.value = nil
        v.isSet = false
}</span>

func NewNullableInvoicesIdGet404Response(val *InvoicesIdGet404Response) *NullableInvoicesIdGet404Response <span class="cov0" title="0">{
        return &amp;NullableInvoicesIdGet404Response{value: val, isSet: true}
}</span>

func (v NullableInvoicesIdGet404Response) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(v.value)
}</span>

func (v *NullableInvoicesIdGet404Response) UnmarshalJSON(src []byte) error <span class="cov0" title="0">{
        v.isSet = true
        return json.Unmarshal(src, &amp;v.value)
}</span>


</pre>
		
		<pre class="file" id="file71" style="display: none">/*
Payment Service

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mock_payment

import (
        "encoding/json"
        "bytes"
        "fmt"
)

// checks if the CreateInvoiceRequest type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &amp;CreateInvoiceRequest{}

// CreateInvoiceRequest struct for CreateInvoiceRequest
type CreateInvoiceRequest struct {
        Amount float32 `json:"amount"`
        Description *string `json:"description,omitempty"`
        ExternalId string `json:"externalId"`
}

type _CreateInvoiceRequest CreateInvoiceRequest

// NewCreateInvoiceRequest instantiates a new CreateInvoiceRequest object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewCreateInvoiceRequest(amount float32, externalId string) *CreateInvoiceRequest <span class="cov0" title="0">{
        this := CreateInvoiceRequest{}
        this.Amount = amount
        var description string = ""
        this.Description = &amp;description
        this.ExternalId = externalId
        return &amp;this
}</span>

// NewCreateInvoiceRequestWithDefaults instantiates a new CreateInvoiceRequest object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewCreateInvoiceRequestWithDefaults() *CreateInvoiceRequest <span class="cov0" title="0">{
        this := CreateInvoiceRequest{}
        var description string = ""
        this.Description = &amp;description
        return &amp;this
}</span>

// GetAmount returns the Amount field value
func (o *CreateInvoiceRequest) GetAmount() float32 <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                var ret float32
                return ret
        }</span>

        <span class="cov0" title="0">return o.Amount</span>
}

// GetAmountOk returns a tuple with the Amount field value
// and a boolean to check if the value has been set.
func (o *CreateInvoiceRequest) GetAmountOk() (*float32, bool) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return &amp;o.Amount, true</span>
}

// SetAmount sets field value
func (o *CreateInvoiceRequest) SetAmount(v float32) <span class="cov0" title="0">{
        o.Amount = v
}</span>

// GetDescription returns the Description field value if set, zero value otherwise.
func (o *CreateInvoiceRequest) GetDescription() string <span class="cov0" title="0">{
        if o == nil || IsNil(o.Description) </span><span class="cov0" title="0">{
                var ret string
                return ret
        }</span>
        <span class="cov0" title="0">return *o.Description</span>
}

// GetDescriptionOk returns a tuple with the Description field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *CreateInvoiceRequest) GetDescriptionOk() (*string, bool) <span class="cov0" title="0">{
        if o == nil || IsNil(o.Description) </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return o.Description, true</span>
}

// HasDescription returns a boolean if a field has been set.
func (o *CreateInvoiceRequest) HasDescription() bool <span class="cov0" title="0">{
        if o != nil &amp;&amp; !IsNil(o.Description) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// SetDescription gets a reference to the given string and assigns it to the Description field.
func (o *CreateInvoiceRequest) SetDescription(v string) <span class="cov0" title="0">{
        o.Description = &amp;v
}</span>

// GetExternalId returns the ExternalId field value
func (o *CreateInvoiceRequest) GetExternalId() string <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                var ret string
                return ret
        }</span>

        <span class="cov0" title="0">return o.ExternalId</span>
}

// GetExternalIdOk returns a tuple with the ExternalId field value
// and a boolean to check if the value has been set.
func (o *CreateInvoiceRequest) GetExternalIdOk() (*string, bool) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return &amp;o.ExternalId, true</span>
}

// SetExternalId sets field value
func (o *CreateInvoiceRequest) SetExternalId(v string) <span class="cov0" title="0">{
        o.ExternalId = v
}</span>

func (o CreateInvoiceRequest) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        toSerialize,err := o.ToMap()
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}, err
        }</span>
        <span class="cov0" title="0">return json.Marshal(toSerialize)</span>
}

func (o CreateInvoiceRequest) ToMap() (map[string]interface{}, error) <span class="cov0" title="0">{
        toSerialize := map[string]interface{}{}
        toSerialize["amount"] = o.Amount
        if !IsNil(o.Description) </span><span class="cov0" title="0">{
                toSerialize["description"] = o.Description
        }</span>
        <span class="cov0" title="0">toSerialize["externalId"] = o.ExternalId
        return toSerialize, nil</span>
}

func (o *CreateInvoiceRequest) UnmarshalJSON(data []byte) (err error) <span class="cov0" title="0">{
        // This validates that all required properties are included in the JSON object
        // by unmarshalling the object into a generic map with string keys and checking
        // that every required field exists as a key in the generic map.
        requiredProperties := []string{
                "amount",
                "externalId",
        }

        allProperties := make(map[string]interface{})

        err = json.Unmarshal(data, &amp;allProperties)

        if err != nil </span><span class="cov0" title="0">{
                return err;
        }</span>

        <span class="cov0" title="0">for _, requiredProperty := range(requiredProperties) </span><span class="cov0" title="0">{
                if _, exists := allProperties[requiredProperty]; !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("no value given for required property %v", requiredProperty)
                }</span>
        }

        <span class="cov0" title="0">varCreateInvoiceRequest := _CreateInvoiceRequest{}

        decoder := json.NewDecoder(bytes.NewReader(data))
        decoder.DisallowUnknownFields()
        err = decoder.Decode(&amp;varCreateInvoiceRequest)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*o = CreateInvoiceRequest(varCreateInvoiceRequest)

        return err</span>
}

type NullableCreateInvoiceRequest struct {
        value *CreateInvoiceRequest
        isSet bool
}

func (v NullableCreateInvoiceRequest) Get() *CreateInvoiceRequest <span class="cov0" title="0">{
        return v.value
}</span>

func (v *NullableCreateInvoiceRequest) Set(val *CreateInvoiceRequest) <span class="cov0" title="0">{
        v.value = val
        v.isSet = true
}</span>

func (v NullableCreateInvoiceRequest) IsSet() bool <span class="cov0" title="0">{
        return v.isSet
}</span>

func (v *NullableCreateInvoiceRequest) Unset() <span class="cov0" title="0">{
        v.value = nil
        v.isSet = false
}</span>

func NewNullableCreateInvoiceRequest(val *CreateInvoiceRequest) *NullableCreateInvoiceRequest <span class="cov0" title="0">{
        return &amp;NullableCreateInvoiceRequest{value: val, isSet: true}
}</span>

func (v NullableCreateInvoiceRequest) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(v.value)
}</span>

func (v *NullableCreateInvoiceRequest) UnmarshalJSON(src []byte) error <span class="cov0" title="0">{
        v.isSet = true
        return json.Unmarshal(src, &amp;v.value)
}</span>


</pre>
		
		<pre class="file" id="file72" style="display: none">/*
Payment Service

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mock_payment

import (
        "encoding/json"
        "bytes"
        "fmt"
)

// checks if the Invoice type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &amp;Invoice{}

// Invoice struct for Invoice
type Invoice struct {
        Id string `json:"id"`
        Amount float32 `json:"amount"`
        Description *string `json:"description,omitempty"`
        ExternalId string `json:"externalId"`
        CreatedAt NullableString `json:"createdAt"`
        ExpiredAt NullableString `json:"expiredAt"`
        PaidAt NullableString `json:"paidAt"`
        PaidAmount NullableFloat32 `json:"paidAmount"`
        Status string `json:"status"`
}

type _Invoice Invoice

// NewInvoice instantiates a new Invoice object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewInvoice(id string, amount float32, externalId string, createdAt NullableString, expiredAt NullableString, paidAt NullableString, paidAmount NullableFloat32, status string) *Invoice <span class="cov0" title="0">{
        this := Invoice{}
        this.Id = id
        this.Amount = amount
        var description string = ""
        this.Description = &amp;description
        this.ExternalId = externalId
        this.CreatedAt = createdAt
        this.ExpiredAt = expiredAt
        this.PaidAt = paidAt
        this.PaidAmount = paidAmount
        this.Status = status
        return &amp;this
}</span>

// NewInvoiceWithDefaults instantiates a new Invoice object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewInvoiceWithDefaults() *Invoice <span class="cov0" title="0">{
        this := Invoice{}
        var description string = ""
        this.Description = &amp;description
        return &amp;this
}</span>

// GetId returns the Id field value
func (o *Invoice) GetId() string <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                var ret string
                return ret
        }</span>

        <span class="cov0" title="0">return o.Id</span>
}

// GetIdOk returns a tuple with the Id field value
// and a boolean to check if the value has been set.
func (o *Invoice) GetIdOk() (*string, bool) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return &amp;o.Id, true</span>
}

// SetId sets field value
func (o *Invoice) SetId(v string) <span class="cov0" title="0">{
        o.Id = v
}</span>

// GetAmount returns the Amount field value
func (o *Invoice) GetAmount() float32 <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                var ret float32
                return ret
        }</span>

        <span class="cov0" title="0">return o.Amount</span>
}

// GetAmountOk returns a tuple with the Amount field value
// and a boolean to check if the value has been set.
func (o *Invoice) GetAmountOk() (*float32, bool) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return &amp;o.Amount, true</span>
}

// SetAmount sets field value
func (o *Invoice) SetAmount(v float32) <span class="cov0" title="0">{
        o.Amount = v
}</span>

// GetDescription returns the Description field value if set, zero value otherwise.
func (o *Invoice) GetDescription() string <span class="cov0" title="0">{
        if o == nil || IsNil(o.Description) </span><span class="cov0" title="0">{
                var ret string
                return ret
        }</span>
        <span class="cov0" title="0">return *o.Description</span>
}

// GetDescriptionOk returns a tuple with the Description field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Invoice) GetDescriptionOk() (*string, bool) <span class="cov0" title="0">{
        if o == nil || IsNil(o.Description) </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return o.Description, true</span>
}

// HasDescription returns a boolean if a field has been set.
func (o *Invoice) HasDescription() bool <span class="cov0" title="0">{
        if o != nil &amp;&amp; !IsNil(o.Description) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// SetDescription gets a reference to the given string and assigns it to the Description field.
func (o *Invoice) SetDescription(v string) <span class="cov0" title="0">{
        o.Description = &amp;v
}</span>

// GetExternalId returns the ExternalId field value
func (o *Invoice) GetExternalId() string <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                var ret string
                return ret
        }</span>

        <span class="cov0" title="0">return o.ExternalId</span>
}

// GetExternalIdOk returns a tuple with the ExternalId field value
// and a boolean to check if the value has been set.
func (o *Invoice) GetExternalIdOk() (*string, bool) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return &amp;o.ExternalId, true</span>
}

// SetExternalId sets field value
func (o *Invoice) SetExternalId(v string) <span class="cov0" title="0">{
        o.ExternalId = v
}</span>

// GetCreatedAt returns the CreatedAt field value
// If the value is explicit nil, the zero value for string will be returned
func (o *Invoice) GetCreatedAt() string <span class="cov0" title="0">{
        if o == nil || o.CreatedAt.Get() == nil </span><span class="cov0" title="0">{
                var ret string
                return ret
        }</span>

        <span class="cov0" title="0">return *o.CreatedAt.Get()</span>
}

// GetCreatedAtOk returns a tuple with the CreatedAt field value
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *Invoice) GetCreatedAtOk() (*string, bool) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return o.CreatedAt.Get(), o.CreatedAt.IsSet()</span>
}

// SetCreatedAt sets field value
func (o *Invoice) SetCreatedAt(v string) <span class="cov0" title="0">{
        o.CreatedAt.Set(&amp;v)
}</span>

// GetExpiredAt returns the ExpiredAt field value
// If the value is explicit nil, the zero value for string will be returned
func (o *Invoice) GetExpiredAt() string <span class="cov0" title="0">{
        if o == nil || o.ExpiredAt.Get() == nil </span><span class="cov0" title="0">{
                var ret string
                return ret
        }</span>

        <span class="cov0" title="0">return *o.ExpiredAt.Get()</span>
}

// GetExpiredAtOk returns a tuple with the ExpiredAt field value
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *Invoice) GetExpiredAtOk() (*string, bool) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return o.ExpiredAt.Get(), o.ExpiredAt.IsSet()</span>
}

// SetExpiredAt sets field value
func (o *Invoice) SetExpiredAt(v string) <span class="cov0" title="0">{
        o.ExpiredAt.Set(&amp;v)
}</span>

// GetPaidAt returns the PaidAt field value
// If the value is explicit nil, the zero value for string will be returned
func (o *Invoice) GetPaidAt() string <span class="cov0" title="0">{
        if o == nil || o.PaidAt.Get() == nil </span><span class="cov0" title="0">{
                var ret string
                return ret
        }</span>

        <span class="cov0" title="0">return *o.PaidAt.Get()</span>
}

// GetPaidAtOk returns a tuple with the PaidAt field value
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *Invoice) GetPaidAtOk() (*string, bool) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return o.PaidAt.Get(), o.PaidAt.IsSet()</span>
}

// SetPaidAt sets field value
func (o *Invoice) SetPaidAt(v string) <span class="cov0" title="0">{
        o.PaidAt.Set(&amp;v)
}</span>

// GetPaidAmount returns the PaidAmount field value
// If the value is explicit nil, the zero value for float32 will be returned
func (o *Invoice) GetPaidAmount() float32 <span class="cov0" title="0">{
        if o == nil || o.PaidAmount.Get() == nil </span><span class="cov0" title="0">{
                var ret float32
                return ret
        }</span>

        <span class="cov0" title="0">return *o.PaidAmount.Get()</span>
}

// GetPaidAmountOk returns a tuple with the PaidAmount field value
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *Invoice) GetPaidAmountOk() (*float32, bool) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return o.PaidAmount.Get(), o.PaidAmount.IsSet()</span>
}

// SetPaidAmount sets field value
func (o *Invoice) SetPaidAmount(v float32) <span class="cov0" title="0">{
        o.PaidAmount.Set(&amp;v)
}</span>

// GetStatus returns the Status field value
func (o *Invoice) GetStatus() string <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                var ret string
                return ret
        }</span>

        <span class="cov0" title="0">return o.Status</span>
}

// GetStatusOk returns a tuple with the Status field value
// and a boolean to check if the value has been set.
func (o *Invoice) GetStatusOk() (*string, bool) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return &amp;o.Status, true</span>
}

// SetStatus sets field value
func (o *Invoice) SetStatus(v string) <span class="cov0" title="0">{
        o.Status = v
}</span>

func (o Invoice) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        toSerialize,err := o.ToMap()
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}, err
        }</span>
        <span class="cov0" title="0">return json.Marshal(toSerialize)</span>
}

func (o Invoice) ToMap() (map[string]interface{}, error) <span class="cov0" title="0">{
        toSerialize := map[string]interface{}{}
        toSerialize["id"] = o.Id
        toSerialize["amount"] = o.Amount
        if !IsNil(o.Description) </span><span class="cov0" title="0">{
                toSerialize["description"] = o.Description
        }</span>
        <span class="cov0" title="0">toSerialize["externalId"] = o.ExternalId
        toSerialize["createdAt"] = o.CreatedAt.Get()
        toSerialize["expiredAt"] = o.ExpiredAt.Get()
        toSerialize["paidAt"] = o.PaidAt.Get()
        toSerialize["paidAmount"] = o.PaidAmount.Get()
        toSerialize["status"] = o.Status
        return toSerialize, nil</span>
}

func (o *Invoice) UnmarshalJSON(data []byte) (err error) <span class="cov0" title="0">{
        // This validates that all required properties are included in the JSON object
        // by unmarshalling the object into a generic map with string keys and checking
        // that every required field exists as a key in the generic map.
        requiredProperties := []string{
                "id",
                "amount",
                "externalId",
                "createdAt",
                "expiredAt",
                "paidAt",
                "paidAmount",
                "status",
        }

        allProperties := make(map[string]interface{})

        err = json.Unmarshal(data, &amp;allProperties)

        if err != nil </span><span class="cov0" title="0">{
                return err;
        }</span>

        <span class="cov0" title="0">for _, requiredProperty := range(requiredProperties) </span><span class="cov0" title="0">{
                if _, exists := allProperties[requiredProperty]; !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("no value given for required property %v", requiredProperty)
                }</span>
        }

        <span class="cov0" title="0">varInvoice := _Invoice{}

        decoder := json.NewDecoder(bytes.NewReader(data))
        decoder.DisallowUnknownFields()
        err = decoder.Decode(&amp;varInvoice)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*o = Invoice(varInvoice)

        return err</span>
}

type NullableInvoice struct {
        value *Invoice
        isSet bool
}

func (v NullableInvoice) Get() *Invoice <span class="cov0" title="0">{
        return v.value
}</span>

func (v *NullableInvoice) Set(val *Invoice) <span class="cov0" title="0">{
        v.value = val
        v.isSet = true
}</span>

func (v NullableInvoice) IsSet() bool <span class="cov0" title="0">{
        return v.isSet
}</span>

func (v *NullableInvoice) Unset() <span class="cov0" title="0">{
        v.value = nil
        v.isSet = false
}</span>

func NewNullableInvoice(val *Invoice) *NullableInvoice <span class="cov0" title="0">{
        return &amp;NullableInvoice{value: val, isSet: true}
}</span>

func (v NullableInvoice) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(v.value)
}</span>

func (v *NullableInvoice) UnmarshalJSON(src []byte) error <span class="cov0" title="0">{
        v.isSet = true
        return json.Unmarshal(src, &amp;v.value)
}</span>


</pre>
		
		<pre class="file" id="file73" style="display: none">/*
Payment Service

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mock_payment

import (
        "encoding/json"
        "bytes"
        "fmt"
)

// checks if the PayInvoiceRequest type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &amp;PayInvoiceRequest{}

// PayInvoiceRequest struct for PayInvoiceRequest
type PayInvoiceRequest struct {
        Mode string `json:"mode"`
}

type _PayInvoiceRequest PayInvoiceRequest

// NewPayInvoiceRequest instantiates a new PayInvoiceRequest object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewPayInvoiceRequest(mode string) *PayInvoiceRequest <span class="cov0" title="0">{
        this := PayInvoiceRequest{}
        this.Mode = mode
        return &amp;this
}</span>

// NewPayInvoiceRequestWithDefaults instantiates a new PayInvoiceRequest object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewPayInvoiceRequestWithDefaults() *PayInvoiceRequest <span class="cov0" title="0">{
        this := PayInvoiceRequest{}
        return &amp;this
}</span>

// GetMode returns the Mode field value
func (o *PayInvoiceRequest) GetMode() string <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                var ret string
                return ret
        }</span>

        <span class="cov0" title="0">return o.Mode</span>
}

// GetModeOk returns a tuple with the Mode field value
// and a boolean to check if the value has been set.
func (o *PayInvoiceRequest) GetModeOk() (*string, bool) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return &amp;o.Mode, true</span>
}

// SetMode sets field value
func (o *PayInvoiceRequest) SetMode(v string) <span class="cov0" title="0">{
        o.Mode = v
}</span>

func (o PayInvoiceRequest) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        toSerialize,err := o.ToMap()
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}, err
        }</span>
        <span class="cov0" title="0">return json.Marshal(toSerialize)</span>
}

func (o PayInvoiceRequest) ToMap() (map[string]interface{}, error) <span class="cov0" title="0">{
        toSerialize := map[string]interface{}{}
        toSerialize["mode"] = o.Mode
        return toSerialize, nil
}</span>

func (o *PayInvoiceRequest) UnmarshalJSON(data []byte) (err error) <span class="cov0" title="0">{
        // This validates that all required properties are included in the JSON object
        // by unmarshalling the object into a generic map with string keys and checking
        // that every required field exists as a key in the generic map.
        requiredProperties := []string{
                "mode",
        }

        allProperties := make(map[string]interface{})

        err = json.Unmarshal(data, &amp;allProperties)

        if err != nil </span><span class="cov0" title="0">{
                return err;
        }</span>

        <span class="cov0" title="0">for _, requiredProperty := range(requiredProperties) </span><span class="cov0" title="0">{
                if _, exists := allProperties[requiredProperty]; !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("no value given for required property %v", requiredProperty)
                }</span>
        }

        <span class="cov0" title="0">varPayInvoiceRequest := _PayInvoiceRequest{}

        decoder := json.NewDecoder(bytes.NewReader(data))
        decoder.DisallowUnknownFields()
        err = decoder.Decode(&amp;varPayInvoiceRequest)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*o = PayInvoiceRequest(varPayInvoiceRequest)

        return err</span>
}

type NullablePayInvoiceRequest struct {
        value *PayInvoiceRequest
        isSet bool
}

func (v NullablePayInvoiceRequest) Get() *PayInvoiceRequest <span class="cov0" title="0">{
        return v.value
}</span>

func (v *NullablePayInvoiceRequest) Set(val *PayInvoiceRequest) <span class="cov0" title="0">{
        v.value = val
        v.isSet = true
}</span>

func (v NullablePayInvoiceRequest) IsSet() bool <span class="cov0" title="0">{
        return v.isSet
}</span>

func (v *NullablePayInvoiceRequest) Unset() <span class="cov0" title="0">{
        v.value = nil
        v.isSet = false
}</span>

func NewNullablePayInvoiceRequest(val *PayInvoiceRequest) *NullablePayInvoiceRequest <span class="cov0" title="0">{
        return &amp;NullablePayInvoiceRequest{value: val, isSet: true}
}</span>

func (v NullablePayInvoiceRequest) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(v.value)
}</span>

func (v *NullablePayInvoiceRequest) UnmarshalJSON(src []byte) error <span class="cov0" title="0">{
        v.isSet = true
        return json.Unmarshal(src, &amp;v.value)
}</span>


</pre>
		
		<pre class="file" id="file74" style="display: none">/*
Payment Service

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mock_payment

import (
        "net/http"
)

// APIResponse stores the API response returned by the server.
type APIResponse struct {
        *http.Response `json:"-"`
        Message        string `json:"message,omitempty"`
        // Operation is the name of the OpenAPI operation.
        Operation string `json:"operation,omitempty"`
        // RequestURL is the request URL. This value is always available, even if the
        // embedded *http.Response is nil.
        RequestURL string `json:"url,omitempty"`
        // Method is the HTTP method used for the request.  This value is always
        // available, even if the embedded *http.Response is nil.
        Method string `json:"method,omitempty"`
        // Payload holds the contents of the response body (which may be nil or empty).
        // This is provided here as the raw response.Body() reader will have already
        // been drained.
        Payload []byte `json:"-"`
}

// NewAPIResponse returns a new APIResponse object.
func NewAPIResponse(r *http.Response) *APIResponse <span class="cov0" title="0">{

        response := &amp;APIResponse{Response: r}
        return response
}</span>

// NewAPIResponseWithError returns a new APIResponse object with the provided error message.
func NewAPIResponseWithError(errorMessage string) *APIResponse <span class="cov0" title="0">{

        response := &amp;APIResponse{Message: errorMessage}
        return response
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">/*
Payment Service

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mock_payment

import (
        "bytes"
        "encoding/json"
        "fmt"
        "reflect"
        "time"
)

// PtrBool is a helper routine that returns a pointer to given boolean value.
func PtrBool(v bool) *bool <span class="cov0" title="0">{ return &amp;v }</span>

// PtrInt is a helper routine that returns a pointer to given integer value.
func PtrInt(v int) *int <span class="cov0" title="0">{ return &amp;v }</span>

// PtrInt32 is a helper routine that returns a pointer to given integer value.
func PtrInt32(v int32) *int32 <span class="cov0" title="0">{ return &amp;v }</span>

// PtrInt64 is a helper routine that returns a pointer to given integer value.
func PtrInt64(v int64) *int64 <span class="cov0" title="0">{ return &amp;v }</span>

// PtrFloat32 is a helper routine that returns a pointer to given float value.
func PtrFloat32(v float32) *float32 <span class="cov0" title="0">{ return &amp;v }</span>

// PtrFloat64 is a helper routine that returns a pointer to given float value.
func PtrFloat64(v float64) *float64 <span class="cov0" title="0">{ return &amp;v }</span>

// PtrString is a helper routine that returns a pointer to given string value.
func PtrString(v string) *string <span class="cov0" title="0">{ return &amp;v }</span>

// PtrTime is helper routine that returns a pointer to given Time value.
func PtrTime(v time.Time) *time.Time <span class="cov0" title="0">{ return &amp;v }</span>

type NullableBool struct {
        value *bool
        isSet bool
}

func (v NullableBool) Get() *bool <span class="cov0" title="0">{
        return v.value
}</span>

func (v *NullableBool) Set(val *bool) <span class="cov0" title="0">{
        v.value = val
        v.isSet = true
}</span>

func (v NullableBool) IsSet() bool <span class="cov0" title="0">{
        return v.isSet
}</span>

func (v *NullableBool) Unset() <span class="cov0" title="0">{
        v.value = nil
        v.isSet = false
}</span>

func NewNullableBool(val *bool) *NullableBool <span class="cov0" title="0">{
        return &amp;NullableBool{value: val, isSet: true}
}</span>

func (v NullableBool) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(v.value)
}</span>

func (v *NullableBool) UnmarshalJSON(src []byte) error <span class="cov0" title="0">{
        v.isSet = true
        return json.Unmarshal(src, &amp;v.value)
}</span>

type NullableInt struct {
        value *int
        isSet bool
}

func (v NullableInt) Get() *int <span class="cov0" title="0">{
        return v.value
}</span>

func (v *NullableInt) Set(val *int) <span class="cov0" title="0">{
        v.value = val
        v.isSet = true
}</span>

func (v NullableInt) IsSet() bool <span class="cov0" title="0">{
        return v.isSet
}</span>

func (v *NullableInt) Unset() <span class="cov0" title="0">{
        v.value = nil
        v.isSet = false
}</span>

func NewNullableInt(val *int) *NullableInt <span class="cov0" title="0">{
        return &amp;NullableInt{value: val, isSet: true}
}</span>

func (v NullableInt) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(v.value)
}</span>

func (v *NullableInt) UnmarshalJSON(src []byte) error <span class="cov0" title="0">{
        v.isSet = true
        return json.Unmarshal(src, &amp;v.value)
}</span>

type NullableInt32 struct {
        value *int32
        isSet bool
}

func (v NullableInt32) Get() *int32 <span class="cov0" title="0">{
        return v.value
}</span>

func (v *NullableInt32) Set(val *int32) <span class="cov0" title="0">{
        v.value = val
        v.isSet = true
}</span>

func (v NullableInt32) IsSet() bool <span class="cov0" title="0">{
        return v.isSet
}</span>

func (v *NullableInt32) Unset() <span class="cov0" title="0">{
        v.value = nil
        v.isSet = false
}</span>

func NewNullableInt32(val *int32) *NullableInt32 <span class="cov0" title="0">{
        return &amp;NullableInt32{value: val, isSet: true}
}</span>

func (v NullableInt32) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(v.value)
}</span>

func (v *NullableInt32) UnmarshalJSON(src []byte) error <span class="cov0" title="0">{
        v.isSet = true
        return json.Unmarshal(src, &amp;v.value)
}</span>

type NullableInt64 struct {
        value *int64
        isSet bool
}

func (v NullableInt64) Get() *int64 <span class="cov0" title="0">{
        return v.value
}</span>

func (v *NullableInt64) Set(val *int64) <span class="cov0" title="0">{
        v.value = val
        v.isSet = true
}</span>

func (v NullableInt64) IsSet() bool <span class="cov0" title="0">{
        return v.isSet
}</span>

func (v *NullableInt64) Unset() <span class="cov0" title="0">{
        v.value = nil
        v.isSet = false
}</span>

func NewNullableInt64(val *int64) *NullableInt64 <span class="cov0" title="0">{
        return &amp;NullableInt64{value: val, isSet: true}
}</span>

func (v NullableInt64) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(v.value)
}</span>

func (v *NullableInt64) UnmarshalJSON(src []byte) error <span class="cov0" title="0">{
        v.isSet = true
        return json.Unmarshal(src, &amp;v.value)
}</span>

type NullableFloat32 struct {
        value *float32
        isSet bool
}

func (v NullableFloat32) Get() *float32 <span class="cov0" title="0">{
        return v.value
}</span>

func (v *NullableFloat32) Set(val *float32) <span class="cov0" title="0">{
        v.value = val
        v.isSet = true
}</span>

func (v NullableFloat32) IsSet() bool <span class="cov0" title="0">{
        return v.isSet
}</span>

func (v *NullableFloat32) Unset() <span class="cov0" title="0">{
        v.value = nil
        v.isSet = false
}</span>

func NewNullableFloat32(val *float32) *NullableFloat32 <span class="cov0" title="0">{
        return &amp;NullableFloat32{value: val, isSet: true}
}</span>

func (v NullableFloat32) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(v.value)
}</span>

func (v *NullableFloat32) UnmarshalJSON(src []byte) error <span class="cov0" title="0">{
        v.isSet = true
        return json.Unmarshal(src, &amp;v.value)
}</span>

type NullableFloat64 struct {
        value *float64
        isSet bool
}

func (v NullableFloat64) Get() *float64 <span class="cov0" title="0">{
        return v.value
}</span>

func (v *NullableFloat64) Set(val *float64) <span class="cov0" title="0">{
        v.value = val
        v.isSet = true
}</span>

func (v NullableFloat64) IsSet() bool <span class="cov0" title="0">{
        return v.isSet
}</span>

func (v *NullableFloat64) Unset() <span class="cov0" title="0">{
        v.value = nil
        v.isSet = false
}</span>

func NewNullableFloat64(val *float64) *NullableFloat64 <span class="cov0" title="0">{
        return &amp;NullableFloat64{value: val, isSet: true}
}</span>

func (v NullableFloat64) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(v.value)
}</span>

func (v *NullableFloat64) UnmarshalJSON(src []byte) error <span class="cov0" title="0">{
        v.isSet = true
        return json.Unmarshal(src, &amp;v.value)
}</span>

type NullableString struct {
        value *string
        isSet bool
}

func (v NullableString) Get() *string <span class="cov0" title="0">{
        return v.value
}</span>

func (v *NullableString) Set(val *string) <span class="cov0" title="0">{
        v.value = val
        v.isSet = true
}</span>

func (v NullableString) IsSet() bool <span class="cov0" title="0">{
        return v.isSet
}</span>

func (v *NullableString) Unset() <span class="cov0" title="0">{
        v.value = nil
        v.isSet = false
}</span>

func NewNullableString(val *string) *NullableString <span class="cov10" title="12">{
        return &amp;NullableString{value: val, isSet: true}
}</span>

func (v NullableString) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(v.value)
}</span>

func (v *NullableString) UnmarshalJSON(src []byte) error <span class="cov0" title="0">{
        v.isSet = true
        return json.Unmarshal(src, &amp;v.value)
}</span>

type NullableTime struct {
        value *time.Time
        isSet bool
}

func (v NullableTime) Get() *time.Time <span class="cov0" title="0">{
        return v.value
}</span>

func (v *NullableTime) Set(val *time.Time) <span class="cov0" title="0">{
        v.value = val
        v.isSet = true
}</span>

func (v NullableTime) IsSet() bool <span class="cov0" title="0">{
        return v.isSet
}</span>

func (v *NullableTime) Unset() <span class="cov0" title="0">{
        v.value = nil
        v.isSet = false
}</span>

func NewNullableTime(val *time.Time) *NullableTime <span class="cov0" title="0">{
        return &amp;NullableTime{value: val, isSet: true}
}</span>

func (v NullableTime) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(v.value)
}</span>

func (v *NullableTime) UnmarshalJSON(src []byte) error <span class="cov0" title="0">{
        v.isSet = true
        return json.Unmarshal(src, &amp;v.value)
}</span>

// IsNil checks if an input is nil
func IsNil(i interface{}) bool <span class="cov0" title="0">{
        if i == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">switch reflect.TypeOf(i).Kind() </span>{
        case reflect.Chan, reflect.Func, reflect.Map, reflect.Ptr, reflect.UnsafePointer, reflect.Interface, reflect.Slice:<span class="cov0" title="0">
                return reflect.ValueOf(i).IsNil()</span>
        case reflect.Array:<span class="cov0" title="0">
                return reflect.ValueOf(i).IsZero()</span>
        }
        <span class="cov0" title="0">return false</span>
}

type MappedNullable interface {
        ToMap() (map[string]interface{}, error)
}

// A wrapper for strict JSON decoding
func newStrictDecoder(data []byte) *json.Decoder <span class="cov0" title="0">{
        dec := json.NewDecoder(bytes.NewBuffer(data))
        dec.DisallowUnknownFields()
        return dec
}</span>

// Prevent trying to import "fmt"
func reportError(format string, a ...interface{}) error <span class="cov0" title="0">{
        return fmt.Errorf(format, a...)
}</pre>
		
		<pre class="file" id="file76" style="display: none">package utility

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
)

// ComputeHMACSHA256 generates a SHA-256 HMAC hash using a secret and payload
func ComputeHMACSHA256(secret, payload string) string <span class="cov0" title="0">{
        // Create a new HMAC hash using SHA-256
        mac := hmac.New(sha256.New, []byte(secret))

        // Write the payload to the hash
        mac.Write([]byte(payload))

        // Get the final hash and convert to hex string
        return hex.EncodeToString(mac.Sum(nil))
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package utility

import "encoding/json"

func PrettyPrintJSON(data interface{}) string <span class="cov10" title="11">{
        bytes, _ := json.MarshalIndent(data, "", "  ")
        return string(bytes)
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">package utility

import (
        "context"
        "time"
)

func SleepWithContext(ctx context.Context, d time.Duration) <span class="cov10" title="146">{
        timer := time.NewTimer(d)
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                if !timer.Stop() </span><span class="cov0" title="0">{
                        &lt;-timer.C
                }</span>
        case &lt;-timer.C:<span class="cov9" title="144"></span>
        }
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package utility

import (
        "fmt"
        "strconv"
        "strings"
)

func ParseNumberString(s string) (int64, int64, error) <span class="cov10" title="6">{
        // Split the string by hyphen
        parts := strings.Split(s, "-")

        // Check if we have exactly 2 parts
        if len(parts) != 2 </span><span class="cov10" title="6">{
                return 0, 0, fmt.Errorf("invalid format: expected 'number-number', got '%s'", s)
        }</span>

        // Parse first number
        <span class="cov0" title="0">num1, err := strconv.ParseInt(parts[0], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("invalid first number: %v", err)
        }</span>

        // Parse second number
        <span class="cov0" title="0">num2, err := strconv.ParseInt(parts[1], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("invalid second number: %v", err)
        }</span>

        <span class="cov0" title="0">return num1, num2, nil</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package test_containers

import (
        "context"
        "github.com/stretchr/testify/require"
        "github.com/testcontainers/testcontainers-go/modules/rabbitmq"
        "testing"

        "github.com/testcontainers/testcontainers-go"
)

const TestRabbitMQUser = "tugas-akhir"
const TestRabbitMQPassword = "tugas-akhir"

type RabbitMQContainer struct {
        testcontainers.Container
}

func (r *RabbitMQContainer) Cleanup(t testing.TB) <span class="cov10" title="2">{
        testcontainers.CleanupContainer(t, r.Container)
}</span>

func NewRabbitMQContainer(ctx context.Context) (*RabbitMQContainer, error) <span class="cov10" title="2">{
        rabbitmqContainer, err := rabbitmq.Run(ctx,
                "rabbitmq:4.1.0-management",
                rabbitmq.WithAdminUsername(TestRabbitMQUser),
                rabbitmq.WithAdminPassword(TestRabbitMQPassword),
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="2">return &amp;RabbitMQContainer{
                Container: rabbitmqContainer.Container,
        }, nil</span>
}

func GetRabbitMQContainer(t *testing.T) *RabbitMQContainer <span class="cov10" title="2">{
        ctx := context.Background() // Use background for setup, test context can time out

        container, err := NewRabbitMQContainer(ctx)

        require.NoError(t, err, "Failed to set up Redis cluster")

        // Register cleanup function with the test
        t.Cleanup(func() </span><span class="cov10" title="2">{
                container.Cleanup(t)
        }</span>)

        <span class="cov10" title="2">return container</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package test_containers

import (
        "context"
        "fmt"
        "io"
        "log"
        "strings"
        "testing"
        "time"

        "tugas-akhir/backend/infrastructure/config"
        redisInfra "tugas-akhir/backend/infrastructure/redis"

        "github.com/docker/go-connections/nat"
        "github.com/stretchr/testify/require"

        "github.com/testcontainers/testcontainers-go"
        "github.com/testcontainers/testcontainers-go/network"
        "github.com/testcontainers/testcontainers-go/wait"
)

const (
        redisImage     = "redis:7.4"
        redisPort      = "6379/tcp"
        clusterBusPort = "16379/tcp"
        nodeCount      = 3
)

type RedisCluster struct {
        Containers []testcontainers.Container
        Network    *testcontainers.DockerNetwork
        MappedAddr []string // Stores ["host:port", "host:port", ...] for client connection
        AliasAddr  []string
}

func (rc *RedisCluster) Cleanup(t testing.TB) <span class="cov7" title="14">{
        ctx := context.Background() // Use background context for cleanup
        log.Println("Cleaning up Redis Cluster...")
        for i := len(rc.Containers) - 1; i &gt;= 0; i-- </span><span class="cov10" title="42">{
                if rc.Containers[i] != nil </span><span class="cov10" title="42">{
                        log.Printf("Terminating Redis container %d...", i+1)
                        if err := rc.Containers[i].Terminate(ctx); err != nil </span><span class="cov0" title="0">{
                                t.Errorf("Failed to terminate Redis container %d: %v", i+1, err)
                        }</span>
                }
        }
        <span class="cov7" title="14">if rc.Network != nil </span><span class="cov7" title="14">{
                log.Println("Removing network...")
                if err := rc.Network.Remove(ctx); err != nil </span><span class="cov0" title="0">{
                        t.Errorf("Failed to remove network: %v", err)
                }</span>
        }
        <span class="cov7" title="14">log.Println("Redis Cluster cleanup finished.")</span>
}

// NewRedisCluster sets up a 3-node Redis cluster
func NewRedisCluster(ctx context.Context) (*RedisCluster, error) <span class="cov7" title="14">{
        cluster := &amp;RedisCluster{
                Containers: make([]testcontainers.Container, nodeCount),
                MappedAddr: make([]string, nodeCount),
        }

        // 1. Create a new Docker network for the cluster nodes
        //log.Println("Creating Docker network for Redis Cluster...")
        net, err := network.New(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create network: %w", err)
        }</span>

        <span class="cov7" title="14">cluster.Network = net
        networkName := net.Name
        //log.Printf("Network '%s' created.", networkName)

        // Prepare node addresses for the cluster create command (using internal network aliases)
        nodeAddrsInternal := make([]string, nodeCount)
        nodeAliases := make([]string, nodeCount)

        // 2. Define and start each Redis node container
        for i := 0; i &lt; nodeCount; i++ </span><span class="cov10" title="42">{
                nodeAliases[i] = fmt.Sprintf("redis-node-%d", i+1)
                // Internal address will be like "redis-node-1:6379"
                nodeAddrsInternal[i] = fmt.Sprintf("%s:%s", nodeAliases[i], nat.Port(redisPort).Port())

                networkAlias := make(map[string][]string)

                networkAlias[networkName] = []string{nodeAliases[i]}

                req := testcontainers.ContainerRequest{
                        Image:          redisImage,
                        ExposedPorts:   []string{redisPort, clusterBusPort},
                        NetworkAliases: networkAlias,
                        Networks:       []string{networkName},
                        Cmd: []string{
                                "redis-server",
                                "--port", nat.Port(redisPort).Port(),
                                "--cluster-enabled", "yes",
                                "--cluster-config-file", fmt.Sprintf("/data/nodes-%d.conf", i+1), // Unique config file per node
                                "--cluster-node-timeout", "5000",
                                "--appendonly", "yes",
                                // Important for Docker: Announce the node's alias or IP within the Docker network
                                // Using alias is generally more reliable than trying to guess internal IP
                                "--cluster-announce-ip", nodeAliases[i], // Use alias for announcement
                                "--cluster-announce-port", nat.Port(redisPort).Port(),
                                "--cluster-announce-bus-port", nat.Port(clusterBusPort).Port(),
                        },
                        WaitingFor: wait.ForAll(
                                wait.ForLog("Ready to accept connections").WithStartupTimeout(20*time.Second),
                                wait.ForListeningPort(redisPort).WithStartupTimeout(10*time.Second),
                        ),
                }

                //log.Printf("Starting Redis container %d (%s)...", i+1, nodeAliases[i])
                container, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
                        ContainerRequest: req,
                        Started:          true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        for j := 0; j &lt; i; j++ </span><span class="cov0" title="0">{
                                _ = cluster.Containers[j].Terminate(ctx)
                        }</span>
                        <span class="cov0" title="0">_ = net.Remove(ctx)
                        return nil, fmt.Errorf("failed to start container %d (%s): %w", i+1, nodeAliases[i], err)</span>
                }
                <span class="cov10" title="42">cluster.Containers[i] = container
                //log.Printf("Redis container %d (%s) started.", i+1, nodeAliases[i])

                // Get mapped host and port for client connection
                host, err := container.Host(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get host for container %d: %w", i+1, err)
                }</span>
                <span class="cov10" title="42">mappedPort, err := container.MappedPort(ctx, redisPort)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get mapped port for container %d: %w", i+1, err)
                }</span>
                <span class="cov10" title="42">cluster.MappedAddr[i] = fmt.Sprintf("%s:%s", host, mappedPort.Port())</span>
                //log.Printf("Container %d (%s) accessible at: %s", i+1, nodeAliases[i], cluster.MappedAddr[i])
        }

        // 3. Create the cluster using redis-cli on the first node
        //log.Println("All Redis nodes started. Attempting cluster creation...")

        // Build the cluster create command arguments dynamically
        <span class="cov7" title="14">clusterCreateCmdArgs := []string{"redis-cli", "--cluster", "create"}
        clusterCreateCmdArgs = append(clusterCreateCmdArgs, nodeAddrsInternal...)
        clusterCreateCmdArgs = append(clusterCreateCmdArgs, "--cluster-replicas", "0", "--cluster-yes") // 0 replicas = all masters

        //log.Printf("Executing cluster create command on node 1: %v", clusterCreateCmdArgs)

        // Execute the command within the first container
        exitCode, cmdOutput, err := cluster.Containers[0].Exec(ctx, clusterCreateCmdArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute cluster create command: %w", err)
        }</span>

        // Read output
        <span class="cov7" title="14">outputBytes, readErr := io.ReadAll(cmdOutput)
        outputString := string(outputBytes)
        //log.Printf("Cluster create command output (Exit Code: %d):\n%s", exitCode, outputString)

        cluster.AliasAddr = nodeAliases

        for i, addr := range cluster.AliasAddr </span><span class="cov10" title="42">{
                cluster.AliasAddr[i] = fmt.Sprintf("%s:%s", addr, nat.Port(redisPort).Port())
        }</span>

        // Check if the command was successful
        <span class="cov7" title="14">if exitCode != 0 || !strings.Contains(outputString, "[OK] All 16384 slots covered.") </span><span class="cov0" title="0">{
                if readErr != nil </span><span class="cov0" title="0">{ // Include potential read error
                        return nil, fmt.Errorf("cluster create command failed with exit code %d and read error %v. Output: %s", exitCode, readErr, outputString)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("cluster create command failed with exit code %d. Output: %s", exitCode, outputString)</span>
        }

        <span class="cov7" title="14">log.Println("Redis Cluster created successfully!")
        return cluster, nil</span>
}

// GetRedisCluster sets up the 3-node cluster and returns a connected client
func GetRedisCluster(t *testing.T) *redisInfra.Redis <span class="cov7" title="14">{
        ctx := context.Background() // Use background for setup, test context can time out

        clusterSetupTimeout := 2 * time.Minute // Increase timeout for multi-node setup
        setupCtx, cancel := context.WithTimeout(ctx, clusterSetupTimeout)
        defer cancel()

        //log.Println("Setting up 3-node Redis Cluster...")
        cluster, err := NewRedisCluster(setupCtx)
        require.NoError(t, err, "Failed to set up Redis cluster")

        // Register cleanup function with the test
        t.Cleanup(func() </span><span class="cov7" title="14">{
                cluster.Cleanup(t)
        }</span>)

        //log.Println("Redis cluster nodes mapped addresses:", cluster.MappedAddr)

        <span class="cov7" title="14">cfg := config.Config{
                RedisHosts:    strings.Join(cluster.MappedAddr, ","),
                RedisHostsMap: strings.Join(cluster.AliasAddr, ","),
        }

        //log.Println("Connecting Redis client to cluster...")
        redisConn, err := redisInfra.NewRedis(&amp;cfg)
        require.NoError(t, err, "Failed to create Redis client")

        // Test client connection
        log.Println("Checking Redis client health...")

        // add some time to wair for redis cluster to be healthy
        time.Sleep(10 * time.Second)

        // Use test's context for health check if appropriate, or background if needed
        var healthcheckErr error

        for i := 0; i &lt; 10; i++ </span><span class="cov7" title="14">{
                healthErr := redisConn.IsHealthy(ctx)

                if healthErr != nil </span><span class="cov0" title="0">{
                        if i == 9 </span><span class="cov0" title="0">{
                                healthcheckErr = healthErr
                        }</span> else<span class="cov0" title="0"> {
                                time.Sleep(1 * time.Second)
                        }</span>
                } else<span class="cov7" title="14"> {
                        break</span>
                }
        }

        <span class="cov7" title="14">require.NoError(t, healthcheckErr, "Redis client health check failed")
        log.Println("Redis client connected and healthy.")

        return redisConn</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package test_containers

import (
        "context"
        "github.com/testcontainers/testcontainers-go"
        "github.com/testcontainers/testcontainers-go/modules/postgres"
        "github.com/testcontainers/testcontainers-go/modules/yugabytedb"
        "testing"
)

type RelationalDBVariant string

const (
        RelationalDBVariant__Postgres   RelationalDBVariant = "postgres"
        RelationalDBVariant__Citus      RelationalDBVariant = "citus"
        RelationalDBVariant__YugabyteDB RelationalDBVariant = "yugabytedb"
)

var RelationalDBVariants = []RelationalDBVariant{
        RelationalDBVariant__Postgres,
        RelationalDBVariant__Citus,
        RelationalDBVariant__YugabyteDB,
}

const TestDBName = "tugas-akhir"
const TestDBUser = "tugas-akhir"
const TestDBPassword = "tugas-akhir"
const TestYugabyteKeyspace = "tugas-akhir"

type RelationalDB struct {
        testcontainers.Container
        Variant RelationalDBVariant
}

func (r *RelationalDB) Cleanup(t testing.TB) <span class="cov10" title="11">{
        testcontainers.CleanupContainer(t, r.Container)
}</span>

func NewRelationalDB(ctx context.Context, variant RelationalDBVariant) (*RelationalDB, error) <span class="cov10" title="11">{
        var container testcontainers.Container
        var initerr error

        if variant == RelationalDBVariant__Postgres </span><span class="cov0" title="0">{
                container, initerr = postgres.Run(ctx,
                        "postgres:16",
                        postgres.WithDatabase(TestDBName),
                        postgres.WithUsername(TestDBUser),
                        postgres.WithPassword(TestDBPassword),
                        postgres.BasicWaitStrategies(),
                )
        }</span> else<span class="cov10" title="11"> if variant == RelationalDBVariant__Citus </span><span class="cov10" title="11">{
                container, initerr = postgres.Run(ctx,
                        "citusdata/citus:13.0.1-pg16",
                        postgres.WithDatabase(TestDBName),
                        postgres.WithUsername(TestDBUser),
                        postgres.WithPassword(TestDBPassword),
                        postgres.BasicWaitStrategies(),
                )
        }</span> else<span class="cov0" title="0"> if variant == RelationalDBVariant__YugabyteDB </span><span class="cov0" title="0">{
                container, initerr = yugabytedb.Run(
                        ctx,
                        "yugabytedb/yugabyte:2024.2.2.2-b2",
                        yugabytedb.WithKeyspace(TestYugabyteKeyspace),
                        yugabytedb.WithUser(TestDBUser),
                        yugabytedb.WithDatabaseName(TestDBName),
                        yugabytedb.WithDatabaseUser(TestDBUser),
                        yugabytedb.WithDatabasePassword(TestDBPassword),
                )
        }</span>

        <span class="cov10" title="11">if initerr != nil </span><span class="cov0" title="0">{
                return nil, initerr
        }</span>

        <span class="cov10" title="11">return &amp;RelationalDB{
                Container: container,
                Variant:   variant,
        }, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

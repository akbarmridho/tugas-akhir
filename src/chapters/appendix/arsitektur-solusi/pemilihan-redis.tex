\subsection{Penggunaan Redis dan Alternatifnya}

Saat ini terdapat berbagai solusi \textit{key-value store}, seperti Redis yang menyimpan data di memory dengan dukungan \textit{persistence}, etcd yang menyimpan data di \textit{storage} dan berbasiskan konsensus, serta LevelDB atau RocksDB yang merupakan \textit{embeddable kv store} yang \textit{persistent}. \textit{KV store} berbasis konsensus unggul dalam aspek \textit{persistence} dan \textit{consistency}, sedangkan Redis unggul dalam aspek \textit{throughput}. \textit{Embeddable kv store} seperti LevelDB atau RocksDB unggul apabila membutuhkan \textit{kv store} yang persistent secara lokal. Pemilihan satu solusi dengan yang lainnya memiliki berbagai \textit{trade off} yang harus dipelajari dengan hati-hati.

Pada ide solusi dengan pola penyeimbangan beban berbasiskan antrean, Redis digunakan untuk menyimpan \textit{uncommited data} dan menolak \textit{request} sebelum masuk antrean. Solusi ini membutuhkan \textit{kv store} dengan \textit{throughput} tinggi. Di antara ketiga solusi atas, Redis merupakan solusi dengan \textit{throughput} tertinggi. Selain itu, solusi ini dapat menoleransi \textit{eventual consistency} dan \textit{weak persistence}. \textit{Weak persistence} dalam hal ini adalah konfigurasi \textit{snapshotting} dan \textit{AOF} dengan penulisan yang dilakukan setiap detik. \textit{Weak persistence} tetap dibutuhkan agar pembangunan ulang data saat terjadi kegagalan dapat dilakukan dengan cepat. Penggunaan \textit{kv store} pada kasus ini juga dapat menoleransi \textit{data loss} karena pemeriksaan kedua tetap akan dilakukan pada saat pemrosesan. Oleh karena itu, Redis merupakan pendekatan yang paling menguntungkan dibandingkan dengan solusi yang lain.



Kenapa Redis dibandingkan dengan solusi KV lain

ini susah jir

local dengan replikasi (redis), consensus based,

Konsensus: etcd, TiKV

Persistent: LevelDB by Google, RocksDB (fork of LevelDB by Facebook)

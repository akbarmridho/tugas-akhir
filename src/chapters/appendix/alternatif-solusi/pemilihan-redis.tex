\section{Penggunaan Redis dan Alternatifnya}

Saat ini terdapat berbagai solusi \textit{key-value store}, seperti Redis yang menyimpan data di memory dengan dukungan \textit{persistence}, etcd yang menyimpan data di \textit{storage} dan berbasiskan konsensus, serta LevelDB atau RocksDB yang merupakan \textit{embeddable kv store} yang \textit{persistent}. \textit{KV store} berbasis konsensus unggul dalam aspek \textit{persistence} dan \textit{consistency}, sedangkan Redis unggul dalam aspek \textit{throughput}. \textit{Embeddable kv store} seperti LevelDB atau RocksDB unggul apabila membutuhkan \textit{kv store} yang persistent secara lokal. Pemilihan satu solusi dengan yang lainnya memiliki berbagai \textit{trade off} yang harus dipelajari dengan hati-hati.

Pada ide solusi dengan pola penyeimbangan beban berbasiskan antrean, Redis digunakan untuk menyimpan \textit{uncommited data} dan menolak \textit{request} sebelum masuk antrean. Solusi ini membutuhkan \textit{kv store} dengan \textit{throughput} tinggi. Di antara ketiga solusi atas, Redis merupakan solusi dengan \textit{throughput} tertinggi. Selain itu, solusi ini dapat menoleransi \textit{eventual consistency} dan \textit{weak persistence}. \textit{Weak persistence} dalam hal ini adalah konfigurasi \textit{snapshotting} dan \textit{AOF} dengan penulisan yang dilakukan setiap detik. \textit{Weak persistence} tetap dibutuhkan agar pembangunan ulang data saat terjadi kegagalan dapat dilakukan dengan cepat. Penggunaan \textit{kv store} pada kasus ini juga dapat menoleransi \textit{data loss} karena pemeriksaan kedua tetap akan dilakukan pada saat pemrosesan. Oleh karena itu, Redis merupakan pendekatan yang paling menguntungkan dibandingkan dengan solusi yang lain.

Pada ide \textit{event-driven architecture}, pemilihan \textit{kv store} menjadi lebih dilematis. Karena digunakan sebagai \textit{uncommited datastore} dan perannya cukup kritis untuk mencegah \textit{double booking}, \textit{kv store} harus mampu menawarkan \textit{persistence} dan \textit{consistency}. Meskipun begitu, fokus pada penelitian ini adalah mengoptimalkan arsitektur sehingga mampu menangani \textit{throughput} tinggi. Oleh karena itu, \textit{kv store} berbasiskan konsensus tidak digunakan karena masalah \textit{throughput} dan \textit{latency}. Meskipun begitu, solusi berbasiskan konsensus menawarkan \textit{fault tolerance} yang lebih baik dibandingkan dengan penggunaan Redis. \textit{Embeddable kv store} merupakan solusi yang cukup menarik karena menawarkan \textit{persistence}. Meskipun begitu, solusi ini terlalu \textit{low level} dan tidak menawarkan banyak fitur \textit{out of the box} dibandingkan dengan Redis, seperti fitur replikasi, \textit{clustering} untuk penskalaan horizontal, dan lain-lain. Redis unggul dalam aspek \textit{throughput}, \textit{clustering}, serta fleksibilitas dalam konfigurasi. Bila diperlukan, Redis mendukung \textit{persistence} (\texttt{fsync always, fsync everysec}) dan \textit{synchronous replication}, meski harus dibayarkan dengan \textit{throughput} yang jauh lebih rendah. Berdasarkan pertimbangan di atas, Redis kembali digunakan sebagai \textit{kv store}. Pada penggunaannya, terdapat beberapa aspek yang harus diperhatikan, seperti konsistensi, \textit{persistence}, serta mekanisme untuk menangani kegagalan.